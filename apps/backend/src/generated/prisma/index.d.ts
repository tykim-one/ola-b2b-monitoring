
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 사용자 계정
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 역할 (admin, analyst, viewer)
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 권한 (resource:action 형태)
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model UserRole
 * 사용자-역할 매핑 (Many-to-Many)
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model RolePermission
 * 역할-권한 매핑 (Many-to-Many)
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model RefreshToken
 * JWT 리프레시 토큰
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model SavedFilter
 * 저장된 데이터 필터
 */
export type SavedFilter = $Result.DefaultSelection<Prisma.$SavedFilterPayload>
/**
 * Model AnalysisSession
 * LLM 분석 세션
 */
export type AnalysisSession = $Result.DefaultSelection<Prisma.$AnalysisSessionPayload>
/**
 * Model AnalysisMessage
 * LLM 분석 대화 기록
 */
export type AnalysisMessage = $Result.DefaultSelection<Prisma.$AnalysisMessagePayload>
/**
 * Model AuditLog
 * 감사 로그 (90일 보관)
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model ApiKey
 * 외부 통합용 API 키 (마이그레이션 Phase 2용)
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model BatchAnalysisJob
 * 배치 분석 작업
 */
export type BatchAnalysisJob = $Result.DefaultSelection<Prisma.$BatchAnalysisJobPayload>
/**
 * Model BatchAnalysisResult
 * 개별 분석 결과
 */
export type BatchAnalysisResult = $Result.DefaultSelection<Prisma.$BatchAnalysisResultPayload>
/**
 * Model AnalysisPromptTemplate
 * 분석 프롬프트 템플릿
 */
export type AnalysisPromptTemplate = $Result.DefaultSelection<Prisma.$AnalysisPromptTemplatePayload>
/**
 * Model BatchSchedulerConfig
 * 배치 분석 스케줄러 설정
 */
export type BatchSchedulerConfig = $Result.DefaultSelection<Prisma.$BatchSchedulerConfigPayload>
/**
 * Model FAQAnalysisJob
 * FAQ 분석 작업
 */
export type FAQAnalysisJob = $Result.DefaultSelection<Prisma.$FAQAnalysisJobPayload>
/**
 * Model FAQAnalysisResult
 * FAQ 분석 결과 (클러스터)
 */
export type FAQAnalysisResult = $Result.DefaultSelection<Prisma.$FAQAnalysisResultPayload>
/**
 * Model UserProfile
 * 유저 프로필 요약 (배치 생성)
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model MessageCategoryAnalysis
 * 메시지별 카테고리 분석 결과
 */
export type MessageCategoryAnalysis = $Result.DefaultSelection<Prisma.$MessageCategoryAnalysisPayload>
/**
 * Model UserProfilingJob
 * 유저 프로필링 배치 작업
 */
export type UserProfilingJob = $Result.DefaultSelection<Prisma.$UserProfilingJobPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedFilter`: Exposes CRUD operations for the **SavedFilter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedFilters
    * const savedFilters = await prisma.savedFilter.findMany()
    * ```
    */
  get savedFilter(): Prisma.SavedFilterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analysisSession`: Exposes CRUD operations for the **AnalysisSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalysisSessions
    * const analysisSessions = await prisma.analysisSession.findMany()
    * ```
    */
  get analysisSession(): Prisma.AnalysisSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analysisMessage`: Exposes CRUD operations for the **AnalysisMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalysisMessages
    * const analysisMessages = await prisma.analysisMessage.findMany()
    * ```
    */
  get analysisMessage(): Prisma.AnalysisMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batchAnalysisJob`: Exposes CRUD operations for the **BatchAnalysisJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchAnalysisJobs
    * const batchAnalysisJobs = await prisma.batchAnalysisJob.findMany()
    * ```
    */
  get batchAnalysisJob(): Prisma.BatchAnalysisJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batchAnalysisResult`: Exposes CRUD operations for the **BatchAnalysisResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchAnalysisResults
    * const batchAnalysisResults = await prisma.batchAnalysisResult.findMany()
    * ```
    */
  get batchAnalysisResult(): Prisma.BatchAnalysisResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analysisPromptTemplate`: Exposes CRUD operations for the **AnalysisPromptTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalysisPromptTemplates
    * const analysisPromptTemplates = await prisma.analysisPromptTemplate.findMany()
    * ```
    */
  get analysisPromptTemplate(): Prisma.AnalysisPromptTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batchSchedulerConfig`: Exposes CRUD operations for the **BatchSchedulerConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchSchedulerConfigs
    * const batchSchedulerConfigs = await prisma.batchSchedulerConfig.findMany()
    * ```
    */
  get batchSchedulerConfig(): Prisma.BatchSchedulerConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fAQAnalysisJob`: Exposes CRUD operations for the **FAQAnalysisJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQAnalysisJobs
    * const fAQAnalysisJobs = await prisma.fAQAnalysisJob.findMany()
    * ```
    */
  get fAQAnalysisJob(): Prisma.FAQAnalysisJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fAQAnalysisResult`: Exposes CRUD operations for the **FAQAnalysisResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQAnalysisResults
    * const fAQAnalysisResults = await prisma.fAQAnalysisResult.findMany()
    * ```
    */
  get fAQAnalysisResult(): Prisma.FAQAnalysisResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageCategoryAnalysis`: Exposes CRUD operations for the **MessageCategoryAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageCategoryAnalyses
    * const messageCategoryAnalyses = await prisma.messageCategoryAnalysis.findMany()
    * ```
    */
  get messageCategoryAnalysis(): Prisma.MessageCategoryAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfilingJob`: Exposes CRUD operations for the **UserProfilingJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfilingJobs
    * const userProfilingJobs = await prisma.userProfilingJob.findMany()
    * ```
    */
  get userProfilingJob(): Prisma.UserProfilingJobDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    Permission: 'Permission',
    UserRole: 'UserRole',
    RolePermission: 'RolePermission',
    RefreshToken: 'RefreshToken',
    SavedFilter: 'SavedFilter',
    AnalysisSession: 'AnalysisSession',
    AnalysisMessage: 'AnalysisMessage',
    AuditLog: 'AuditLog',
    ApiKey: 'ApiKey',
    BatchAnalysisJob: 'BatchAnalysisJob',
    BatchAnalysisResult: 'BatchAnalysisResult',
    AnalysisPromptTemplate: 'AnalysisPromptTemplate',
    BatchSchedulerConfig: 'BatchSchedulerConfig',
    FAQAnalysisJob: 'FAQAnalysisJob',
    FAQAnalysisResult: 'FAQAnalysisResult',
    UserProfile: 'UserProfile',
    MessageCategoryAnalysis: 'MessageCategoryAnalysis',
    UserProfilingJob: 'UserProfilingJob'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "permission" | "userRole" | "rolePermission" | "refreshToken" | "savedFilter" | "analysisSession" | "analysisMessage" | "auditLog" | "apiKey" | "batchAnalysisJob" | "batchAnalysisResult" | "analysisPromptTemplate" | "batchSchedulerConfig" | "fAQAnalysisJob" | "fAQAnalysisResult" | "userProfile" | "messageCategoryAnalysis" | "userProfilingJob"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      SavedFilter: {
        payload: Prisma.$SavedFilterPayload<ExtArgs>
        fields: Prisma.SavedFilterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedFilterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedFilterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          findFirst: {
            args: Prisma.SavedFilterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedFilterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          findMany: {
            args: Prisma.SavedFilterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>[]
          }
          create: {
            args: Prisma.SavedFilterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          createMany: {
            args: Prisma.SavedFilterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedFilterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>[]
          }
          delete: {
            args: Prisma.SavedFilterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          update: {
            args: Prisma.SavedFilterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          deleteMany: {
            args: Prisma.SavedFilterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedFilterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SavedFilterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>[]
          }
          upsert: {
            args: Prisma.SavedFilterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          aggregate: {
            args: Prisma.SavedFilterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedFilter>
          }
          groupBy: {
            args: Prisma.SavedFilterGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedFilterGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedFilterCountArgs<ExtArgs>
            result: $Utils.Optional<SavedFilterCountAggregateOutputType> | number
          }
        }
      }
      AnalysisSession: {
        payload: Prisma.$AnalysisSessionPayload<ExtArgs>
        fields: Prisma.AnalysisSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalysisSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalysisSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisSessionPayload>
          }
          findFirst: {
            args: Prisma.AnalysisSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalysisSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisSessionPayload>
          }
          findMany: {
            args: Prisma.AnalysisSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisSessionPayload>[]
          }
          create: {
            args: Prisma.AnalysisSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisSessionPayload>
          }
          createMany: {
            args: Prisma.AnalysisSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalysisSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisSessionPayload>[]
          }
          delete: {
            args: Prisma.AnalysisSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisSessionPayload>
          }
          update: {
            args: Prisma.AnalysisSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisSessionPayload>
          }
          deleteMany: {
            args: Prisma.AnalysisSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalysisSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalysisSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisSessionPayload>[]
          }
          upsert: {
            args: Prisma.AnalysisSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisSessionPayload>
          }
          aggregate: {
            args: Prisma.AnalysisSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalysisSession>
          }
          groupBy: {
            args: Prisma.AnalysisSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalysisSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalysisSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AnalysisSessionCountAggregateOutputType> | number
          }
        }
      }
      AnalysisMessage: {
        payload: Prisma.$AnalysisMessagePayload<ExtArgs>
        fields: Prisma.AnalysisMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalysisMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalysisMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisMessagePayload>
          }
          findFirst: {
            args: Prisma.AnalysisMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalysisMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisMessagePayload>
          }
          findMany: {
            args: Prisma.AnalysisMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisMessagePayload>[]
          }
          create: {
            args: Prisma.AnalysisMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisMessagePayload>
          }
          createMany: {
            args: Prisma.AnalysisMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalysisMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisMessagePayload>[]
          }
          delete: {
            args: Prisma.AnalysisMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisMessagePayload>
          }
          update: {
            args: Prisma.AnalysisMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisMessagePayload>
          }
          deleteMany: {
            args: Prisma.AnalysisMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalysisMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalysisMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisMessagePayload>[]
          }
          upsert: {
            args: Prisma.AnalysisMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisMessagePayload>
          }
          aggregate: {
            args: Prisma.AnalysisMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalysisMessage>
          }
          groupBy: {
            args: Prisma.AnalysisMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalysisMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalysisMessageCountArgs<ExtArgs>
            result: $Utils.Optional<AnalysisMessageCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      BatchAnalysisJob: {
        payload: Prisma.$BatchAnalysisJobPayload<ExtArgs>
        fields: Prisma.BatchAnalysisJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchAnalysisJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchAnalysisJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisJobPayload>
          }
          findFirst: {
            args: Prisma.BatchAnalysisJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchAnalysisJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisJobPayload>
          }
          findMany: {
            args: Prisma.BatchAnalysisJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisJobPayload>[]
          }
          create: {
            args: Prisma.BatchAnalysisJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisJobPayload>
          }
          createMany: {
            args: Prisma.BatchAnalysisJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchAnalysisJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisJobPayload>[]
          }
          delete: {
            args: Prisma.BatchAnalysisJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisJobPayload>
          }
          update: {
            args: Prisma.BatchAnalysisJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisJobPayload>
          }
          deleteMany: {
            args: Prisma.BatchAnalysisJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchAnalysisJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchAnalysisJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisJobPayload>[]
          }
          upsert: {
            args: Prisma.BatchAnalysisJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisJobPayload>
          }
          aggregate: {
            args: Prisma.BatchAnalysisJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchAnalysisJob>
          }
          groupBy: {
            args: Prisma.BatchAnalysisJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchAnalysisJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchAnalysisJobCountArgs<ExtArgs>
            result: $Utils.Optional<BatchAnalysisJobCountAggregateOutputType> | number
          }
        }
      }
      BatchAnalysisResult: {
        payload: Prisma.$BatchAnalysisResultPayload<ExtArgs>
        fields: Prisma.BatchAnalysisResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchAnalysisResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchAnalysisResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisResultPayload>
          }
          findFirst: {
            args: Prisma.BatchAnalysisResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchAnalysisResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisResultPayload>
          }
          findMany: {
            args: Prisma.BatchAnalysisResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisResultPayload>[]
          }
          create: {
            args: Prisma.BatchAnalysisResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisResultPayload>
          }
          createMany: {
            args: Prisma.BatchAnalysisResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchAnalysisResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisResultPayload>[]
          }
          delete: {
            args: Prisma.BatchAnalysisResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisResultPayload>
          }
          update: {
            args: Prisma.BatchAnalysisResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisResultPayload>
          }
          deleteMany: {
            args: Prisma.BatchAnalysisResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchAnalysisResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchAnalysisResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisResultPayload>[]
          }
          upsert: {
            args: Prisma.BatchAnalysisResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchAnalysisResultPayload>
          }
          aggregate: {
            args: Prisma.BatchAnalysisResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchAnalysisResult>
          }
          groupBy: {
            args: Prisma.BatchAnalysisResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchAnalysisResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchAnalysisResultCountArgs<ExtArgs>
            result: $Utils.Optional<BatchAnalysisResultCountAggregateOutputType> | number
          }
        }
      }
      AnalysisPromptTemplate: {
        payload: Prisma.$AnalysisPromptTemplatePayload<ExtArgs>
        fields: Prisma.AnalysisPromptTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalysisPromptTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPromptTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalysisPromptTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPromptTemplatePayload>
          }
          findFirst: {
            args: Prisma.AnalysisPromptTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPromptTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalysisPromptTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPromptTemplatePayload>
          }
          findMany: {
            args: Prisma.AnalysisPromptTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPromptTemplatePayload>[]
          }
          create: {
            args: Prisma.AnalysisPromptTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPromptTemplatePayload>
          }
          createMany: {
            args: Prisma.AnalysisPromptTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalysisPromptTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPromptTemplatePayload>[]
          }
          delete: {
            args: Prisma.AnalysisPromptTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPromptTemplatePayload>
          }
          update: {
            args: Prisma.AnalysisPromptTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPromptTemplatePayload>
          }
          deleteMany: {
            args: Prisma.AnalysisPromptTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalysisPromptTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalysisPromptTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPromptTemplatePayload>[]
          }
          upsert: {
            args: Prisma.AnalysisPromptTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisPromptTemplatePayload>
          }
          aggregate: {
            args: Prisma.AnalysisPromptTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalysisPromptTemplate>
          }
          groupBy: {
            args: Prisma.AnalysisPromptTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalysisPromptTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalysisPromptTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<AnalysisPromptTemplateCountAggregateOutputType> | number
          }
        }
      }
      BatchSchedulerConfig: {
        payload: Prisma.$BatchSchedulerConfigPayload<ExtArgs>
        fields: Prisma.BatchSchedulerConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchSchedulerConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchSchedulerConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchSchedulerConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchSchedulerConfigPayload>
          }
          findFirst: {
            args: Prisma.BatchSchedulerConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchSchedulerConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchSchedulerConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchSchedulerConfigPayload>
          }
          findMany: {
            args: Prisma.BatchSchedulerConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchSchedulerConfigPayload>[]
          }
          create: {
            args: Prisma.BatchSchedulerConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchSchedulerConfigPayload>
          }
          createMany: {
            args: Prisma.BatchSchedulerConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchSchedulerConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchSchedulerConfigPayload>[]
          }
          delete: {
            args: Prisma.BatchSchedulerConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchSchedulerConfigPayload>
          }
          update: {
            args: Prisma.BatchSchedulerConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchSchedulerConfigPayload>
          }
          deleteMany: {
            args: Prisma.BatchSchedulerConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchSchedulerConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchSchedulerConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchSchedulerConfigPayload>[]
          }
          upsert: {
            args: Prisma.BatchSchedulerConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchSchedulerConfigPayload>
          }
          aggregate: {
            args: Prisma.BatchSchedulerConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchSchedulerConfig>
          }
          groupBy: {
            args: Prisma.BatchSchedulerConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchSchedulerConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchSchedulerConfigCountArgs<ExtArgs>
            result: $Utils.Optional<BatchSchedulerConfigCountAggregateOutputType> | number
          }
        }
      }
      FAQAnalysisJob: {
        payload: Prisma.$FAQAnalysisJobPayload<ExtArgs>
        fields: Prisma.FAQAnalysisJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQAnalysisJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQAnalysisJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisJobPayload>
          }
          findFirst: {
            args: Prisma.FAQAnalysisJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQAnalysisJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisJobPayload>
          }
          findMany: {
            args: Prisma.FAQAnalysisJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisJobPayload>[]
          }
          create: {
            args: Prisma.FAQAnalysisJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisJobPayload>
          }
          createMany: {
            args: Prisma.FAQAnalysisJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FAQAnalysisJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisJobPayload>[]
          }
          delete: {
            args: Prisma.FAQAnalysisJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisJobPayload>
          }
          update: {
            args: Prisma.FAQAnalysisJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisJobPayload>
          }
          deleteMany: {
            args: Prisma.FAQAnalysisJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FAQAnalysisJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FAQAnalysisJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisJobPayload>[]
          }
          upsert: {
            args: Prisma.FAQAnalysisJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisJobPayload>
          }
          aggregate: {
            args: Prisma.FAQAnalysisJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFAQAnalysisJob>
          }
          groupBy: {
            args: Prisma.FAQAnalysisJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<FAQAnalysisJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQAnalysisJobCountArgs<ExtArgs>
            result: $Utils.Optional<FAQAnalysisJobCountAggregateOutputType> | number
          }
        }
      }
      FAQAnalysisResult: {
        payload: Prisma.$FAQAnalysisResultPayload<ExtArgs>
        fields: Prisma.FAQAnalysisResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQAnalysisResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQAnalysisResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisResultPayload>
          }
          findFirst: {
            args: Prisma.FAQAnalysisResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQAnalysisResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisResultPayload>
          }
          findMany: {
            args: Prisma.FAQAnalysisResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisResultPayload>[]
          }
          create: {
            args: Prisma.FAQAnalysisResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisResultPayload>
          }
          createMany: {
            args: Prisma.FAQAnalysisResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FAQAnalysisResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisResultPayload>[]
          }
          delete: {
            args: Prisma.FAQAnalysisResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisResultPayload>
          }
          update: {
            args: Prisma.FAQAnalysisResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisResultPayload>
          }
          deleteMany: {
            args: Prisma.FAQAnalysisResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FAQAnalysisResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FAQAnalysisResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisResultPayload>[]
          }
          upsert: {
            args: Prisma.FAQAnalysisResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQAnalysisResultPayload>
          }
          aggregate: {
            args: Prisma.FAQAnalysisResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFAQAnalysisResult>
          }
          groupBy: {
            args: Prisma.FAQAnalysisResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<FAQAnalysisResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQAnalysisResultCountArgs<ExtArgs>
            result: $Utils.Optional<FAQAnalysisResultCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      MessageCategoryAnalysis: {
        payload: Prisma.$MessageCategoryAnalysisPayload<ExtArgs>
        fields: Prisma.MessageCategoryAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageCategoryAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageCategoryAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryAnalysisPayload>
          }
          findFirst: {
            args: Prisma.MessageCategoryAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageCategoryAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryAnalysisPayload>
          }
          findMany: {
            args: Prisma.MessageCategoryAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryAnalysisPayload>[]
          }
          create: {
            args: Prisma.MessageCategoryAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryAnalysisPayload>
          }
          createMany: {
            args: Prisma.MessageCategoryAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCategoryAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryAnalysisPayload>[]
          }
          delete: {
            args: Prisma.MessageCategoryAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryAnalysisPayload>
          }
          update: {
            args: Prisma.MessageCategoryAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.MessageCategoryAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageCategoryAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageCategoryAnalysisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryAnalysisPayload>[]
          }
          upsert: {
            args: Prisma.MessageCategoryAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageCategoryAnalysisPayload>
          }
          aggregate: {
            args: Prisma.MessageCategoryAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageCategoryAnalysis>
          }
          groupBy: {
            args: Prisma.MessageCategoryAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageCategoryAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCategoryAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCategoryAnalysisCountAggregateOutputType> | number
          }
        }
      }
      UserProfilingJob: {
        payload: Prisma.$UserProfilingJobPayload<ExtArgs>
        fields: Prisma.UserProfilingJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfilingJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilingJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfilingJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilingJobPayload>
          }
          findFirst: {
            args: Prisma.UserProfilingJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilingJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfilingJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilingJobPayload>
          }
          findMany: {
            args: Prisma.UserProfilingJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilingJobPayload>[]
          }
          create: {
            args: Prisma.UserProfilingJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilingJobPayload>
          }
          createMany: {
            args: Prisma.UserProfilingJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfilingJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilingJobPayload>[]
          }
          delete: {
            args: Prisma.UserProfilingJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilingJobPayload>
          }
          update: {
            args: Prisma.UserProfilingJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilingJobPayload>
          }
          deleteMany: {
            args: Prisma.UserProfilingJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfilingJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfilingJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilingJobPayload>[]
          }
          upsert: {
            args: Prisma.UserProfilingJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilingJobPayload>
          }
          aggregate: {
            args: Prisma.UserProfilingJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfilingJob>
          }
          groupBy: {
            args: Prisma.UserProfilingJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfilingJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfilingJobCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfilingJobCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    permission?: PermissionOmit
    userRole?: UserRoleOmit
    rolePermission?: RolePermissionOmit
    refreshToken?: RefreshTokenOmit
    savedFilter?: SavedFilterOmit
    analysisSession?: AnalysisSessionOmit
    analysisMessage?: AnalysisMessageOmit
    auditLog?: AuditLogOmit
    apiKey?: ApiKeyOmit
    batchAnalysisJob?: BatchAnalysisJobOmit
    batchAnalysisResult?: BatchAnalysisResultOmit
    analysisPromptTemplate?: AnalysisPromptTemplateOmit
    batchSchedulerConfig?: BatchSchedulerConfigOmit
    fAQAnalysisJob?: FAQAnalysisJobOmit
    fAQAnalysisResult?: FAQAnalysisResultOmit
    userProfile?: UserProfileOmit
    messageCategoryAnalysis?: MessageCategoryAnalysisOmit
    userProfilingJob?: UserProfilingJobOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userRoles: number
    refreshTokens: number
    savedFilters: number
    analysisSessions: number
    auditLogs: number
    apiKeys: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    savedFilters?: boolean | UserCountOutputTypeCountSavedFiltersArgs
    analysisSessions?: boolean | UserCountOutputTypeCountAnalysisSessionsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedFiltersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedFilterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnalysisSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userRoles: number
    rolePermissions: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
    rolePermissions?: boolean | RoleCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolePermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | PermissionCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type AnalysisSessionCountOutputType
   */

  export type AnalysisSessionCountOutputType = {
    messages: number
  }

  export type AnalysisSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AnalysisSessionCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * AnalysisSessionCountOutputType without action
   */
  export type AnalysisSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSessionCountOutputType
     */
    select?: AnalysisSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnalysisSessionCountOutputType without action
   */
  export type AnalysisSessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisMessageWhereInput
  }


  /**
   * Count Type BatchAnalysisJobCountOutputType
   */

  export type BatchAnalysisJobCountOutputType = {
    results: number
  }

  export type BatchAnalysisJobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | BatchAnalysisJobCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * BatchAnalysisJobCountOutputType without action
   */
  export type BatchAnalysisJobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJobCountOutputType
     */
    select?: BatchAnalysisJobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BatchAnalysisJobCountOutputType without action
   */
  export type BatchAnalysisJobCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchAnalysisResultWhereInput
  }


  /**
   * Count Type FAQAnalysisJobCountOutputType
   */

  export type FAQAnalysisJobCountOutputType = {
    results: number
  }

  export type FAQAnalysisJobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | FAQAnalysisJobCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * FAQAnalysisJobCountOutputType without action
   */
  export type FAQAnalysisJobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJobCountOutputType
     */
    select?: FAQAnalysisJobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FAQAnalysisJobCountOutputType without action
   */
  export type FAQAnalysisJobCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQAnalysisResultWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failedAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    failedAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    isActive: boolean | null
    failedAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    isActive: boolean | null
    failedAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    isActive: number
    failedAttempts: number
    lockedUntil: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failedAttempts?: true
  }

  export type UserSumAggregateInputType = {
    failedAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isActive?: true
    failedAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isActive?: true
    failedAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    isActive?: true
    failedAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    isActive: boolean
    failedAttempts: number
    lockedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isActive?: boolean
    failedAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    savedFilters?: boolean | User$savedFiltersArgs<ExtArgs>
    analysisSessions?: boolean | User$analysisSessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isActive?: boolean
    failedAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isActive?: boolean
    failedAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    isActive?: boolean
    failedAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "isActive" | "failedAttempts" | "lockedUntil" | "createdAt" | "updatedAt" | "lastLoginAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    savedFilters?: boolean | User$savedFiltersArgs<ExtArgs>
    analysisSessions?: boolean | User$analysisSessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      savedFilters: Prisma.$SavedFilterPayload<ExtArgs>[]
      analysisSessions: Prisma.$AnalysisSessionPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      isActive: boolean
      failedAttempts: number
      lockedUntil: Date | null
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedFilters<T extends User$savedFiltersArgs<ExtArgs> = {}>(args?: Subset<T, User$savedFiltersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analysisSessions<T extends User$analysisSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$analysisSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly failedAttempts: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.savedFilters
   */
  export type User$savedFiltersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterInclude<ExtArgs> | null
    where?: SavedFilterWhereInput
    orderBy?: SavedFilterOrderByWithRelationInput | SavedFilterOrderByWithRelationInput[]
    cursor?: SavedFilterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedFilterScalarFieldEnum | SavedFilterScalarFieldEnum[]
  }

  /**
   * User.analysisSessions
   */
  export type User$analysisSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionInclude<ExtArgs> | null
    where?: AnalysisSessionWhereInput
    orderBy?: AnalysisSessionOrderByWithRelationInput | AnalysisSessionOrderByWithRelationInput[]
    cursor?: AnalysisSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalysisSessionScalarFieldEnum | AnalysisSessionScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rolePermissions<T extends Role$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role.rolePermissions
   */
  export type Role$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Permission$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.rolePermissions
   */
  export type Permission$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    createdAt: Date | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    createdAt: Date | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    createdAt: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    createdAt: Date
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roleId" | "createdAt", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      createdAt: Date
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly createdAt: FieldRef<"UserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    createdAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "permissionId" | "createdAt", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
      createdAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission updateManyAndReturn
   */
  export type RolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    revokedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    createdAt: Date
    revokedAt: Date | null
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "createdAt" | "revokedAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      createdAt: Date
      revokedAt: Date | null
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model SavedFilter
   */

  export type AggregateSavedFilter = {
    _count: SavedFilterCountAggregateOutputType | null
    _min: SavedFilterMinAggregateOutputType | null
    _max: SavedFilterMaxAggregateOutputType | null
  }

  export type SavedFilterMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    criteria: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedFilterMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    criteria: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedFilterCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    criteria: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SavedFilterMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    criteria?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedFilterMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    criteria?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedFilterCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    criteria?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SavedFilterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedFilter to aggregate.
     */
    where?: SavedFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedFilters to fetch.
     */
    orderBy?: SavedFilterOrderByWithRelationInput | SavedFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedFilters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedFilters
    **/
    _count?: true | SavedFilterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedFilterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedFilterMaxAggregateInputType
  }

  export type GetSavedFilterAggregateType<T extends SavedFilterAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedFilter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedFilter[P]>
      : GetScalarType<T[P], AggregateSavedFilter[P]>
  }




  export type SavedFilterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedFilterWhereInput
    orderBy?: SavedFilterOrderByWithAggregationInput | SavedFilterOrderByWithAggregationInput[]
    by: SavedFilterScalarFieldEnum[] | SavedFilterScalarFieldEnum
    having?: SavedFilterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedFilterCountAggregateInputType | true
    _min?: SavedFilterMinAggregateInputType
    _max?: SavedFilterMaxAggregateInputType
  }

  export type SavedFilterGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    criteria: string
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: SavedFilterCountAggregateOutputType | null
    _min: SavedFilterMinAggregateOutputType | null
    _max: SavedFilterMaxAggregateOutputType | null
  }

  type GetSavedFilterGroupByPayload<T extends SavedFilterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedFilterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedFilterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedFilterGroupByOutputType[P]>
            : GetScalarType<T[P], SavedFilterGroupByOutputType[P]>
        }
      >
    >


  export type SavedFilterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    criteria?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedFilter"]>

  export type SavedFilterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    criteria?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedFilter"]>

  export type SavedFilterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    criteria?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedFilter"]>

  export type SavedFilterSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    criteria?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SavedFilterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "criteria" | "isDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["savedFilter"]>
  export type SavedFilterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SavedFilterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SavedFilterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SavedFilterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedFilter"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      criteria: string
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["savedFilter"]>
    composites: {}
  }

  type SavedFilterGetPayload<S extends boolean | null | undefined | SavedFilterDefaultArgs> = $Result.GetResult<Prisma.$SavedFilterPayload, S>

  type SavedFilterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SavedFilterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedFilterCountAggregateInputType | true
    }

  export interface SavedFilterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedFilter'], meta: { name: 'SavedFilter' } }
    /**
     * Find zero or one SavedFilter that matches the filter.
     * @param {SavedFilterFindUniqueArgs} args - Arguments to find a SavedFilter
     * @example
     * // Get one SavedFilter
     * const savedFilter = await prisma.savedFilter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedFilterFindUniqueArgs>(args: SelectSubset<T, SavedFilterFindUniqueArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SavedFilter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SavedFilterFindUniqueOrThrowArgs} args - Arguments to find a SavedFilter
     * @example
     * // Get one SavedFilter
     * const savedFilter = await prisma.savedFilter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedFilterFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedFilterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedFilter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterFindFirstArgs} args - Arguments to find a SavedFilter
     * @example
     * // Get one SavedFilter
     * const savedFilter = await prisma.savedFilter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedFilterFindFirstArgs>(args?: SelectSubset<T, SavedFilterFindFirstArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedFilter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterFindFirstOrThrowArgs} args - Arguments to find a SavedFilter
     * @example
     * // Get one SavedFilter
     * const savedFilter = await prisma.savedFilter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedFilterFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedFilterFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedFilters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedFilters
     * const savedFilters = await prisma.savedFilter.findMany()
     * 
     * // Get first 10 SavedFilters
     * const savedFilters = await prisma.savedFilter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedFilterWithIdOnly = await prisma.savedFilter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedFilterFindManyArgs>(args?: SelectSubset<T, SavedFilterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SavedFilter.
     * @param {SavedFilterCreateArgs} args - Arguments to create a SavedFilter.
     * @example
     * // Create one SavedFilter
     * const SavedFilter = await prisma.savedFilter.create({
     *   data: {
     *     // ... data to create a SavedFilter
     *   }
     * })
     * 
     */
    create<T extends SavedFilterCreateArgs>(args: SelectSubset<T, SavedFilterCreateArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SavedFilters.
     * @param {SavedFilterCreateManyArgs} args - Arguments to create many SavedFilters.
     * @example
     * // Create many SavedFilters
     * const savedFilter = await prisma.savedFilter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedFilterCreateManyArgs>(args?: SelectSubset<T, SavedFilterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedFilters and returns the data saved in the database.
     * @param {SavedFilterCreateManyAndReturnArgs} args - Arguments to create many SavedFilters.
     * @example
     * // Create many SavedFilters
     * const savedFilter = await prisma.savedFilter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedFilters and only return the `id`
     * const savedFilterWithIdOnly = await prisma.savedFilter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedFilterCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedFilterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SavedFilter.
     * @param {SavedFilterDeleteArgs} args - Arguments to delete one SavedFilter.
     * @example
     * // Delete one SavedFilter
     * const SavedFilter = await prisma.savedFilter.delete({
     *   where: {
     *     // ... filter to delete one SavedFilter
     *   }
     * })
     * 
     */
    delete<T extends SavedFilterDeleteArgs>(args: SelectSubset<T, SavedFilterDeleteArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SavedFilter.
     * @param {SavedFilterUpdateArgs} args - Arguments to update one SavedFilter.
     * @example
     * // Update one SavedFilter
     * const savedFilter = await prisma.savedFilter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedFilterUpdateArgs>(args: SelectSubset<T, SavedFilterUpdateArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SavedFilters.
     * @param {SavedFilterDeleteManyArgs} args - Arguments to filter SavedFilters to delete.
     * @example
     * // Delete a few SavedFilters
     * const { count } = await prisma.savedFilter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedFilterDeleteManyArgs>(args?: SelectSubset<T, SavedFilterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedFilters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedFilters
     * const savedFilter = await prisma.savedFilter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedFilterUpdateManyArgs>(args: SelectSubset<T, SavedFilterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedFilters and returns the data updated in the database.
     * @param {SavedFilterUpdateManyAndReturnArgs} args - Arguments to update many SavedFilters.
     * @example
     * // Update many SavedFilters
     * const savedFilter = await prisma.savedFilter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SavedFilters and only return the `id`
     * const savedFilterWithIdOnly = await prisma.savedFilter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SavedFilterUpdateManyAndReturnArgs>(args: SelectSubset<T, SavedFilterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SavedFilter.
     * @param {SavedFilterUpsertArgs} args - Arguments to update or create a SavedFilter.
     * @example
     * // Update or create a SavedFilter
     * const savedFilter = await prisma.savedFilter.upsert({
     *   create: {
     *     // ... data to create a SavedFilter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedFilter we want to update
     *   }
     * })
     */
    upsert<T extends SavedFilterUpsertArgs>(args: SelectSubset<T, SavedFilterUpsertArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SavedFilters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterCountArgs} args - Arguments to filter SavedFilters to count.
     * @example
     * // Count the number of SavedFilters
     * const count = await prisma.savedFilter.count({
     *   where: {
     *     // ... the filter for the SavedFilters we want to count
     *   }
     * })
    **/
    count<T extends SavedFilterCountArgs>(
      args?: Subset<T, SavedFilterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedFilterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedFilter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedFilterAggregateArgs>(args: Subset<T, SavedFilterAggregateArgs>): Prisma.PrismaPromise<GetSavedFilterAggregateType<T>>

    /**
     * Group by SavedFilter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedFilterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedFilterGroupByArgs['orderBy'] }
        : { orderBy?: SavedFilterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedFilterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedFilterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedFilter model
   */
  readonly fields: SavedFilterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedFilter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedFilterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedFilter model
   */
  interface SavedFilterFieldRefs {
    readonly id: FieldRef<"SavedFilter", 'String'>
    readonly userId: FieldRef<"SavedFilter", 'String'>
    readonly name: FieldRef<"SavedFilter", 'String'>
    readonly description: FieldRef<"SavedFilter", 'String'>
    readonly criteria: FieldRef<"SavedFilter", 'String'>
    readonly isDefault: FieldRef<"SavedFilter", 'Boolean'>
    readonly createdAt: FieldRef<"SavedFilter", 'DateTime'>
    readonly updatedAt: FieldRef<"SavedFilter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedFilter findUnique
   */
  export type SavedFilterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterInclude<ExtArgs> | null
    /**
     * Filter, which SavedFilter to fetch.
     */
    where: SavedFilterWhereUniqueInput
  }

  /**
   * SavedFilter findUniqueOrThrow
   */
  export type SavedFilterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterInclude<ExtArgs> | null
    /**
     * Filter, which SavedFilter to fetch.
     */
    where: SavedFilterWhereUniqueInput
  }

  /**
   * SavedFilter findFirst
   */
  export type SavedFilterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterInclude<ExtArgs> | null
    /**
     * Filter, which SavedFilter to fetch.
     */
    where?: SavedFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedFilters to fetch.
     */
    orderBy?: SavedFilterOrderByWithRelationInput | SavedFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedFilters.
     */
    cursor?: SavedFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedFilters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedFilters.
     */
    distinct?: SavedFilterScalarFieldEnum | SavedFilterScalarFieldEnum[]
  }

  /**
   * SavedFilter findFirstOrThrow
   */
  export type SavedFilterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterInclude<ExtArgs> | null
    /**
     * Filter, which SavedFilter to fetch.
     */
    where?: SavedFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedFilters to fetch.
     */
    orderBy?: SavedFilterOrderByWithRelationInput | SavedFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedFilters.
     */
    cursor?: SavedFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedFilters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedFilters.
     */
    distinct?: SavedFilterScalarFieldEnum | SavedFilterScalarFieldEnum[]
  }

  /**
   * SavedFilter findMany
   */
  export type SavedFilterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterInclude<ExtArgs> | null
    /**
     * Filter, which SavedFilters to fetch.
     */
    where?: SavedFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedFilters to fetch.
     */
    orderBy?: SavedFilterOrderByWithRelationInput | SavedFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedFilters.
     */
    cursor?: SavedFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedFilters.
     */
    skip?: number
    distinct?: SavedFilterScalarFieldEnum | SavedFilterScalarFieldEnum[]
  }

  /**
   * SavedFilter create
   */
  export type SavedFilterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedFilter.
     */
    data: XOR<SavedFilterCreateInput, SavedFilterUncheckedCreateInput>
  }

  /**
   * SavedFilter createMany
   */
  export type SavedFilterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedFilters.
     */
    data: SavedFilterCreateManyInput | SavedFilterCreateManyInput[]
  }

  /**
   * SavedFilter createManyAndReturn
   */
  export type SavedFilterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * The data used to create many SavedFilters.
     */
    data: SavedFilterCreateManyInput | SavedFilterCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedFilter update
   */
  export type SavedFilterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedFilter.
     */
    data: XOR<SavedFilterUpdateInput, SavedFilterUncheckedUpdateInput>
    /**
     * Choose, which SavedFilter to update.
     */
    where: SavedFilterWhereUniqueInput
  }

  /**
   * SavedFilter updateMany
   */
  export type SavedFilterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedFilters.
     */
    data: XOR<SavedFilterUpdateManyMutationInput, SavedFilterUncheckedUpdateManyInput>
    /**
     * Filter which SavedFilters to update
     */
    where?: SavedFilterWhereInput
    /**
     * Limit how many SavedFilters to update.
     */
    limit?: number
  }

  /**
   * SavedFilter updateManyAndReturn
   */
  export type SavedFilterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * The data used to update SavedFilters.
     */
    data: XOR<SavedFilterUpdateManyMutationInput, SavedFilterUncheckedUpdateManyInput>
    /**
     * Filter which SavedFilters to update
     */
    where?: SavedFilterWhereInput
    /**
     * Limit how many SavedFilters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedFilter upsert
   */
  export type SavedFilterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedFilter to update in case it exists.
     */
    where: SavedFilterWhereUniqueInput
    /**
     * In case the SavedFilter found by the `where` argument doesn't exist, create a new SavedFilter with this data.
     */
    create: XOR<SavedFilterCreateInput, SavedFilterUncheckedCreateInput>
    /**
     * In case the SavedFilter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedFilterUpdateInput, SavedFilterUncheckedUpdateInput>
  }

  /**
   * SavedFilter delete
   */
  export type SavedFilterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterInclude<ExtArgs> | null
    /**
     * Filter which SavedFilter to delete.
     */
    where: SavedFilterWhereUniqueInput
  }

  /**
   * SavedFilter deleteMany
   */
  export type SavedFilterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedFilters to delete
     */
    where?: SavedFilterWhereInput
    /**
     * Limit how many SavedFilters to delete.
     */
    limit?: number
  }

  /**
   * SavedFilter without action
   */
  export type SavedFilterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedFilterInclude<ExtArgs> | null
  }


  /**
   * Model AnalysisSession
   */

  export type AggregateAnalysisSession = {
    _count: AnalysisSessionCountAggregateOutputType | null
    _min: AnalysisSessionMinAggregateOutputType | null
    _max: AnalysisSessionMaxAggregateOutputType | null
  }

  export type AnalysisSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    context: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalysisSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    context: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalysisSessionCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    context: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalysisSessionMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    context?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalysisSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    context?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalysisSessionCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    context?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalysisSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisSession to aggregate.
     */
    where?: AnalysisSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisSessions to fetch.
     */
    orderBy?: AnalysisSessionOrderByWithRelationInput | AnalysisSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalysisSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalysisSessions
    **/
    _count?: true | AnalysisSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalysisSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalysisSessionMaxAggregateInputType
  }

  export type GetAnalysisSessionAggregateType<T extends AnalysisSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalysisSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalysisSession[P]>
      : GetScalarType<T[P], AggregateAnalysisSession[P]>
  }




  export type AnalysisSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisSessionWhereInput
    orderBy?: AnalysisSessionOrderByWithAggregationInput | AnalysisSessionOrderByWithAggregationInput[]
    by: AnalysisSessionScalarFieldEnum[] | AnalysisSessionScalarFieldEnum
    having?: AnalysisSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalysisSessionCountAggregateInputType | true
    _min?: AnalysisSessionMinAggregateInputType
    _max?: AnalysisSessionMaxAggregateInputType
  }

  export type AnalysisSessionGroupByOutputType = {
    id: string
    userId: string
    title: string
    context: string | null
    createdAt: Date
    updatedAt: Date
    _count: AnalysisSessionCountAggregateOutputType | null
    _min: AnalysisSessionMinAggregateOutputType | null
    _max: AnalysisSessionMaxAggregateOutputType | null
  }

  type GetAnalysisSessionGroupByPayload<T extends AnalysisSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalysisSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalysisSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalysisSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AnalysisSessionGroupByOutputType[P]>
        }
      >
    >


  export type AnalysisSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    context?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | AnalysisSession$messagesArgs<ExtArgs>
    _count?: boolean | AnalysisSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisSession"]>

  export type AnalysisSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    context?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisSession"]>

  export type AnalysisSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    context?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisSession"]>

  export type AnalysisSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    context?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalysisSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "context" | "createdAt" | "updatedAt", ExtArgs["result"]["analysisSession"]>
  export type AnalysisSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | AnalysisSession$messagesArgs<ExtArgs>
    _count?: boolean | AnalysisSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnalysisSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnalysisSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnalysisSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalysisSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$AnalysisMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      context: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analysisSession"]>
    composites: {}
  }

  type AnalysisSessionGetPayload<S extends boolean | null | undefined | AnalysisSessionDefaultArgs> = $Result.GetResult<Prisma.$AnalysisSessionPayload, S>

  type AnalysisSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalysisSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalysisSessionCountAggregateInputType | true
    }

  export interface AnalysisSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalysisSession'], meta: { name: 'AnalysisSession' } }
    /**
     * Find zero or one AnalysisSession that matches the filter.
     * @param {AnalysisSessionFindUniqueArgs} args - Arguments to find a AnalysisSession
     * @example
     * // Get one AnalysisSession
     * const analysisSession = await prisma.analysisSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalysisSessionFindUniqueArgs>(args: SelectSubset<T, AnalysisSessionFindUniqueArgs<ExtArgs>>): Prisma__AnalysisSessionClient<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalysisSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalysisSessionFindUniqueOrThrowArgs} args - Arguments to find a AnalysisSession
     * @example
     * // Get one AnalysisSession
     * const analysisSession = await prisma.analysisSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalysisSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalysisSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalysisSessionClient<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisSessionFindFirstArgs} args - Arguments to find a AnalysisSession
     * @example
     * // Get one AnalysisSession
     * const analysisSession = await prisma.analysisSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalysisSessionFindFirstArgs>(args?: SelectSubset<T, AnalysisSessionFindFirstArgs<ExtArgs>>): Prisma__AnalysisSessionClient<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisSessionFindFirstOrThrowArgs} args - Arguments to find a AnalysisSession
     * @example
     * // Get one AnalysisSession
     * const analysisSession = await prisma.analysisSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalysisSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalysisSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalysisSessionClient<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalysisSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalysisSessions
     * const analysisSessions = await prisma.analysisSession.findMany()
     * 
     * // Get first 10 AnalysisSessions
     * const analysisSessions = await prisma.analysisSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analysisSessionWithIdOnly = await prisma.analysisSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalysisSessionFindManyArgs>(args?: SelectSubset<T, AnalysisSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalysisSession.
     * @param {AnalysisSessionCreateArgs} args - Arguments to create a AnalysisSession.
     * @example
     * // Create one AnalysisSession
     * const AnalysisSession = await prisma.analysisSession.create({
     *   data: {
     *     // ... data to create a AnalysisSession
     *   }
     * })
     * 
     */
    create<T extends AnalysisSessionCreateArgs>(args: SelectSubset<T, AnalysisSessionCreateArgs<ExtArgs>>): Prisma__AnalysisSessionClient<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalysisSessions.
     * @param {AnalysisSessionCreateManyArgs} args - Arguments to create many AnalysisSessions.
     * @example
     * // Create many AnalysisSessions
     * const analysisSession = await prisma.analysisSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalysisSessionCreateManyArgs>(args?: SelectSubset<T, AnalysisSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalysisSessions and returns the data saved in the database.
     * @param {AnalysisSessionCreateManyAndReturnArgs} args - Arguments to create many AnalysisSessions.
     * @example
     * // Create many AnalysisSessions
     * const analysisSession = await prisma.analysisSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalysisSessions and only return the `id`
     * const analysisSessionWithIdOnly = await prisma.analysisSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalysisSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalysisSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalysisSession.
     * @param {AnalysisSessionDeleteArgs} args - Arguments to delete one AnalysisSession.
     * @example
     * // Delete one AnalysisSession
     * const AnalysisSession = await prisma.analysisSession.delete({
     *   where: {
     *     // ... filter to delete one AnalysisSession
     *   }
     * })
     * 
     */
    delete<T extends AnalysisSessionDeleteArgs>(args: SelectSubset<T, AnalysisSessionDeleteArgs<ExtArgs>>): Prisma__AnalysisSessionClient<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalysisSession.
     * @param {AnalysisSessionUpdateArgs} args - Arguments to update one AnalysisSession.
     * @example
     * // Update one AnalysisSession
     * const analysisSession = await prisma.analysisSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalysisSessionUpdateArgs>(args: SelectSubset<T, AnalysisSessionUpdateArgs<ExtArgs>>): Prisma__AnalysisSessionClient<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalysisSessions.
     * @param {AnalysisSessionDeleteManyArgs} args - Arguments to filter AnalysisSessions to delete.
     * @example
     * // Delete a few AnalysisSessions
     * const { count } = await prisma.analysisSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalysisSessionDeleteManyArgs>(args?: SelectSubset<T, AnalysisSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalysisSessions
     * const analysisSession = await prisma.analysisSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalysisSessionUpdateManyArgs>(args: SelectSubset<T, AnalysisSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisSessions and returns the data updated in the database.
     * @param {AnalysisSessionUpdateManyAndReturnArgs} args - Arguments to update many AnalysisSessions.
     * @example
     * // Update many AnalysisSessions
     * const analysisSession = await prisma.analysisSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalysisSessions and only return the `id`
     * const analysisSessionWithIdOnly = await prisma.analysisSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalysisSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalysisSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalysisSession.
     * @param {AnalysisSessionUpsertArgs} args - Arguments to update or create a AnalysisSession.
     * @example
     * // Update or create a AnalysisSession
     * const analysisSession = await prisma.analysisSession.upsert({
     *   create: {
     *     // ... data to create a AnalysisSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalysisSession we want to update
     *   }
     * })
     */
    upsert<T extends AnalysisSessionUpsertArgs>(args: SelectSubset<T, AnalysisSessionUpsertArgs<ExtArgs>>): Prisma__AnalysisSessionClient<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalysisSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisSessionCountArgs} args - Arguments to filter AnalysisSessions to count.
     * @example
     * // Count the number of AnalysisSessions
     * const count = await prisma.analysisSession.count({
     *   where: {
     *     // ... the filter for the AnalysisSessions we want to count
     *   }
     * })
    **/
    count<T extends AnalysisSessionCountArgs>(
      args?: Subset<T, AnalysisSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalysisSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalysisSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalysisSessionAggregateArgs>(args: Subset<T, AnalysisSessionAggregateArgs>): Prisma.PrismaPromise<GetAnalysisSessionAggregateType<T>>

    /**
     * Group by AnalysisSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalysisSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalysisSessionGroupByArgs['orderBy'] }
        : { orderBy?: AnalysisSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalysisSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalysisSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalysisSession model
   */
  readonly fields: AnalysisSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalysisSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalysisSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends AnalysisSession$messagesArgs<ExtArgs> = {}>(args?: Subset<T, AnalysisSession$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalysisSession model
   */
  interface AnalysisSessionFieldRefs {
    readonly id: FieldRef<"AnalysisSession", 'String'>
    readonly userId: FieldRef<"AnalysisSession", 'String'>
    readonly title: FieldRef<"AnalysisSession", 'String'>
    readonly context: FieldRef<"AnalysisSession", 'String'>
    readonly createdAt: FieldRef<"AnalysisSession", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalysisSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalysisSession findUnique
   */
  export type AnalysisSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisSession to fetch.
     */
    where: AnalysisSessionWhereUniqueInput
  }

  /**
   * AnalysisSession findUniqueOrThrow
   */
  export type AnalysisSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisSession to fetch.
     */
    where: AnalysisSessionWhereUniqueInput
  }

  /**
   * AnalysisSession findFirst
   */
  export type AnalysisSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisSession to fetch.
     */
    where?: AnalysisSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisSessions to fetch.
     */
    orderBy?: AnalysisSessionOrderByWithRelationInput | AnalysisSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisSessions.
     */
    cursor?: AnalysisSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisSessions.
     */
    distinct?: AnalysisSessionScalarFieldEnum | AnalysisSessionScalarFieldEnum[]
  }

  /**
   * AnalysisSession findFirstOrThrow
   */
  export type AnalysisSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisSession to fetch.
     */
    where?: AnalysisSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisSessions to fetch.
     */
    orderBy?: AnalysisSessionOrderByWithRelationInput | AnalysisSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisSessions.
     */
    cursor?: AnalysisSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisSessions.
     */
    distinct?: AnalysisSessionScalarFieldEnum | AnalysisSessionScalarFieldEnum[]
  }

  /**
   * AnalysisSession findMany
   */
  export type AnalysisSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisSessions to fetch.
     */
    where?: AnalysisSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisSessions to fetch.
     */
    orderBy?: AnalysisSessionOrderByWithRelationInput | AnalysisSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalysisSessions.
     */
    cursor?: AnalysisSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisSessions.
     */
    skip?: number
    distinct?: AnalysisSessionScalarFieldEnum | AnalysisSessionScalarFieldEnum[]
  }

  /**
   * AnalysisSession create
   */
  export type AnalysisSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalysisSession.
     */
    data: XOR<AnalysisSessionCreateInput, AnalysisSessionUncheckedCreateInput>
  }

  /**
   * AnalysisSession createMany
   */
  export type AnalysisSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalysisSessions.
     */
    data: AnalysisSessionCreateManyInput | AnalysisSessionCreateManyInput[]
  }

  /**
   * AnalysisSession createManyAndReturn
   */
  export type AnalysisSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AnalysisSessions.
     */
    data: AnalysisSessionCreateManyInput | AnalysisSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalysisSession update
   */
  export type AnalysisSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalysisSession.
     */
    data: XOR<AnalysisSessionUpdateInput, AnalysisSessionUncheckedUpdateInput>
    /**
     * Choose, which AnalysisSession to update.
     */
    where: AnalysisSessionWhereUniqueInput
  }

  /**
   * AnalysisSession updateMany
   */
  export type AnalysisSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalysisSessions.
     */
    data: XOR<AnalysisSessionUpdateManyMutationInput, AnalysisSessionUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisSessions to update
     */
    where?: AnalysisSessionWhereInput
    /**
     * Limit how many AnalysisSessions to update.
     */
    limit?: number
  }

  /**
   * AnalysisSession updateManyAndReturn
   */
  export type AnalysisSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * The data used to update AnalysisSessions.
     */
    data: XOR<AnalysisSessionUpdateManyMutationInput, AnalysisSessionUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisSessions to update
     */
    where?: AnalysisSessionWhereInput
    /**
     * Limit how many AnalysisSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalysisSession upsert
   */
  export type AnalysisSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalysisSession to update in case it exists.
     */
    where: AnalysisSessionWhereUniqueInput
    /**
     * In case the AnalysisSession found by the `where` argument doesn't exist, create a new AnalysisSession with this data.
     */
    create: XOR<AnalysisSessionCreateInput, AnalysisSessionUncheckedCreateInput>
    /**
     * In case the AnalysisSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalysisSessionUpdateInput, AnalysisSessionUncheckedUpdateInput>
  }

  /**
   * AnalysisSession delete
   */
  export type AnalysisSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionInclude<ExtArgs> | null
    /**
     * Filter which AnalysisSession to delete.
     */
    where: AnalysisSessionWhereUniqueInput
  }

  /**
   * AnalysisSession deleteMany
   */
  export type AnalysisSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisSessions to delete
     */
    where?: AnalysisSessionWhereInput
    /**
     * Limit how many AnalysisSessions to delete.
     */
    limit?: number
  }

  /**
   * AnalysisSession.messages
   */
  export type AnalysisSession$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageInclude<ExtArgs> | null
    where?: AnalysisMessageWhereInput
    orderBy?: AnalysisMessageOrderByWithRelationInput | AnalysisMessageOrderByWithRelationInput[]
    cursor?: AnalysisMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalysisMessageScalarFieldEnum | AnalysisMessageScalarFieldEnum[]
  }

  /**
   * AnalysisSession without action
   */
  export type AnalysisSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisSession
     */
    select?: AnalysisSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisSession
     */
    omit?: AnalysisSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisSessionInclude<ExtArgs> | null
  }


  /**
   * Model AnalysisMessage
   */

  export type AggregateAnalysisMessage = {
    _count: AnalysisMessageCountAggregateOutputType | null
    _min: AnalysisMessageMinAggregateOutputType | null
    _max: AnalysisMessageMaxAggregateOutputType | null
  }

  export type AnalysisMessageMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    role: string | null
    content: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type AnalysisMessageMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    role: string | null
    content: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type AnalysisMessageCountAggregateOutputType = {
    id: number
    sessionId: number
    role: number
    content: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AnalysisMessageMinAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    metadata?: true
    createdAt?: true
  }

  export type AnalysisMessageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    metadata?: true
    createdAt?: true
  }

  export type AnalysisMessageCountAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AnalysisMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisMessage to aggregate.
     */
    where?: AnalysisMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisMessages to fetch.
     */
    orderBy?: AnalysisMessageOrderByWithRelationInput | AnalysisMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalysisMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalysisMessages
    **/
    _count?: true | AnalysisMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalysisMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalysisMessageMaxAggregateInputType
  }

  export type GetAnalysisMessageAggregateType<T extends AnalysisMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalysisMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalysisMessage[P]>
      : GetScalarType<T[P], AggregateAnalysisMessage[P]>
  }




  export type AnalysisMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisMessageWhereInput
    orderBy?: AnalysisMessageOrderByWithAggregationInput | AnalysisMessageOrderByWithAggregationInput[]
    by: AnalysisMessageScalarFieldEnum[] | AnalysisMessageScalarFieldEnum
    having?: AnalysisMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalysisMessageCountAggregateInputType | true
    _min?: AnalysisMessageMinAggregateInputType
    _max?: AnalysisMessageMaxAggregateInputType
  }

  export type AnalysisMessageGroupByOutputType = {
    id: string
    sessionId: string
    role: string
    content: string
    metadata: string | null
    createdAt: Date
    _count: AnalysisMessageCountAggregateOutputType | null
    _min: AnalysisMessageMinAggregateOutputType | null
    _max: AnalysisMessageMaxAggregateOutputType | null
  }

  type GetAnalysisMessageGroupByPayload<T extends AnalysisMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalysisMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalysisMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalysisMessageGroupByOutputType[P]>
            : GetScalarType<T[P], AnalysisMessageGroupByOutputType[P]>
        }
      >
    >


  export type AnalysisMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    session?: boolean | AnalysisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisMessage"]>

  export type AnalysisMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    session?: boolean | AnalysisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisMessage"]>

  export type AnalysisMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    session?: boolean | AnalysisSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisMessage"]>

  export type AnalysisMessageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AnalysisMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "role" | "content" | "metadata" | "createdAt", ExtArgs["result"]["analysisMessage"]>
  export type AnalysisMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AnalysisSessionDefaultArgs<ExtArgs>
  }
  export type AnalysisMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AnalysisSessionDefaultArgs<ExtArgs>
  }
  export type AnalysisMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AnalysisSessionDefaultArgs<ExtArgs>
  }

  export type $AnalysisMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalysisMessage"
    objects: {
      session: Prisma.$AnalysisSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      role: string
      content: string
      metadata: string | null
      createdAt: Date
    }, ExtArgs["result"]["analysisMessage"]>
    composites: {}
  }

  type AnalysisMessageGetPayload<S extends boolean | null | undefined | AnalysisMessageDefaultArgs> = $Result.GetResult<Prisma.$AnalysisMessagePayload, S>

  type AnalysisMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalysisMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalysisMessageCountAggregateInputType | true
    }

  export interface AnalysisMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalysisMessage'], meta: { name: 'AnalysisMessage' } }
    /**
     * Find zero or one AnalysisMessage that matches the filter.
     * @param {AnalysisMessageFindUniqueArgs} args - Arguments to find a AnalysisMessage
     * @example
     * // Get one AnalysisMessage
     * const analysisMessage = await prisma.analysisMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalysisMessageFindUniqueArgs>(args: SelectSubset<T, AnalysisMessageFindUniqueArgs<ExtArgs>>): Prisma__AnalysisMessageClient<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalysisMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalysisMessageFindUniqueOrThrowArgs} args - Arguments to find a AnalysisMessage
     * @example
     * // Get one AnalysisMessage
     * const analysisMessage = await prisma.analysisMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalysisMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalysisMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalysisMessageClient<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisMessageFindFirstArgs} args - Arguments to find a AnalysisMessage
     * @example
     * // Get one AnalysisMessage
     * const analysisMessage = await prisma.analysisMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalysisMessageFindFirstArgs>(args?: SelectSubset<T, AnalysisMessageFindFirstArgs<ExtArgs>>): Prisma__AnalysisMessageClient<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisMessageFindFirstOrThrowArgs} args - Arguments to find a AnalysisMessage
     * @example
     * // Get one AnalysisMessage
     * const analysisMessage = await prisma.analysisMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalysisMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalysisMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalysisMessageClient<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalysisMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalysisMessages
     * const analysisMessages = await prisma.analysisMessage.findMany()
     * 
     * // Get first 10 AnalysisMessages
     * const analysisMessages = await prisma.analysisMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analysisMessageWithIdOnly = await prisma.analysisMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalysisMessageFindManyArgs>(args?: SelectSubset<T, AnalysisMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalysisMessage.
     * @param {AnalysisMessageCreateArgs} args - Arguments to create a AnalysisMessage.
     * @example
     * // Create one AnalysisMessage
     * const AnalysisMessage = await prisma.analysisMessage.create({
     *   data: {
     *     // ... data to create a AnalysisMessage
     *   }
     * })
     * 
     */
    create<T extends AnalysisMessageCreateArgs>(args: SelectSubset<T, AnalysisMessageCreateArgs<ExtArgs>>): Prisma__AnalysisMessageClient<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalysisMessages.
     * @param {AnalysisMessageCreateManyArgs} args - Arguments to create many AnalysisMessages.
     * @example
     * // Create many AnalysisMessages
     * const analysisMessage = await prisma.analysisMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalysisMessageCreateManyArgs>(args?: SelectSubset<T, AnalysisMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalysisMessages and returns the data saved in the database.
     * @param {AnalysisMessageCreateManyAndReturnArgs} args - Arguments to create many AnalysisMessages.
     * @example
     * // Create many AnalysisMessages
     * const analysisMessage = await prisma.analysisMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalysisMessages and only return the `id`
     * const analysisMessageWithIdOnly = await prisma.analysisMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalysisMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalysisMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalysisMessage.
     * @param {AnalysisMessageDeleteArgs} args - Arguments to delete one AnalysisMessage.
     * @example
     * // Delete one AnalysisMessage
     * const AnalysisMessage = await prisma.analysisMessage.delete({
     *   where: {
     *     // ... filter to delete one AnalysisMessage
     *   }
     * })
     * 
     */
    delete<T extends AnalysisMessageDeleteArgs>(args: SelectSubset<T, AnalysisMessageDeleteArgs<ExtArgs>>): Prisma__AnalysisMessageClient<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalysisMessage.
     * @param {AnalysisMessageUpdateArgs} args - Arguments to update one AnalysisMessage.
     * @example
     * // Update one AnalysisMessage
     * const analysisMessage = await prisma.analysisMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalysisMessageUpdateArgs>(args: SelectSubset<T, AnalysisMessageUpdateArgs<ExtArgs>>): Prisma__AnalysisMessageClient<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalysisMessages.
     * @param {AnalysisMessageDeleteManyArgs} args - Arguments to filter AnalysisMessages to delete.
     * @example
     * // Delete a few AnalysisMessages
     * const { count } = await prisma.analysisMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalysisMessageDeleteManyArgs>(args?: SelectSubset<T, AnalysisMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalysisMessages
     * const analysisMessage = await prisma.analysisMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalysisMessageUpdateManyArgs>(args: SelectSubset<T, AnalysisMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisMessages and returns the data updated in the database.
     * @param {AnalysisMessageUpdateManyAndReturnArgs} args - Arguments to update many AnalysisMessages.
     * @example
     * // Update many AnalysisMessages
     * const analysisMessage = await prisma.analysisMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalysisMessages and only return the `id`
     * const analysisMessageWithIdOnly = await prisma.analysisMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalysisMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalysisMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalysisMessage.
     * @param {AnalysisMessageUpsertArgs} args - Arguments to update or create a AnalysisMessage.
     * @example
     * // Update or create a AnalysisMessage
     * const analysisMessage = await prisma.analysisMessage.upsert({
     *   create: {
     *     // ... data to create a AnalysisMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalysisMessage we want to update
     *   }
     * })
     */
    upsert<T extends AnalysisMessageUpsertArgs>(args: SelectSubset<T, AnalysisMessageUpsertArgs<ExtArgs>>): Prisma__AnalysisMessageClient<$Result.GetResult<Prisma.$AnalysisMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalysisMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisMessageCountArgs} args - Arguments to filter AnalysisMessages to count.
     * @example
     * // Count the number of AnalysisMessages
     * const count = await prisma.analysisMessage.count({
     *   where: {
     *     // ... the filter for the AnalysisMessages we want to count
     *   }
     * })
    **/
    count<T extends AnalysisMessageCountArgs>(
      args?: Subset<T, AnalysisMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalysisMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalysisMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalysisMessageAggregateArgs>(args: Subset<T, AnalysisMessageAggregateArgs>): Prisma.PrismaPromise<GetAnalysisMessageAggregateType<T>>

    /**
     * Group by AnalysisMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalysisMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalysisMessageGroupByArgs['orderBy'] }
        : { orderBy?: AnalysisMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalysisMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalysisMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalysisMessage model
   */
  readonly fields: AnalysisMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalysisMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalysisMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends AnalysisSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnalysisSessionDefaultArgs<ExtArgs>>): Prisma__AnalysisSessionClient<$Result.GetResult<Prisma.$AnalysisSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalysisMessage model
   */
  interface AnalysisMessageFieldRefs {
    readonly id: FieldRef<"AnalysisMessage", 'String'>
    readonly sessionId: FieldRef<"AnalysisMessage", 'String'>
    readonly role: FieldRef<"AnalysisMessage", 'String'>
    readonly content: FieldRef<"AnalysisMessage", 'String'>
    readonly metadata: FieldRef<"AnalysisMessage", 'String'>
    readonly createdAt: FieldRef<"AnalysisMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalysisMessage findUnique
   */
  export type AnalysisMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisMessage to fetch.
     */
    where: AnalysisMessageWhereUniqueInput
  }

  /**
   * AnalysisMessage findUniqueOrThrow
   */
  export type AnalysisMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisMessage to fetch.
     */
    where: AnalysisMessageWhereUniqueInput
  }

  /**
   * AnalysisMessage findFirst
   */
  export type AnalysisMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisMessage to fetch.
     */
    where?: AnalysisMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisMessages to fetch.
     */
    orderBy?: AnalysisMessageOrderByWithRelationInput | AnalysisMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisMessages.
     */
    cursor?: AnalysisMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisMessages.
     */
    distinct?: AnalysisMessageScalarFieldEnum | AnalysisMessageScalarFieldEnum[]
  }

  /**
   * AnalysisMessage findFirstOrThrow
   */
  export type AnalysisMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisMessage to fetch.
     */
    where?: AnalysisMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisMessages to fetch.
     */
    orderBy?: AnalysisMessageOrderByWithRelationInput | AnalysisMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisMessages.
     */
    cursor?: AnalysisMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisMessages.
     */
    distinct?: AnalysisMessageScalarFieldEnum | AnalysisMessageScalarFieldEnum[]
  }

  /**
   * AnalysisMessage findMany
   */
  export type AnalysisMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisMessages to fetch.
     */
    where?: AnalysisMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisMessages to fetch.
     */
    orderBy?: AnalysisMessageOrderByWithRelationInput | AnalysisMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalysisMessages.
     */
    cursor?: AnalysisMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisMessages.
     */
    skip?: number
    distinct?: AnalysisMessageScalarFieldEnum | AnalysisMessageScalarFieldEnum[]
  }

  /**
   * AnalysisMessage create
   */
  export type AnalysisMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalysisMessage.
     */
    data: XOR<AnalysisMessageCreateInput, AnalysisMessageUncheckedCreateInput>
  }

  /**
   * AnalysisMessage createMany
   */
  export type AnalysisMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalysisMessages.
     */
    data: AnalysisMessageCreateManyInput | AnalysisMessageCreateManyInput[]
  }

  /**
   * AnalysisMessage createManyAndReturn
   */
  export type AnalysisMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * The data used to create many AnalysisMessages.
     */
    data: AnalysisMessageCreateManyInput | AnalysisMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalysisMessage update
   */
  export type AnalysisMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalysisMessage.
     */
    data: XOR<AnalysisMessageUpdateInput, AnalysisMessageUncheckedUpdateInput>
    /**
     * Choose, which AnalysisMessage to update.
     */
    where: AnalysisMessageWhereUniqueInput
  }

  /**
   * AnalysisMessage updateMany
   */
  export type AnalysisMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalysisMessages.
     */
    data: XOR<AnalysisMessageUpdateManyMutationInput, AnalysisMessageUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisMessages to update
     */
    where?: AnalysisMessageWhereInput
    /**
     * Limit how many AnalysisMessages to update.
     */
    limit?: number
  }

  /**
   * AnalysisMessage updateManyAndReturn
   */
  export type AnalysisMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * The data used to update AnalysisMessages.
     */
    data: XOR<AnalysisMessageUpdateManyMutationInput, AnalysisMessageUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisMessages to update
     */
    where?: AnalysisMessageWhereInput
    /**
     * Limit how many AnalysisMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalysisMessage upsert
   */
  export type AnalysisMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalysisMessage to update in case it exists.
     */
    where: AnalysisMessageWhereUniqueInput
    /**
     * In case the AnalysisMessage found by the `where` argument doesn't exist, create a new AnalysisMessage with this data.
     */
    create: XOR<AnalysisMessageCreateInput, AnalysisMessageUncheckedCreateInput>
    /**
     * In case the AnalysisMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalysisMessageUpdateInput, AnalysisMessageUncheckedUpdateInput>
  }

  /**
   * AnalysisMessage delete
   */
  export type AnalysisMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageInclude<ExtArgs> | null
    /**
     * Filter which AnalysisMessage to delete.
     */
    where: AnalysisMessageWhereUniqueInput
  }

  /**
   * AnalysisMessage deleteMany
   */
  export type AnalysisMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisMessages to delete
     */
    where?: AnalysisMessageWhereInput
    /**
     * Limit how many AnalysisMessages to delete.
     */
    limit?: number
  }

  /**
   * AnalysisMessage without action
   */
  export type AnalysisMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisMessage
     */
    select?: AnalysisMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisMessage
     */
    omit?: AnalysisMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisMessageInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resource: string | null
    resourceId: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resource" | "resourceId" | "details" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resource: string | null
      resourceId: string | null
      details: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    key: string | null
    permissions: string | null
    expiresAt: Date | null
    lastUsedAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    key: string | null
    permissions: string | null
    expiresAt: Date | null
    lastUsedAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    key: number
    permissions: number
    expiresAt: number
    lastUsedAt: number
    createdAt: number
    revokedAt: number
    _all: number
  }


  export type ApiKeyMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    key?: true
    permissions?: true
    expiresAt?: true
    lastUsedAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    key?: true
    permissions?: true
    expiresAt?: true
    lastUsedAt?: true
    createdAt?: true
    revokedAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    key?: true
    permissions?: true
    expiresAt?: true
    lastUsedAt?: true
    createdAt?: true
    revokedAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    userId: string
    name: string
    key: string
    permissions: string
    expiresAt: Date | null
    lastUsedAt: Date | null
    createdAt: Date
    revokedAt: Date | null
    _count: ApiKeyCountAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    key?: boolean
    permissions?: boolean
    expiresAt?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    key?: boolean
    permissions?: boolean
    expiresAt?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    key?: boolean
    permissions?: boolean
    expiresAt?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    key?: boolean
    permissions?: boolean
    expiresAt?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
  }

  export type ApiKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "key" | "permissions" | "expiresAt" | "lastUsedAt" | "createdAt" | "revokedAt", ExtArgs["result"]["apiKey"]>
  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      key: string
      permissions: string
      expiresAt: Date | null
      lastUsedAt: Date | null
      createdAt: Date
      revokedAt: Date | null
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys and returns the data updated in the database.
     * @param {ApiKeyUpdateManyAndReturnArgs} args - Arguments to update many ApiKeys.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly userId: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly key: FieldRef<"ApiKey", 'String'>
    readonly permissions: FieldRef<"ApiKey", 'String'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly revokedAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
  }

  /**
   * ApiKey updateManyAndReturn
   */
  export type ApiKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to delete.
     */
    limit?: number
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model BatchAnalysisJob
   */

  export type AggregateBatchAnalysisJob = {
    _count: BatchAnalysisJobCountAggregateOutputType | null
    _avg: BatchAnalysisJobAvgAggregateOutputType | null
    _sum: BatchAnalysisJobSumAggregateOutputType | null
    _min: BatchAnalysisJobMinAggregateOutputType | null
    _max: BatchAnalysisJobMaxAggregateOutputType | null
  }

  export type BatchAnalysisJobAvgAggregateOutputType = {
    sampleSize: number | null
    totalItems: number | null
    processedItems: number | null
    failedItems: number | null
  }

  export type BatchAnalysisJobSumAggregateOutputType = {
    sampleSize: number | null
    totalItems: number | null
    processedItems: number | null
    failedItems: number | null
  }

  export type BatchAnalysisJobMinAggregateOutputType = {
    id: string | null
    status: string | null
    targetDate: Date | null
    tenantId: string | null
    sampleSize: number | null
    promptTemplate: string | null
    totalItems: number | null
    processedItems: number | null
    failedItems: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    cancelRequested: boolean | null
    createdAt: Date | null
  }

  export type BatchAnalysisJobMaxAggregateOutputType = {
    id: string | null
    status: string | null
    targetDate: Date | null
    tenantId: string | null
    sampleSize: number | null
    promptTemplate: string | null
    totalItems: number | null
    processedItems: number | null
    failedItems: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    cancelRequested: boolean | null
    createdAt: Date | null
  }

  export type BatchAnalysisJobCountAggregateOutputType = {
    id: number
    status: number
    targetDate: number
    tenantId: number
    sampleSize: number
    promptTemplate: number
    totalItems: number
    processedItems: number
    failedItems: number
    startedAt: number
    completedAt: number
    errorMessage: number
    cancelRequested: number
    createdAt: number
    _all: number
  }


  export type BatchAnalysisJobAvgAggregateInputType = {
    sampleSize?: true
    totalItems?: true
    processedItems?: true
    failedItems?: true
  }

  export type BatchAnalysisJobSumAggregateInputType = {
    sampleSize?: true
    totalItems?: true
    processedItems?: true
    failedItems?: true
  }

  export type BatchAnalysisJobMinAggregateInputType = {
    id?: true
    status?: true
    targetDate?: true
    tenantId?: true
    sampleSize?: true
    promptTemplate?: true
    totalItems?: true
    processedItems?: true
    failedItems?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    cancelRequested?: true
    createdAt?: true
  }

  export type BatchAnalysisJobMaxAggregateInputType = {
    id?: true
    status?: true
    targetDate?: true
    tenantId?: true
    sampleSize?: true
    promptTemplate?: true
    totalItems?: true
    processedItems?: true
    failedItems?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    cancelRequested?: true
    createdAt?: true
  }

  export type BatchAnalysisJobCountAggregateInputType = {
    id?: true
    status?: true
    targetDate?: true
    tenantId?: true
    sampleSize?: true
    promptTemplate?: true
    totalItems?: true
    processedItems?: true
    failedItems?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    cancelRequested?: true
    createdAt?: true
    _all?: true
  }

  export type BatchAnalysisJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchAnalysisJob to aggregate.
     */
    where?: BatchAnalysisJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchAnalysisJobs to fetch.
     */
    orderBy?: BatchAnalysisJobOrderByWithRelationInput | BatchAnalysisJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchAnalysisJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchAnalysisJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchAnalysisJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchAnalysisJobs
    **/
    _count?: true | BatchAnalysisJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchAnalysisJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchAnalysisJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchAnalysisJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchAnalysisJobMaxAggregateInputType
  }

  export type GetBatchAnalysisJobAggregateType<T extends BatchAnalysisJobAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchAnalysisJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchAnalysisJob[P]>
      : GetScalarType<T[P], AggregateBatchAnalysisJob[P]>
  }




  export type BatchAnalysisJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchAnalysisJobWhereInput
    orderBy?: BatchAnalysisJobOrderByWithAggregationInput | BatchAnalysisJobOrderByWithAggregationInput[]
    by: BatchAnalysisJobScalarFieldEnum[] | BatchAnalysisJobScalarFieldEnum
    having?: BatchAnalysisJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchAnalysisJobCountAggregateInputType | true
    _avg?: BatchAnalysisJobAvgAggregateInputType
    _sum?: BatchAnalysisJobSumAggregateInputType
    _min?: BatchAnalysisJobMinAggregateInputType
    _max?: BatchAnalysisJobMaxAggregateInputType
  }

  export type BatchAnalysisJobGroupByOutputType = {
    id: string
    status: string
    targetDate: Date
    tenantId: string | null
    sampleSize: number
    promptTemplate: string
    totalItems: number
    processedItems: number
    failedItems: number
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    cancelRequested: boolean
    createdAt: Date
    _count: BatchAnalysisJobCountAggregateOutputType | null
    _avg: BatchAnalysisJobAvgAggregateOutputType | null
    _sum: BatchAnalysisJobSumAggregateOutputType | null
    _min: BatchAnalysisJobMinAggregateOutputType | null
    _max: BatchAnalysisJobMaxAggregateOutputType | null
  }

  type GetBatchAnalysisJobGroupByPayload<T extends BatchAnalysisJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchAnalysisJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchAnalysisJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchAnalysisJobGroupByOutputType[P]>
            : GetScalarType<T[P], BatchAnalysisJobGroupByOutputType[P]>
        }
      >
    >


  export type BatchAnalysisJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    targetDate?: boolean
    tenantId?: boolean
    sampleSize?: boolean
    promptTemplate?: boolean
    totalItems?: boolean
    processedItems?: boolean
    failedItems?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    cancelRequested?: boolean
    createdAt?: boolean
    results?: boolean | BatchAnalysisJob$resultsArgs<ExtArgs>
    _count?: boolean | BatchAnalysisJobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchAnalysisJob"]>

  export type BatchAnalysisJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    targetDate?: boolean
    tenantId?: boolean
    sampleSize?: boolean
    promptTemplate?: boolean
    totalItems?: boolean
    processedItems?: boolean
    failedItems?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    cancelRequested?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["batchAnalysisJob"]>

  export type BatchAnalysisJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    targetDate?: boolean
    tenantId?: boolean
    sampleSize?: boolean
    promptTemplate?: boolean
    totalItems?: boolean
    processedItems?: boolean
    failedItems?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    cancelRequested?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["batchAnalysisJob"]>

  export type BatchAnalysisJobSelectScalar = {
    id?: boolean
    status?: boolean
    targetDate?: boolean
    tenantId?: boolean
    sampleSize?: boolean
    promptTemplate?: boolean
    totalItems?: boolean
    processedItems?: boolean
    failedItems?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    cancelRequested?: boolean
    createdAt?: boolean
  }

  export type BatchAnalysisJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "targetDate" | "tenantId" | "sampleSize" | "promptTemplate" | "totalItems" | "processedItems" | "failedItems" | "startedAt" | "completedAt" | "errorMessage" | "cancelRequested" | "createdAt", ExtArgs["result"]["batchAnalysisJob"]>
  export type BatchAnalysisJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | BatchAnalysisJob$resultsArgs<ExtArgs>
    _count?: boolean | BatchAnalysisJobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BatchAnalysisJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BatchAnalysisJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BatchAnalysisJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchAnalysisJob"
    objects: {
      results: Prisma.$BatchAnalysisResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      targetDate: Date
      tenantId: string | null
      sampleSize: number
      promptTemplate: string
      totalItems: number
      processedItems: number
      failedItems: number
      startedAt: Date | null
      completedAt: Date | null
      errorMessage: string | null
      cancelRequested: boolean
      createdAt: Date
    }, ExtArgs["result"]["batchAnalysisJob"]>
    composites: {}
  }

  type BatchAnalysisJobGetPayload<S extends boolean | null | undefined | BatchAnalysisJobDefaultArgs> = $Result.GetResult<Prisma.$BatchAnalysisJobPayload, S>

  type BatchAnalysisJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchAnalysisJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchAnalysisJobCountAggregateInputType | true
    }

  export interface BatchAnalysisJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchAnalysisJob'], meta: { name: 'BatchAnalysisJob' } }
    /**
     * Find zero or one BatchAnalysisJob that matches the filter.
     * @param {BatchAnalysisJobFindUniqueArgs} args - Arguments to find a BatchAnalysisJob
     * @example
     * // Get one BatchAnalysisJob
     * const batchAnalysisJob = await prisma.batchAnalysisJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchAnalysisJobFindUniqueArgs>(args: SelectSubset<T, BatchAnalysisJobFindUniqueArgs<ExtArgs>>): Prisma__BatchAnalysisJobClient<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BatchAnalysisJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchAnalysisJobFindUniqueOrThrowArgs} args - Arguments to find a BatchAnalysisJob
     * @example
     * // Get one BatchAnalysisJob
     * const batchAnalysisJob = await prisma.batchAnalysisJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchAnalysisJobFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchAnalysisJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchAnalysisJobClient<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchAnalysisJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisJobFindFirstArgs} args - Arguments to find a BatchAnalysisJob
     * @example
     * // Get one BatchAnalysisJob
     * const batchAnalysisJob = await prisma.batchAnalysisJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchAnalysisJobFindFirstArgs>(args?: SelectSubset<T, BatchAnalysisJobFindFirstArgs<ExtArgs>>): Prisma__BatchAnalysisJobClient<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchAnalysisJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisJobFindFirstOrThrowArgs} args - Arguments to find a BatchAnalysisJob
     * @example
     * // Get one BatchAnalysisJob
     * const batchAnalysisJob = await prisma.batchAnalysisJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchAnalysisJobFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchAnalysisJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchAnalysisJobClient<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BatchAnalysisJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchAnalysisJobs
     * const batchAnalysisJobs = await prisma.batchAnalysisJob.findMany()
     * 
     * // Get first 10 BatchAnalysisJobs
     * const batchAnalysisJobs = await prisma.batchAnalysisJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchAnalysisJobWithIdOnly = await prisma.batchAnalysisJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchAnalysisJobFindManyArgs>(args?: SelectSubset<T, BatchAnalysisJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BatchAnalysisJob.
     * @param {BatchAnalysisJobCreateArgs} args - Arguments to create a BatchAnalysisJob.
     * @example
     * // Create one BatchAnalysisJob
     * const BatchAnalysisJob = await prisma.batchAnalysisJob.create({
     *   data: {
     *     // ... data to create a BatchAnalysisJob
     *   }
     * })
     * 
     */
    create<T extends BatchAnalysisJobCreateArgs>(args: SelectSubset<T, BatchAnalysisJobCreateArgs<ExtArgs>>): Prisma__BatchAnalysisJobClient<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BatchAnalysisJobs.
     * @param {BatchAnalysisJobCreateManyArgs} args - Arguments to create many BatchAnalysisJobs.
     * @example
     * // Create many BatchAnalysisJobs
     * const batchAnalysisJob = await prisma.batchAnalysisJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchAnalysisJobCreateManyArgs>(args?: SelectSubset<T, BatchAnalysisJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BatchAnalysisJobs and returns the data saved in the database.
     * @param {BatchAnalysisJobCreateManyAndReturnArgs} args - Arguments to create many BatchAnalysisJobs.
     * @example
     * // Create many BatchAnalysisJobs
     * const batchAnalysisJob = await prisma.batchAnalysisJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BatchAnalysisJobs and only return the `id`
     * const batchAnalysisJobWithIdOnly = await prisma.batchAnalysisJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchAnalysisJobCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchAnalysisJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BatchAnalysisJob.
     * @param {BatchAnalysisJobDeleteArgs} args - Arguments to delete one BatchAnalysisJob.
     * @example
     * // Delete one BatchAnalysisJob
     * const BatchAnalysisJob = await prisma.batchAnalysisJob.delete({
     *   where: {
     *     // ... filter to delete one BatchAnalysisJob
     *   }
     * })
     * 
     */
    delete<T extends BatchAnalysisJobDeleteArgs>(args: SelectSubset<T, BatchAnalysisJobDeleteArgs<ExtArgs>>): Prisma__BatchAnalysisJobClient<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BatchAnalysisJob.
     * @param {BatchAnalysisJobUpdateArgs} args - Arguments to update one BatchAnalysisJob.
     * @example
     * // Update one BatchAnalysisJob
     * const batchAnalysisJob = await prisma.batchAnalysisJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchAnalysisJobUpdateArgs>(args: SelectSubset<T, BatchAnalysisJobUpdateArgs<ExtArgs>>): Prisma__BatchAnalysisJobClient<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BatchAnalysisJobs.
     * @param {BatchAnalysisJobDeleteManyArgs} args - Arguments to filter BatchAnalysisJobs to delete.
     * @example
     * // Delete a few BatchAnalysisJobs
     * const { count } = await prisma.batchAnalysisJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchAnalysisJobDeleteManyArgs>(args?: SelectSubset<T, BatchAnalysisJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchAnalysisJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchAnalysisJobs
     * const batchAnalysisJob = await prisma.batchAnalysisJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchAnalysisJobUpdateManyArgs>(args: SelectSubset<T, BatchAnalysisJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchAnalysisJobs and returns the data updated in the database.
     * @param {BatchAnalysisJobUpdateManyAndReturnArgs} args - Arguments to update many BatchAnalysisJobs.
     * @example
     * // Update many BatchAnalysisJobs
     * const batchAnalysisJob = await prisma.batchAnalysisJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BatchAnalysisJobs and only return the `id`
     * const batchAnalysisJobWithIdOnly = await prisma.batchAnalysisJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchAnalysisJobUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchAnalysisJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BatchAnalysisJob.
     * @param {BatchAnalysisJobUpsertArgs} args - Arguments to update or create a BatchAnalysisJob.
     * @example
     * // Update or create a BatchAnalysisJob
     * const batchAnalysisJob = await prisma.batchAnalysisJob.upsert({
     *   create: {
     *     // ... data to create a BatchAnalysisJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchAnalysisJob we want to update
     *   }
     * })
     */
    upsert<T extends BatchAnalysisJobUpsertArgs>(args: SelectSubset<T, BatchAnalysisJobUpsertArgs<ExtArgs>>): Prisma__BatchAnalysisJobClient<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BatchAnalysisJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisJobCountArgs} args - Arguments to filter BatchAnalysisJobs to count.
     * @example
     * // Count the number of BatchAnalysisJobs
     * const count = await prisma.batchAnalysisJob.count({
     *   where: {
     *     // ... the filter for the BatchAnalysisJobs we want to count
     *   }
     * })
    **/
    count<T extends BatchAnalysisJobCountArgs>(
      args?: Subset<T, BatchAnalysisJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchAnalysisJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchAnalysisJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAnalysisJobAggregateArgs>(args: Subset<T, BatchAnalysisJobAggregateArgs>): Prisma.PrismaPromise<GetBatchAnalysisJobAggregateType<T>>

    /**
     * Group by BatchAnalysisJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchAnalysisJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchAnalysisJobGroupByArgs['orderBy'] }
        : { orderBy?: BatchAnalysisJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchAnalysisJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchAnalysisJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchAnalysisJob model
   */
  readonly fields: BatchAnalysisJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchAnalysisJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchAnalysisJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    results<T extends BatchAnalysisJob$resultsArgs<ExtArgs> = {}>(args?: Subset<T, BatchAnalysisJob$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchAnalysisJob model
   */
  interface BatchAnalysisJobFieldRefs {
    readonly id: FieldRef<"BatchAnalysisJob", 'String'>
    readonly status: FieldRef<"BatchAnalysisJob", 'String'>
    readonly targetDate: FieldRef<"BatchAnalysisJob", 'DateTime'>
    readonly tenantId: FieldRef<"BatchAnalysisJob", 'String'>
    readonly sampleSize: FieldRef<"BatchAnalysisJob", 'Int'>
    readonly promptTemplate: FieldRef<"BatchAnalysisJob", 'String'>
    readonly totalItems: FieldRef<"BatchAnalysisJob", 'Int'>
    readonly processedItems: FieldRef<"BatchAnalysisJob", 'Int'>
    readonly failedItems: FieldRef<"BatchAnalysisJob", 'Int'>
    readonly startedAt: FieldRef<"BatchAnalysisJob", 'DateTime'>
    readonly completedAt: FieldRef<"BatchAnalysisJob", 'DateTime'>
    readonly errorMessage: FieldRef<"BatchAnalysisJob", 'String'>
    readonly cancelRequested: FieldRef<"BatchAnalysisJob", 'Boolean'>
    readonly createdAt: FieldRef<"BatchAnalysisJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BatchAnalysisJob findUnique
   */
  export type BatchAnalysisJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter, which BatchAnalysisJob to fetch.
     */
    where: BatchAnalysisJobWhereUniqueInput
  }

  /**
   * BatchAnalysisJob findUniqueOrThrow
   */
  export type BatchAnalysisJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter, which BatchAnalysisJob to fetch.
     */
    where: BatchAnalysisJobWhereUniqueInput
  }

  /**
   * BatchAnalysisJob findFirst
   */
  export type BatchAnalysisJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter, which BatchAnalysisJob to fetch.
     */
    where?: BatchAnalysisJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchAnalysisJobs to fetch.
     */
    orderBy?: BatchAnalysisJobOrderByWithRelationInput | BatchAnalysisJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchAnalysisJobs.
     */
    cursor?: BatchAnalysisJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchAnalysisJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchAnalysisJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchAnalysisJobs.
     */
    distinct?: BatchAnalysisJobScalarFieldEnum | BatchAnalysisJobScalarFieldEnum[]
  }

  /**
   * BatchAnalysisJob findFirstOrThrow
   */
  export type BatchAnalysisJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter, which BatchAnalysisJob to fetch.
     */
    where?: BatchAnalysisJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchAnalysisJobs to fetch.
     */
    orderBy?: BatchAnalysisJobOrderByWithRelationInput | BatchAnalysisJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchAnalysisJobs.
     */
    cursor?: BatchAnalysisJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchAnalysisJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchAnalysisJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchAnalysisJobs.
     */
    distinct?: BatchAnalysisJobScalarFieldEnum | BatchAnalysisJobScalarFieldEnum[]
  }

  /**
   * BatchAnalysisJob findMany
   */
  export type BatchAnalysisJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter, which BatchAnalysisJobs to fetch.
     */
    where?: BatchAnalysisJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchAnalysisJobs to fetch.
     */
    orderBy?: BatchAnalysisJobOrderByWithRelationInput | BatchAnalysisJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchAnalysisJobs.
     */
    cursor?: BatchAnalysisJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchAnalysisJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchAnalysisJobs.
     */
    skip?: number
    distinct?: BatchAnalysisJobScalarFieldEnum | BatchAnalysisJobScalarFieldEnum[]
  }

  /**
   * BatchAnalysisJob create
   */
  export type BatchAnalysisJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisJobInclude<ExtArgs> | null
    /**
     * The data needed to create a BatchAnalysisJob.
     */
    data: XOR<BatchAnalysisJobCreateInput, BatchAnalysisJobUncheckedCreateInput>
  }

  /**
   * BatchAnalysisJob createMany
   */
  export type BatchAnalysisJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchAnalysisJobs.
     */
    data: BatchAnalysisJobCreateManyInput | BatchAnalysisJobCreateManyInput[]
  }

  /**
   * BatchAnalysisJob createManyAndReturn
   */
  export type BatchAnalysisJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * The data used to create many BatchAnalysisJobs.
     */
    data: BatchAnalysisJobCreateManyInput | BatchAnalysisJobCreateManyInput[]
  }

  /**
   * BatchAnalysisJob update
   */
  export type BatchAnalysisJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisJobInclude<ExtArgs> | null
    /**
     * The data needed to update a BatchAnalysisJob.
     */
    data: XOR<BatchAnalysisJobUpdateInput, BatchAnalysisJobUncheckedUpdateInput>
    /**
     * Choose, which BatchAnalysisJob to update.
     */
    where: BatchAnalysisJobWhereUniqueInput
  }

  /**
   * BatchAnalysisJob updateMany
   */
  export type BatchAnalysisJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchAnalysisJobs.
     */
    data: XOR<BatchAnalysisJobUpdateManyMutationInput, BatchAnalysisJobUncheckedUpdateManyInput>
    /**
     * Filter which BatchAnalysisJobs to update
     */
    where?: BatchAnalysisJobWhereInput
    /**
     * Limit how many BatchAnalysisJobs to update.
     */
    limit?: number
  }

  /**
   * BatchAnalysisJob updateManyAndReturn
   */
  export type BatchAnalysisJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * The data used to update BatchAnalysisJobs.
     */
    data: XOR<BatchAnalysisJobUpdateManyMutationInput, BatchAnalysisJobUncheckedUpdateManyInput>
    /**
     * Filter which BatchAnalysisJobs to update
     */
    where?: BatchAnalysisJobWhereInput
    /**
     * Limit how many BatchAnalysisJobs to update.
     */
    limit?: number
  }

  /**
   * BatchAnalysisJob upsert
   */
  export type BatchAnalysisJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisJobInclude<ExtArgs> | null
    /**
     * The filter to search for the BatchAnalysisJob to update in case it exists.
     */
    where: BatchAnalysisJobWhereUniqueInput
    /**
     * In case the BatchAnalysisJob found by the `where` argument doesn't exist, create a new BatchAnalysisJob with this data.
     */
    create: XOR<BatchAnalysisJobCreateInput, BatchAnalysisJobUncheckedCreateInput>
    /**
     * In case the BatchAnalysisJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchAnalysisJobUpdateInput, BatchAnalysisJobUncheckedUpdateInput>
  }

  /**
   * BatchAnalysisJob delete
   */
  export type BatchAnalysisJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter which BatchAnalysisJob to delete.
     */
    where: BatchAnalysisJobWhereUniqueInput
  }

  /**
   * BatchAnalysisJob deleteMany
   */
  export type BatchAnalysisJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchAnalysisJobs to delete
     */
    where?: BatchAnalysisJobWhereInput
    /**
     * Limit how many BatchAnalysisJobs to delete.
     */
    limit?: number
  }

  /**
   * BatchAnalysisJob.results
   */
  export type BatchAnalysisJob$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultInclude<ExtArgs> | null
    where?: BatchAnalysisResultWhereInput
    orderBy?: BatchAnalysisResultOrderByWithRelationInput | BatchAnalysisResultOrderByWithRelationInput[]
    cursor?: BatchAnalysisResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchAnalysisResultScalarFieldEnum | BatchAnalysisResultScalarFieldEnum[]
  }

  /**
   * BatchAnalysisJob without action
   */
  export type BatchAnalysisJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisJob
     */
    select?: BatchAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisJob
     */
    omit?: BatchAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisJobInclude<ExtArgs> | null
  }


  /**
   * Model BatchAnalysisResult
   */

  export type AggregateBatchAnalysisResult = {
    _count: BatchAnalysisResultCountAggregateOutputType | null
    _avg: BatchAnalysisResultAvgAggregateOutputType | null
    _sum: BatchAnalysisResultSumAggregateOutputType | null
    _min: BatchAnalysisResultMinAggregateOutputType | null
    _max: BatchAnalysisResultMaxAggregateOutputType | null
  }

  export type BatchAnalysisResultAvgAggregateOutputType = {
    latencyMs: number | null
    inputTokens: number | null
    outputTokens: number | null
    qualityScore: number | null
    relevance: number | null
    completeness: number | null
    clarity: number | null
    issueCount: number | null
    avgScore: number | null
  }

  export type BatchAnalysisResultSumAggregateOutputType = {
    latencyMs: number | null
    inputTokens: number | null
    outputTokens: number | null
    qualityScore: number | null
    relevance: number | null
    completeness: number | null
    clarity: number | null
    issueCount: number | null
    avgScore: number | null
  }

  export type BatchAnalysisResultMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    originalTimestamp: Date | null
    tenantId: string | null
    sessionId: string | null
    userInput: string | null
    llmResponse: string | null
    analysisPrompt: string | null
    analysisResult: string | null
    modelName: string | null
    latencyMs: number | null
    inputTokens: number | null
    outputTokens: number | null
    qualityScore: number | null
    relevance: number | null
    completeness: number | null
    clarity: number | null
    sentiment: string | null
    summaryText: string | null
    issues: string | null
    improvements: string | null
    missingData: string | null
    issueCount: number | null
    avgScore: number | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type BatchAnalysisResultMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    originalTimestamp: Date | null
    tenantId: string | null
    sessionId: string | null
    userInput: string | null
    llmResponse: string | null
    analysisPrompt: string | null
    analysisResult: string | null
    modelName: string | null
    latencyMs: number | null
    inputTokens: number | null
    outputTokens: number | null
    qualityScore: number | null
    relevance: number | null
    completeness: number | null
    clarity: number | null
    sentiment: string | null
    summaryText: string | null
    issues: string | null
    improvements: string | null
    missingData: string | null
    issueCount: number | null
    avgScore: number | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type BatchAnalysisResultCountAggregateOutputType = {
    id: number
    jobId: number
    originalTimestamp: number
    tenantId: number
    sessionId: number
    userInput: number
    llmResponse: number
    analysisPrompt: number
    analysisResult: number
    modelName: number
    latencyMs: number
    inputTokens: number
    outputTokens: number
    qualityScore: number
    relevance: number
    completeness: number
    clarity: number
    sentiment: number
    summaryText: number
    issues: number
    improvements: number
    missingData: number
    issueCount: number
    avgScore: number
    status: number
    errorMessage: number
    createdAt: number
    _all: number
  }


  export type BatchAnalysisResultAvgAggregateInputType = {
    latencyMs?: true
    inputTokens?: true
    outputTokens?: true
    qualityScore?: true
    relevance?: true
    completeness?: true
    clarity?: true
    issueCount?: true
    avgScore?: true
  }

  export type BatchAnalysisResultSumAggregateInputType = {
    latencyMs?: true
    inputTokens?: true
    outputTokens?: true
    qualityScore?: true
    relevance?: true
    completeness?: true
    clarity?: true
    issueCount?: true
    avgScore?: true
  }

  export type BatchAnalysisResultMinAggregateInputType = {
    id?: true
    jobId?: true
    originalTimestamp?: true
    tenantId?: true
    sessionId?: true
    userInput?: true
    llmResponse?: true
    analysisPrompt?: true
    analysisResult?: true
    modelName?: true
    latencyMs?: true
    inputTokens?: true
    outputTokens?: true
    qualityScore?: true
    relevance?: true
    completeness?: true
    clarity?: true
    sentiment?: true
    summaryText?: true
    issues?: true
    improvements?: true
    missingData?: true
    issueCount?: true
    avgScore?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type BatchAnalysisResultMaxAggregateInputType = {
    id?: true
    jobId?: true
    originalTimestamp?: true
    tenantId?: true
    sessionId?: true
    userInput?: true
    llmResponse?: true
    analysisPrompt?: true
    analysisResult?: true
    modelName?: true
    latencyMs?: true
    inputTokens?: true
    outputTokens?: true
    qualityScore?: true
    relevance?: true
    completeness?: true
    clarity?: true
    sentiment?: true
    summaryText?: true
    issues?: true
    improvements?: true
    missingData?: true
    issueCount?: true
    avgScore?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type BatchAnalysisResultCountAggregateInputType = {
    id?: true
    jobId?: true
    originalTimestamp?: true
    tenantId?: true
    sessionId?: true
    userInput?: true
    llmResponse?: true
    analysisPrompt?: true
    analysisResult?: true
    modelName?: true
    latencyMs?: true
    inputTokens?: true
    outputTokens?: true
    qualityScore?: true
    relevance?: true
    completeness?: true
    clarity?: true
    sentiment?: true
    summaryText?: true
    issues?: true
    improvements?: true
    missingData?: true
    issueCount?: true
    avgScore?: true
    status?: true
    errorMessage?: true
    createdAt?: true
    _all?: true
  }

  export type BatchAnalysisResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchAnalysisResult to aggregate.
     */
    where?: BatchAnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchAnalysisResults to fetch.
     */
    orderBy?: BatchAnalysisResultOrderByWithRelationInput | BatchAnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchAnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchAnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchAnalysisResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchAnalysisResults
    **/
    _count?: true | BatchAnalysisResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchAnalysisResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchAnalysisResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchAnalysisResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchAnalysisResultMaxAggregateInputType
  }

  export type GetBatchAnalysisResultAggregateType<T extends BatchAnalysisResultAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchAnalysisResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchAnalysisResult[P]>
      : GetScalarType<T[P], AggregateBatchAnalysisResult[P]>
  }




  export type BatchAnalysisResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchAnalysisResultWhereInput
    orderBy?: BatchAnalysisResultOrderByWithAggregationInput | BatchAnalysisResultOrderByWithAggregationInput[]
    by: BatchAnalysisResultScalarFieldEnum[] | BatchAnalysisResultScalarFieldEnum
    having?: BatchAnalysisResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchAnalysisResultCountAggregateInputType | true
    _avg?: BatchAnalysisResultAvgAggregateInputType
    _sum?: BatchAnalysisResultSumAggregateInputType
    _min?: BatchAnalysisResultMinAggregateInputType
    _max?: BatchAnalysisResultMaxAggregateInputType
  }

  export type BatchAnalysisResultGroupByOutputType = {
    id: string
    jobId: string
    originalTimestamp: Date
    tenantId: string
    sessionId: string | null
    userInput: string
    llmResponse: string
    analysisPrompt: string
    analysisResult: string
    modelName: string
    latencyMs: number
    inputTokens: number
    outputTokens: number
    qualityScore: number | null
    relevance: number | null
    completeness: number | null
    clarity: number | null
    sentiment: string | null
    summaryText: string | null
    issues: string | null
    improvements: string | null
    missingData: string | null
    issueCount: number | null
    avgScore: number | null
    status: string
    errorMessage: string | null
    createdAt: Date
    _count: BatchAnalysisResultCountAggregateOutputType | null
    _avg: BatchAnalysisResultAvgAggregateOutputType | null
    _sum: BatchAnalysisResultSumAggregateOutputType | null
    _min: BatchAnalysisResultMinAggregateOutputType | null
    _max: BatchAnalysisResultMaxAggregateOutputType | null
  }

  type GetBatchAnalysisResultGroupByPayload<T extends BatchAnalysisResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchAnalysisResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchAnalysisResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchAnalysisResultGroupByOutputType[P]>
            : GetScalarType<T[P], BatchAnalysisResultGroupByOutputType[P]>
        }
      >
    >


  export type BatchAnalysisResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    originalTimestamp?: boolean
    tenantId?: boolean
    sessionId?: boolean
    userInput?: boolean
    llmResponse?: boolean
    analysisPrompt?: boolean
    analysisResult?: boolean
    modelName?: boolean
    latencyMs?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    qualityScore?: boolean
    relevance?: boolean
    completeness?: boolean
    clarity?: boolean
    sentiment?: boolean
    summaryText?: boolean
    issues?: boolean
    improvements?: boolean
    missingData?: boolean
    issueCount?: boolean
    avgScore?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    job?: boolean | BatchAnalysisJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchAnalysisResult"]>

  export type BatchAnalysisResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    originalTimestamp?: boolean
    tenantId?: boolean
    sessionId?: boolean
    userInput?: boolean
    llmResponse?: boolean
    analysisPrompt?: boolean
    analysisResult?: boolean
    modelName?: boolean
    latencyMs?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    qualityScore?: boolean
    relevance?: boolean
    completeness?: boolean
    clarity?: boolean
    sentiment?: boolean
    summaryText?: boolean
    issues?: boolean
    improvements?: boolean
    missingData?: boolean
    issueCount?: boolean
    avgScore?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    job?: boolean | BatchAnalysisJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchAnalysisResult"]>

  export type BatchAnalysisResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    originalTimestamp?: boolean
    tenantId?: boolean
    sessionId?: boolean
    userInput?: boolean
    llmResponse?: boolean
    analysisPrompt?: boolean
    analysisResult?: boolean
    modelName?: boolean
    latencyMs?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    qualityScore?: boolean
    relevance?: boolean
    completeness?: boolean
    clarity?: boolean
    sentiment?: boolean
    summaryText?: boolean
    issues?: boolean
    improvements?: boolean
    missingData?: boolean
    issueCount?: boolean
    avgScore?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    job?: boolean | BatchAnalysisJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchAnalysisResult"]>

  export type BatchAnalysisResultSelectScalar = {
    id?: boolean
    jobId?: boolean
    originalTimestamp?: boolean
    tenantId?: boolean
    sessionId?: boolean
    userInput?: boolean
    llmResponse?: boolean
    analysisPrompt?: boolean
    analysisResult?: boolean
    modelName?: boolean
    latencyMs?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    qualityScore?: boolean
    relevance?: boolean
    completeness?: boolean
    clarity?: boolean
    sentiment?: boolean
    summaryText?: boolean
    issues?: boolean
    improvements?: boolean
    missingData?: boolean
    issueCount?: boolean
    avgScore?: boolean
    status?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }

  export type BatchAnalysisResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobId" | "originalTimestamp" | "tenantId" | "sessionId" | "userInput" | "llmResponse" | "analysisPrompt" | "analysisResult" | "modelName" | "latencyMs" | "inputTokens" | "outputTokens" | "qualityScore" | "relevance" | "completeness" | "clarity" | "sentiment" | "summaryText" | "issues" | "improvements" | "missingData" | "issueCount" | "avgScore" | "status" | "errorMessage" | "createdAt", ExtArgs["result"]["batchAnalysisResult"]>
  export type BatchAnalysisResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | BatchAnalysisJobDefaultArgs<ExtArgs>
  }
  export type BatchAnalysisResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | BatchAnalysisJobDefaultArgs<ExtArgs>
  }
  export type BatchAnalysisResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | BatchAnalysisJobDefaultArgs<ExtArgs>
  }

  export type $BatchAnalysisResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchAnalysisResult"
    objects: {
      job: Prisma.$BatchAnalysisJobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      originalTimestamp: Date
      tenantId: string
      sessionId: string | null
      userInput: string
      llmResponse: string
      analysisPrompt: string
      analysisResult: string
      modelName: string
      latencyMs: number
      inputTokens: number
      outputTokens: number
      qualityScore: number | null
      relevance: number | null
      completeness: number | null
      clarity: number | null
      sentiment: string | null
      summaryText: string | null
      issues: string | null
      improvements: string | null
      missingData: string | null
      issueCount: number | null
      avgScore: number | null
      status: string
      errorMessage: string | null
      createdAt: Date
    }, ExtArgs["result"]["batchAnalysisResult"]>
    composites: {}
  }

  type BatchAnalysisResultGetPayload<S extends boolean | null | undefined | BatchAnalysisResultDefaultArgs> = $Result.GetResult<Prisma.$BatchAnalysisResultPayload, S>

  type BatchAnalysisResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchAnalysisResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchAnalysisResultCountAggregateInputType | true
    }

  export interface BatchAnalysisResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchAnalysisResult'], meta: { name: 'BatchAnalysisResult' } }
    /**
     * Find zero or one BatchAnalysisResult that matches the filter.
     * @param {BatchAnalysisResultFindUniqueArgs} args - Arguments to find a BatchAnalysisResult
     * @example
     * // Get one BatchAnalysisResult
     * const batchAnalysisResult = await prisma.batchAnalysisResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchAnalysisResultFindUniqueArgs>(args: SelectSubset<T, BatchAnalysisResultFindUniqueArgs<ExtArgs>>): Prisma__BatchAnalysisResultClient<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BatchAnalysisResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchAnalysisResultFindUniqueOrThrowArgs} args - Arguments to find a BatchAnalysisResult
     * @example
     * // Get one BatchAnalysisResult
     * const batchAnalysisResult = await prisma.batchAnalysisResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchAnalysisResultFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchAnalysisResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchAnalysisResultClient<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchAnalysisResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisResultFindFirstArgs} args - Arguments to find a BatchAnalysisResult
     * @example
     * // Get one BatchAnalysisResult
     * const batchAnalysisResult = await prisma.batchAnalysisResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchAnalysisResultFindFirstArgs>(args?: SelectSubset<T, BatchAnalysisResultFindFirstArgs<ExtArgs>>): Prisma__BatchAnalysisResultClient<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchAnalysisResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisResultFindFirstOrThrowArgs} args - Arguments to find a BatchAnalysisResult
     * @example
     * // Get one BatchAnalysisResult
     * const batchAnalysisResult = await prisma.batchAnalysisResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchAnalysisResultFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchAnalysisResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchAnalysisResultClient<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BatchAnalysisResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchAnalysisResults
     * const batchAnalysisResults = await prisma.batchAnalysisResult.findMany()
     * 
     * // Get first 10 BatchAnalysisResults
     * const batchAnalysisResults = await prisma.batchAnalysisResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchAnalysisResultWithIdOnly = await prisma.batchAnalysisResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchAnalysisResultFindManyArgs>(args?: SelectSubset<T, BatchAnalysisResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BatchAnalysisResult.
     * @param {BatchAnalysisResultCreateArgs} args - Arguments to create a BatchAnalysisResult.
     * @example
     * // Create one BatchAnalysisResult
     * const BatchAnalysisResult = await prisma.batchAnalysisResult.create({
     *   data: {
     *     // ... data to create a BatchAnalysisResult
     *   }
     * })
     * 
     */
    create<T extends BatchAnalysisResultCreateArgs>(args: SelectSubset<T, BatchAnalysisResultCreateArgs<ExtArgs>>): Prisma__BatchAnalysisResultClient<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BatchAnalysisResults.
     * @param {BatchAnalysisResultCreateManyArgs} args - Arguments to create many BatchAnalysisResults.
     * @example
     * // Create many BatchAnalysisResults
     * const batchAnalysisResult = await prisma.batchAnalysisResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchAnalysisResultCreateManyArgs>(args?: SelectSubset<T, BatchAnalysisResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BatchAnalysisResults and returns the data saved in the database.
     * @param {BatchAnalysisResultCreateManyAndReturnArgs} args - Arguments to create many BatchAnalysisResults.
     * @example
     * // Create many BatchAnalysisResults
     * const batchAnalysisResult = await prisma.batchAnalysisResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BatchAnalysisResults and only return the `id`
     * const batchAnalysisResultWithIdOnly = await prisma.batchAnalysisResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchAnalysisResultCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchAnalysisResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BatchAnalysisResult.
     * @param {BatchAnalysisResultDeleteArgs} args - Arguments to delete one BatchAnalysisResult.
     * @example
     * // Delete one BatchAnalysisResult
     * const BatchAnalysisResult = await prisma.batchAnalysisResult.delete({
     *   where: {
     *     // ... filter to delete one BatchAnalysisResult
     *   }
     * })
     * 
     */
    delete<T extends BatchAnalysisResultDeleteArgs>(args: SelectSubset<T, BatchAnalysisResultDeleteArgs<ExtArgs>>): Prisma__BatchAnalysisResultClient<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BatchAnalysisResult.
     * @param {BatchAnalysisResultUpdateArgs} args - Arguments to update one BatchAnalysisResult.
     * @example
     * // Update one BatchAnalysisResult
     * const batchAnalysisResult = await prisma.batchAnalysisResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchAnalysisResultUpdateArgs>(args: SelectSubset<T, BatchAnalysisResultUpdateArgs<ExtArgs>>): Prisma__BatchAnalysisResultClient<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BatchAnalysisResults.
     * @param {BatchAnalysisResultDeleteManyArgs} args - Arguments to filter BatchAnalysisResults to delete.
     * @example
     * // Delete a few BatchAnalysisResults
     * const { count } = await prisma.batchAnalysisResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchAnalysisResultDeleteManyArgs>(args?: SelectSubset<T, BatchAnalysisResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchAnalysisResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchAnalysisResults
     * const batchAnalysisResult = await prisma.batchAnalysisResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchAnalysisResultUpdateManyArgs>(args: SelectSubset<T, BatchAnalysisResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchAnalysisResults and returns the data updated in the database.
     * @param {BatchAnalysisResultUpdateManyAndReturnArgs} args - Arguments to update many BatchAnalysisResults.
     * @example
     * // Update many BatchAnalysisResults
     * const batchAnalysisResult = await prisma.batchAnalysisResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BatchAnalysisResults and only return the `id`
     * const batchAnalysisResultWithIdOnly = await prisma.batchAnalysisResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchAnalysisResultUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchAnalysisResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BatchAnalysisResult.
     * @param {BatchAnalysisResultUpsertArgs} args - Arguments to update or create a BatchAnalysisResult.
     * @example
     * // Update or create a BatchAnalysisResult
     * const batchAnalysisResult = await prisma.batchAnalysisResult.upsert({
     *   create: {
     *     // ... data to create a BatchAnalysisResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchAnalysisResult we want to update
     *   }
     * })
     */
    upsert<T extends BatchAnalysisResultUpsertArgs>(args: SelectSubset<T, BatchAnalysisResultUpsertArgs<ExtArgs>>): Prisma__BatchAnalysisResultClient<$Result.GetResult<Prisma.$BatchAnalysisResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BatchAnalysisResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisResultCountArgs} args - Arguments to filter BatchAnalysisResults to count.
     * @example
     * // Count the number of BatchAnalysisResults
     * const count = await prisma.batchAnalysisResult.count({
     *   where: {
     *     // ... the filter for the BatchAnalysisResults we want to count
     *   }
     * })
    **/
    count<T extends BatchAnalysisResultCountArgs>(
      args?: Subset<T, BatchAnalysisResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchAnalysisResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchAnalysisResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAnalysisResultAggregateArgs>(args: Subset<T, BatchAnalysisResultAggregateArgs>): Prisma.PrismaPromise<GetBatchAnalysisResultAggregateType<T>>

    /**
     * Group by BatchAnalysisResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAnalysisResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchAnalysisResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchAnalysisResultGroupByArgs['orderBy'] }
        : { orderBy?: BatchAnalysisResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchAnalysisResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchAnalysisResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchAnalysisResult model
   */
  readonly fields: BatchAnalysisResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchAnalysisResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchAnalysisResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends BatchAnalysisJobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchAnalysisJobDefaultArgs<ExtArgs>>): Prisma__BatchAnalysisJobClient<$Result.GetResult<Prisma.$BatchAnalysisJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchAnalysisResult model
   */
  interface BatchAnalysisResultFieldRefs {
    readonly id: FieldRef<"BatchAnalysisResult", 'String'>
    readonly jobId: FieldRef<"BatchAnalysisResult", 'String'>
    readonly originalTimestamp: FieldRef<"BatchAnalysisResult", 'DateTime'>
    readonly tenantId: FieldRef<"BatchAnalysisResult", 'String'>
    readonly sessionId: FieldRef<"BatchAnalysisResult", 'String'>
    readonly userInput: FieldRef<"BatchAnalysisResult", 'String'>
    readonly llmResponse: FieldRef<"BatchAnalysisResult", 'String'>
    readonly analysisPrompt: FieldRef<"BatchAnalysisResult", 'String'>
    readonly analysisResult: FieldRef<"BatchAnalysisResult", 'String'>
    readonly modelName: FieldRef<"BatchAnalysisResult", 'String'>
    readonly latencyMs: FieldRef<"BatchAnalysisResult", 'Int'>
    readonly inputTokens: FieldRef<"BatchAnalysisResult", 'Int'>
    readonly outputTokens: FieldRef<"BatchAnalysisResult", 'Int'>
    readonly qualityScore: FieldRef<"BatchAnalysisResult", 'Int'>
    readonly relevance: FieldRef<"BatchAnalysisResult", 'Int'>
    readonly completeness: FieldRef<"BatchAnalysisResult", 'Int'>
    readonly clarity: FieldRef<"BatchAnalysisResult", 'Int'>
    readonly sentiment: FieldRef<"BatchAnalysisResult", 'String'>
    readonly summaryText: FieldRef<"BatchAnalysisResult", 'String'>
    readonly issues: FieldRef<"BatchAnalysisResult", 'String'>
    readonly improvements: FieldRef<"BatchAnalysisResult", 'String'>
    readonly missingData: FieldRef<"BatchAnalysisResult", 'String'>
    readonly issueCount: FieldRef<"BatchAnalysisResult", 'Int'>
    readonly avgScore: FieldRef<"BatchAnalysisResult", 'Float'>
    readonly status: FieldRef<"BatchAnalysisResult", 'String'>
    readonly errorMessage: FieldRef<"BatchAnalysisResult", 'String'>
    readonly createdAt: FieldRef<"BatchAnalysisResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BatchAnalysisResult findUnique
   */
  export type BatchAnalysisResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which BatchAnalysisResult to fetch.
     */
    where: BatchAnalysisResultWhereUniqueInput
  }

  /**
   * BatchAnalysisResult findUniqueOrThrow
   */
  export type BatchAnalysisResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which BatchAnalysisResult to fetch.
     */
    where: BatchAnalysisResultWhereUniqueInput
  }

  /**
   * BatchAnalysisResult findFirst
   */
  export type BatchAnalysisResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which BatchAnalysisResult to fetch.
     */
    where?: BatchAnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchAnalysisResults to fetch.
     */
    orderBy?: BatchAnalysisResultOrderByWithRelationInput | BatchAnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchAnalysisResults.
     */
    cursor?: BatchAnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchAnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchAnalysisResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchAnalysisResults.
     */
    distinct?: BatchAnalysisResultScalarFieldEnum | BatchAnalysisResultScalarFieldEnum[]
  }

  /**
   * BatchAnalysisResult findFirstOrThrow
   */
  export type BatchAnalysisResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which BatchAnalysisResult to fetch.
     */
    where?: BatchAnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchAnalysisResults to fetch.
     */
    orderBy?: BatchAnalysisResultOrderByWithRelationInput | BatchAnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchAnalysisResults.
     */
    cursor?: BatchAnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchAnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchAnalysisResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchAnalysisResults.
     */
    distinct?: BatchAnalysisResultScalarFieldEnum | BatchAnalysisResultScalarFieldEnum[]
  }

  /**
   * BatchAnalysisResult findMany
   */
  export type BatchAnalysisResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which BatchAnalysisResults to fetch.
     */
    where?: BatchAnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchAnalysisResults to fetch.
     */
    orderBy?: BatchAnalysisResultOrderByWithRelationInput | BatchAnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchAnalysisResults.
     */
    cursor?: BatchAnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchAnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchAnalysisResults.
     */
    skip?: number
    distinct?: BatchAnalysisResultScalarFieldEnum | BatchAnalysisResultScalarFieldEnum[]
  }

  /**
   * BatchAnalysisResult create
   */
  export type BatchAnalysisResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultInclude<ExtArgs> | null
    /**
     * The data needed to create a BatchAnalysisResult.
     */
    data: XOR<BatchAnalysisResultCreateInput, BatchAnalysisResultUncheckedCreateInput>
  }

  /**
   * BatchAnalysisResult createMany
   */
  export type BatchAnalysisResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchAnalysisResults.
     */
    data: BatchAnalysisResultCreateManyInput | BatchAnalysisResultCreateManyInput[]
  }

  /**
   * BatchAnalysisResult createManyAndReturn
   */
  export type BatchAnalysisResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * The data used to create many BatchAnalysisResults.
     */
    data: BatchAnalysisResultCreateManyInput | BatchAnalysisResultCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchAnalysisResult update
   */
  export type BatchAnalysisResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultInclude<ExtArgs> | null
    /**
     * The data needed to update a BatchAnalysisResult.
     */
    data: XOR<BatchAnalysisResultUpdateInput, BatchAnalysisResultUncheckedUpdateInput>
    /**
     * Choose, which BatchAnalysisResult to update.
     */
    where: BatchAnalysisResultWhereUniqueInput
  }

  /**
   * BatchAnalysisResult updateMany
   */
  export type BatchAnalysisResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchAnalysisResults.
     */
    data: XOR<BatchAnalysisResultUpdateManyMutationInput, BatchAnalysisResultUncheckedUpdateManyInput>
    /**
     * Filter which BatchAnalysisResults to update
     */
    where?: BatchAnalysisResultWhereInput
    /**
     * Limit how many BatchAnalysisResults to update.
     */
    limit?: number
  }

  /**
   * BatchAnalysisResult updateManyAndReturn
   */
  export type BatchAnalysisResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * The data used to update BatchAnalysisResults.
     */
    data: XOR<BatchAnalysisResultUpdateManyMutationInput, BatchAnalysisResultUncheckedUpdateManyInput>
    /**
     * Filter which BatchAnalysisResults to update
     */
    where?: BatchAnalysisResultWhereInput
    /**
     * Limit how many BatchAnalysisResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchAnalysisResult upsert
   */
  export type BatchAnalysisResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultInclude<ExtArgs> | null
    /**
     * The filter to search for the BatchAnalysisResult to update in case it exists.
     */
    where: BatchAnalysisResultWhereUniqueInput
    /**
     * In case the BatchAnalysisResult found by the `where` argument doesn't exist, create a new BatchAnalysisResult with this data.
     */
    create: XOR<BatchAnalysisResultCreateInput, BatchAnalysisResultUncheckedCreateInput>
    /**
     * In case the BatchAnalysisResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchAnalysisResultUpdateInput, BatchAnalysisResultUncheckedUpdateInput>
  }

  /**
   * BatchAnalysisResult delete
   */
  export type BatchAnalysisResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter which BatchAnalysisResult to delete.
     */
    where: BatchAnalysisResultWhereUniqueInput
  }

  /**
   * BatchAnalysisResult deleteMany
   */
  export type BatchAnalysisResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchAnalysisResults to delete
     */
    where?: BatchAnalysisResultWhereInput
    /**
     * Limit how many BatchAnalysisResults to delete.
     */
    limit?: number
  }

  /**
   * BatchAnalysisResult without action
   */
  export type BatchAnalysisResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchAnalysisResult
     */
    select?: BatchAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchAnalysisResult
     */
    omit?: BatchAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchAnalysisResultInclude<ExtArgs> | null
  }


  /**
   * Model AnalysisPromptTemplate
   */

  export type AggregateAnalysisPromptTemplate = {
    _count: AnalysisPromptTemplateCountAggregateOutputType | null
    _min: AnalysisPromptTemplateMinAggregateOutputType | null
    _max: AnalysisPromptTemplateMaxAggregateOutputType | null
  }

  export type AnalysisPromptTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    prompt: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalysisPromptTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    prompt: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalysisPromptTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    prompt: number
    isDefault: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalysisPromptTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    prompt?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalysisPromptTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    prompt?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalysisPromptTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    prompt?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalysisPromptTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisPromptTemplate to aggregate.
     */
    where?: AnalysisPromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisPromptTemplates to fetch.
     */
    orderBy?: AnalysisPromptTemplateOrderByWithRelationInput | AnalysisPromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalysisPromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisPromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisPromptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalysisPromptTemplates
    **/
    _count?: true | AnalysisPromptTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalysisPromptTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalysisPromptTemplateMaxAggregateInputType
  }

  export type GetAnalysisPromptTemplateAggregateType<T extends AnalysisPromptTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalysisPromptTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalysisPromptTemplate[P]>
      : GetScalarType<T[P], AggregateAnalysisPromptTemplate[P]>
  }




  export type AnalysisPromptTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisPromptTemplateWhereInput
    orderBy?: AnalysisPromptTemplateOrderByWithAggregationInput | AnalysisPromptTemplateOrderByWithAggregationInput[]
    by: AnalysisPromptTemplateScalarFieldEnum[] | AnalysisPromptTemplateScalarFieldEnum
    having?: AnalysisPromptTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalysisPromptTemplateCountAggregateInputType | true
    _min?: AnalysisPromptTemplateMinAggregateInputType
    _max?: AnalysisPromptTemplateMaxAggregateInputType
  }

  export type AnalysisPromptTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    prompt: string
    isDefault: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AnalysisPromptTemplateCountAggregateOutputType | null
    _min: AnalysisPromptTemplateMinAggregateOutputType | null
    _max: AnalysisPromptTemplateMaxAggregateOutputType | null
  }

  type GetAnalysisPromptTemplateGroupByPayload<T extends AnalysisPromptTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalysisPromptTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalysisPromptTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalysisPromptTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], AnalysisPromptTemplateGroupByOutputType[P]>
        }
      >
    >


  export type AnalysisPromptTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    prompt?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analysisPromptTemplate"]>

  export type AnalysisPromptTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    prompt?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analysisPromptTemplate"]>

  export type AnalysisPromptTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    prompt?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["analysisPromptTemplate"]>

  export type AnalysisPromptTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    prompt?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalysisPromptTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "prompt" | "isDefault" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["analysisPromptTemplate"]>

  export type $AnalysisPromptTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalysisPromptTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      prompt: string
      isDefault: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analysisPromptTemplate"]>
    composites: {}
  }

  type AnalysisPromptTemplateGetPayload<S extends boolean | null | undefined | AnalysisPromptTemplateDefaultArgs> = $Result.GetResult<Prisma.$AnalysisPromptTemplatePayload, S>

  type AnalysisPromptTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalysisPromptTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalysisPromptTemplateCountAggregateInputType | true
    }

  export interface AnalysisPromptTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalysisPromptTemplate'], meta: { name: 'AnalysisPromptTemplate' } }
    /**
     * Find zero or one AnalysisPromptTemplate that matches the filter.
     * @param {AnalysisPromptTemplateFindUniqueArgs} args - Arguments to find a AnalysisPromptTemplate
     * @example
     * // Get one AnalysisPromptTemplate
     * const analysisPromptTemplate = await prisma.analysisPromptTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalysisPromptTemplateFindUniqueArgs>(args: SelectSubset<T, AnalysisPromptTemplateFindUniqueArgs<ExtArgs>>): Prisma__AnalysisPromptTemplateClient<$Result.GetResult<Prisma.$AnalysisPromptTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalysisPromptTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalysisPromptTemplateFindUniqueOrThrowArgs} args - Arguments to find a AnalysisPromptTemplate
     * @example
     * // Get one AnalysisPromptTemplate
     * const analysisPromptTemplate = await prisma.analysisPromptTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalysisPromptTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalysisPromptTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalysisPromptTemplateClient<$Result.GetResult<Prisma.$AnalysisPromptTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisPromptTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPromptTemplateFindFirstArgs} args - Arguments to find a AnalysisPromptTemplate
     * @example
     * // Get one AnalysisPromptTemplate
     * const analysisPromptTemplate = await prisma.analysisPromptTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalysisPromptTemplateFindFirstArgs>(args?: SelectSubset<T, AnalysisPromptTemplateFindFirstArgs<ExtArgs>>): Prisma__AnalysisPromptTemplateClient<$Result.GetResult<Prisma.$AnalysisPromptTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisPromptTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPromptTemplateFindFirstOrThrowArgs} args - Arguments to find a AnalysisPromptTemplate
     * @example
     * // Get one AnalysisPromptTemplate
     * const analysisPromptTemplate = await prisma.analysisPromptTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalysisPromptTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalysisPromptTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalysisPromptTemplateClient<$Result.GetResult<Prisma.$AnalysisPromptTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalysisPromptTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPromptTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalysisPromptTemplates
     * const analysisPromptTemplates = await prisma.analysisPromptTemplate.findMany()
     * 
     * // Get first 10 AnalysisPromptTemplates
     * const analysisPromptTemplates = await prisma.analysisPromptTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analysisPromptTemplateWithIdOnly = await prisma.analysisPromptTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalysisPromptTemplateFindManyArgs>(args?: SelectSubset<T, AnalysisPromptTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisPromptTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalysisPromptTemplate.
     * @param {AnalysisPromptTemplateCreateArgs} args - Arguments to create a AnalysisPromptTemplate.
     * @example
     * // Create one AnalysisPromptTemplate
     * const AnalysisPromptTemplate = await prisma.analysisPromptTemplate.create({
     *   data: {
     *     // ... data to create a AnalysisPromptTemplate
     *   }
     * })
     * 
     */
    create<T extends AnalysisPromptTemplateCreateArgs>(args: SelectSubset<T, AnalysisPromptTemplateCreateArgs<ExtArgs>>): Prisma__AnalysisPromptTemplateClient<$Result.GetResult<Prisma.$AnalysisPromptTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalysisPromptTemplates.
     * @param {AnalysisPromptTemplateCreateManyArgs} args - Arguments to create many AnalysisPromptTemplates.
     * @example
     * // Create many AnalysisPromptTemplates
     * const analysisPromptTemplate = await prisma.analysisPromptTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalysisPromptTemplateCreateManyArgs>(args?: SelectSubset<T, AnalysisPromptTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalysisPromptTemplates and returns the data saved in the database.
     * @param {AnalysisPromptTemplateCreateManyAndReturnArgs} args - Arguments to create many AnalysisPromptTemplates.
     * @example
     * // Create many AnalysisPromptTemplates
     * const analysisPromptTemplate = await prisma.analysisPromptTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalysisPromptTemplates and only return the `id`
     * const analysisPromptTemplateWithIdOnly = await prisma.analysisPromptTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalysisPromptTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalysisPromptTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisPromptTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalysisPromptTemplate.
     * @param {AnalysisPromptTemplateDeleteArgs} args - Arguments to delete one AnalysisPromptTemplate.
     * @example
     * // Delete one AnalysisPromptTemplate
     * const AnalysisPromptTemplate = await prisma.analysisPromptTemplate.delete({
     *   where: {
     *     // ... filter to delete one AnalysisPromptTemplate
     *   }
     * })
     * 
     */
    delete<T extends AnalysisPromptTemplateDeleteArgs>(args: SelectSubset<T, AnalysisPromptTemplateDeleteArgs<ExtArgs>>): Prisma__AnalysisPromptTemplateClient<$Result.GetResult<Prisma.$AnalysisPromptTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalysisPromptTemplate.
     * @param {AnalysisPromptTemplateUpdateArgs} args - Arguments to update one AnalysisPromptTemplate.
     * @example
     * // Update one AnalysisPromptTemplate
     * const analysisPromptTemplate = await prisma.analysisPromptTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalysisPromptTemplateUpdateArgs>(args: SelectSubset<T, AnalysisPromptTemplateUpdateArgs<ExtArgs>>): Prisma__AnalysisPromptTemplateClient<$Result.GetResult<Prisma.$AnalysisPromptTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalysisPromptTemplates.
     * @param {AnalysisPromptTemplateDeleteManyArgs} args - Arguments to filter AnalysisPromptTemplates to delete.
     * @example
     * // Delete a few AnalysisPromptTemplates
     * const { count } = await prisma.analysisPromptTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalysisPromptTemplateDeleteManyArgs>(args?: SelectSubset<T, AnalysisPromptTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisPromptTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPromptTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalysisPromptTemplates
     * const analysisPromptTemplate = await prisma.analysisPromptTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalysisPromptTemplateUpdateManyArgs>(args: SelectSubset<T, AnalysisPromptTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisPromptTemplates and returns the data updated in the database.
     * @param {AnalysisPromptTemplateUpdateManyAndReturnArgs} args - Arguments to update many AnalysisPromptTemplates.
     * @example
     * // Update many AnalysisPromptTemplates
     * const analysisPromptTemplate = await prisma.analysisPromptTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalysisPromptTemplates and only return the `id`
     * const analysisPromptTemplateWithIdOnly = await prisma.analysisPromptTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalysisPromptTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalysisPromptTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisPromptTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalysisPromptTemplate.
     * @param {AnalysisPromptTemplateUpsertArgs} args - Arguments to update or create a AnalysisPromptTemplate.
     * @example
     * // Update or create a AnalysisPromptTemplate
     * const analysisPromptTemplate = await prisma.analysisPromptTemplate.upsert({
     *   create: {
     *     // ... data to create a AnalysisPromptTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalysisPromptTemplate we want to update
     *   }
     * })
     */
    upsert<T extends AnalysisPromptTemplateUpsertArgs>(args: SelectSubset<T, AnalysisPromptTemplateUpsertArgs<ExtArgs>>): Prisma__AnalysisPromptTemplateClient<$Result.GetResult<Prisma.$AnalysisPromptTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalysisPromptTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPromptTemplateCountArgs} args - Arguments to filter AnalysisPromptTemplates to count.
     * @example
     * // Count the number of AnalysisPromptTemplates
     * const count = await prisma.analysisPromptTemplate.count({
     *   where: {
     *     // ... the filter for the AnalysisPromptTemplates we want to count
     *   }
     * })
    **/
    count<T extends AnalysisPromptTemplateCountArgs>(
      args?: Subset<T, AnalysisPromptTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalysisPromptTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalysisPromptTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPromptTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalysisPromptTemplateAggregateArgs>(args: Subset<T, AnalysisPromptTemplateAggregateArgs>): Prisma.PrismaPromise<GetAnalysisPromptTemplateAggregateType<T>>

    /**
     * Group by AnalysisPromptTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisPromptTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalysisPromptTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalysisPromptTemplateGroupByArgs['orderBy'] }
        : { orderBy?: AnalysisPromptTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalysisPromptTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalysisPromptTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalysisPromptTemplate model
   */
  readonly fields: AnalysisPromptTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalysisPromptTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalysisPromptTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalysisPromptTemplate model
   */
  interface AnalysisPromptTemplateFieldRefs {
    readonly id: FieldRef<"AnalysisPromptTemplate", 'String'>
    readonly name: FieldRef<"AnalysisPromptTemplate", 'String'>
    readonly description: FieldRef<"AnalysisPromptTemplate", 'String'>
    readonly prompt: FieldRef<"AnalysisPromptTemplate", 'String'>
    readonly isDefault: FieldRef<"AnalysisPromptTemplate", 'Boolean'>
    readonly isActive: FieldRef<"AnalysisPromptTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"AnalysisPromptTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalysisPromptTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalysisPromptTemplate findUnique
   */
  export type AnalysisPromptTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AnalysisPromptTemplate to fetch.
     */
    where: AnalysisPromptTemplateWhereUniqueInput
  }

  /**
   * AnalysisPromptTemplate findUniqueOrThrow
   */
  export type AnalysisPromptTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AnalysisPromptTemplate to fetch.
     */
    where: AnalysisPromptTemplateWhereUniqueInput
  }

  /**
   * AnalysisPromptTemplate findFirst
   */
  export type AnalysisPromptTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AnalysisPromptTemplate to fetch.
     */
    where?: AnalysisPromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisPromptTemplates to fetch.
     */
    orderBy?: AnalysisPromptTemplateOrderByWithRelationInput | AnalysisPromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisPromptTemplates.
     */
    cursor?: AnalysisPromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisPromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisPromptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisPromptTemplates.
     */
    distinct?: AnalysisPromptTemplateScalarFieldEnum | AnalysisPromptTemplateScalarFieldEnum[]
  }

  /**
   * AnalysisPromptTemplate findFirstOrThrow
   */
  export type AnalysisPromptTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AnalysisPromptTemplate to fetch.
     */
    where?: AnalysisPromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisPromptTemplates to fetch.
     */
    orderBy?: AnalysisPromptTemplateOrderByWithRelationInput | AnalysisPromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisPromptTemplates.
     */
    cursor?: AnalysisPromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisPromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisPromptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisPromptTemplates.
     */
    distinct?: AnalysisPromptTemplateScalarFieldEnum | AnalysisPromptTemplateScalarFieldEnum[]
  }

  /**
   * AnalysisPromptTemplate findMany
   */
  export type AnalysisPromptTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AnalysisPromptTemplates to fetch.
     */
    where?: AnalysisPromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisPromptTemplates to fetch.
     */
    orderBy?: AnalysisPromptTemplateOrderByWithRelationInput | AnalysisPromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalysisPromptTemplates.
     */
    cursor?: AnalysisPromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisPromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisPromptTemplates.
     */
    skip?: number
    distinct?: AnalysisPromptTemplateScalarFieldEnum | AnalysisPromptTemplateScalarFieldEnum[]
  }

  /**
   * AnalysisPromptTemplate create
   */
  export type AnalysisPromptTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a AnalysisPromptTemplate.
     */
    data: XOR<AnalysisPromptTemplateCreateInput, AnalysisPromptTemplateUncheckedCreateInput>
  }

  /**
   * AnalysisPromptTemplate createMany
   */
  export type AnalysisPromptTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalysisPromptTemplates.
     */
    data: AnalysisPromptTemplateCreateManyInput | AnalysisPromptTemplateCreateManyInput[]
  }

  /**
   * AnalysisPromptTemplate createManyAndReturn
   */
  export type AnalysisPromptTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many AnalysisPromptTemplates.
     */
    data: AnalysisPromptTemplateCreateManyInput | AnalysisPromptTemplateCreateManyInput[]
  }

  /**
   * AnalysisPromptTemplate update
   */
  export type AnalysisPromptTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a AnalysisPromptTemplate.
     */
    data: XOR<AnalysisPromptTemplateUpdateInput, AnalysisPromptTemplateUncheckedUpdateInput>
    /**
     * Choose, which AnalysisPromptTemplate to update.
     */
    where: AnalysisPromptTemplateWhereUniqueInput
  }

  /**
   * AnalysisPromptTemplate updateMany
   */
  export type AnalysisPromptTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalysisPromptTemplates.
     */
    data: XOR<AnalysisPromptTemplateUpdateManyMutationInput, AnalysisPromptTemplateUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisPromptTemplates to update
     */
    where?: AnalysisPromptTemplateWhereInput
    /**
     * Limit how many AnalysisPromptTemplates to update.
     */
    limit?: number
  }

  /**
   * AnalysisPromptTemplate updateManyAndReturn
   */
  export type AnalysisPromptTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
    /**
     * The data used to update AnalysisPromptTemplates.
     */
    data: XOR<AnalysisPromptTemplateUpdateManyMutationInput, AnalysisPromptTemplateUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisPromptTemplates to update
     */
    where?: AnalysisPromptTemplateWhereInput
    /**
     * Limit how many AnalysisPromptTemplates to update.
     */
    limit?: number
  }

  /**
   * AnalysisPromptTemplate upsert
   */
  export type AnalysisPromptTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the AnalysisPromptTemplate to update in case it exists.
     */
    where: AnalysisPromptTemplateWhereUniqueInput
    /**
     * In case the AnalysisPromptTemplate found by the `where` argument doesn't exist, create a new AnalysisPromptTemplate with this data.
     */
    create: XOR<AnalysisPromptTemplateCreateInput, AnalysisPromptTemplateUncheckedCreateInput>
    /**
     * In case the AnalysisPromptTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalysisPromptTemplateUpdateInput, AnalysisPromptTemplateUncheckedUpdateInput>
  }

  /**
   * AnalysisPromptTemplate delete
   */
  export type AnalysisPromptTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter which AnalysisPromptTemplate to delete.
     */
    where: AnalysisPromptTemplateWhereUniqueInput
  }

  /**
   * AnalysisPromptTemplate deleteMany
   */
  export type AnalysisPromptTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisPromptTemplates to delete
     */
    where?: AnalysisPromptTemplateWhereInput
    /**
     * Limit how many AnalysisPromptTemplates to delete.
     */
    limit?: number
  }

  /**
   * AnalysisPromptTemplate without action
   */
  export type AnalysisPromptTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisPromptTemplate
     */
    select?: AnalysisPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisPromptTemplate
     */
    omit?: AnalysisPromptTemplateOmit<ExtArgs> | null
  }


  /**
   * Model BatchSchedulerConfig
   */

  export type AggregateBatchSchedulerConfig = {
    _count: BatchSchedulerConfigCountAggregateOutputType | null
    _avg: BatchSchedulerConfigAvgAggregateOutputType | null
    _sum: BatchSchedulerConfigSumAggregateOutputType | null
    _min: BatchSchedulerConfigMinAggregateOutputType | null
    _max: BatchSchedulerConfigMaxAggregateOutputType | null
  }

  export type BatchSchedulerConfigAvgAggregateOutputType = {
    hour: number | null
    minute: number | null
    sampleSize: number | null
  }

  export type BatchSchedulerConfigSumAggregateOutputType = {
    hour: number | null
    minute: number | null
    sampleSize: number | null
  }

  export type BatchSchedulerConfigMinAggregateOutputType = {
    id: string | null
    name: string | null
    isEnabled: boolean | null
    hour: number | null
    minute: number | null
    daysOfWeek: string | null
    timeZone: string | null
    targetTenantId: string | null
    sampleSize: number | null
    promptTemplateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchSchedulerConfigMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isEnabled: boolean | null
    hour: number | null
    minute: number | null
    daysOfWeek: string | null
    timeZone: string | null
    targetTenantId: string | null
    sampleSize: number | null
    promptTemplateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchSchedulerConfigCountAggregateOutputType = {
    id: number
    name: number
    isEnabled: number
    hour: number
    minute: number
    daysOfWeek: number
    timeZone: number
    targetTenantId: number
    sampleSize: number
    promptTemplateId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchSchedulerConfigAvgAggregateInputType = {
    hour?: true
    minute?: true
    sampleSize?: true
  }

  export type BatchSchedulerConfigSumAggregateInputType = {
    hour?: true
    minute?: true
    sampleSize?: true
  }

  export type BatchSchedulerConfigMinAggregateInputType = {
    id?: true
    name?: true
    isEnabled?: true
    hour?: true
    minute?: true
    daysOfWeek?: true
    timeZone?: true
    targetTenantId?: true
    sampleSize?: true
    promptTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchSchedulerConfigMaxAggregateInputType = {
    id?: true
    name?: true
    isEnabled?: true
    hour?: true
    minute?: true
    daysOfWeek?: true
    timeZone?: true
    targetTenantId?: true
    sampleSize?: true
    promptTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchSchedulerConfigCountAggregateInputType = {
    id?: true
    name?: true
    isEnabled?: true
    hour?: true
    minute?: true
    daysOfWeek?: true
    timeZone?: true
    targetTenantId?: true
    sampleSize?: true
    promptTemplateId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchSchedulerConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchSchedulerConfig to aggregate.
     */
    where?: BatchSchedulerConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchSchedulerConfigs to fetch.
     */
    orderBy?: BatchSchedulerConfigOrderByWithRelationInput | BatchSchedulerConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchSchedulerConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchSchedulerConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchSchedulerConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchSchedulerConfigs
    **/
    _count?: true | BatchSchedulerConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchSchedulerConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchSchedulerConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchSchedulerConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchSchedulerConfigMaxAggregateInputType
  }

  export type GetBatchSchedulerConfigAggregateType<T extends BatchSchedulerConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchSchedulerConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchSchedulerConfig[P]>
      : GetScalarType<T[P], AggregateBatchSchedulerConfig[P]>
  }




  export type BatchSchedulerConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchSchedulerConfigWhereInput
    orderBy?: BatchSchedulerConfigOrderByWithAggregationInput | BatchSchedulerConfigOrderByWithAggregationInput[]
    by: BatchSchedulerConfigScalarFieldEnum[] | BatchSchedulerConfigScalarFieldEnum
    having?: BatchSchedulerConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchSchedulerConfigCountAggregateInputType | true
    _avg?: BatchSchedulerConfigAvgAggregateInputType
    _sum?: BatchSchedulerConfigSumAggregateInputType
    _min?: BatchSchedulerConfigMinAggregateInputType
    _max?: BatchSchedulerConfigMaxAggregateInputType
  }

  export type BatchSchedulerConfigGroupByOutputType = {
    id: string
    name: string
    isEnabled: boolean
    hour: number
    minute: number
    daysOfWeek: string
    timeZone: string
    targetTenantId: string | null
    sampleSize: number
    promptTemplateId: string | null
    createdAt: Date
    updatedAt: Date
    _count: BatchSchedulerConfigCountAggregateOutputType | null
    _avg: BatchSchedulerConfigAvgAggregateOutputType | null
    _sum: BatchSchedulerConfigSumAggregateOutputType | null
    _min: BatchSchedulerConfigMinAggregateOutputType | null
    _max: BatchSchedulerConfigMaxAggregateOutputType | null
  }

  type GetBatchSchedulerConfigGroupByPayload<T extends BatchSchedulerConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchSchedulerConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchSchedulerConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchSchedulerConfigGroupByOutputType[P]>
            : GetScalarType<T[P], BatchSchedulerConfigGroupByOutputType[P]>
        }
      >
    >


  export type BatchSchedulerConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isEnabled?: boolean
    hour?: boolean
    minute?: boolean
    daysOfWeek?: boolean
    timeZone?: boolean
    targetTenantId?: boolean
    sampleSize?: boolean
    promptTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchSchedulerConfig"]>

  export type BatchSchedulerConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isEnabled?: boolean
    hour?: boolean
    minute?: boolean
    daysOfWeek?: boolean
    timeZone?: boolean
    targetTenantId?: boolean
    sampleSize?: boolean
    promptTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchSchedulerConfig"]>

  export type BatchSchedulerConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isEnabled?: boolean
    hour?: boolean
    minute?: boolean
    daysOfWeek?: boolean
    timeZone?: boolean
    targetTenantId?: boolean
    sampleSize?: boolean
    promptTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchSchedulerConfig"]>

  export type BatchSchedulerConfigSelectScalar = {
    id?: boolean
    name?: boolean
    isEnabled?: boolean
    hour?: boolean
    minute?: boolean
    daysOfWeek?: boolean
    timeZone?: boolean
    targetTenantId?: boolean
    sampleSize?: boolean
    promptTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BatchSchedulerConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isEnabled" | "hour" | "minute" | "daysOfWeek" | "timeZone" | "targetTenantId" | "sampleSize" | "promptTemplateId" | "createdAt" | "updatedAt", ExtArgs["result"]["batchSchedulerConfig"]>

  export type $BatchSchedulerConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchSchedulerConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isEnabled: boolean
      hour: number
      minute: number
      daysOfWeek: string
      timeZone: string
      targetTenantId: string | null
      sampleSize: number
      promptTemplateId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batchSchedulerConfig"]>
    composites: {}
  }

  type BatchSchedulerConfigGetPayload<S extends boolean | null | undefined | BatchSchedulerConfigDefaultArgs> = $Result.GetResult<Prisma.$BatchSchedulerConfigPayload, S>

  type BatchSchedulerConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchSchedulerConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchSchedulerConfigCountAggregateInputType | true
    }

  export interface BatchSchedulerConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchSchedulerConfig'], meta: { name: 'BatchSchedulerConfig' } }
    /**
     * Find zero or one BatchSchedulerConfig that matches the filter.
     * @param {BatchSchedulerConfigFindUniqueArgs} args - Arguments to find a BatchSchedulerConfig
     * @example
     * // Get one BatchSchedulerConfig
     * const batchSchedulerConfig = await prisma.batchSchedulerConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchSchedulerConfigFindUniqueArgs>(args: SelectSubset<T, BatchSchedulerConfigFindUniqueArgs<ExtArgs>>): Prisma__BatchSchedulerConfigClient<$Result.GetResult<Prisma.$BatchSchedulerConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BatchSchedulerConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchSchedulerConfigFindUniqueOrThrowArgs} args - Arguments to find a BatchSchedulerConfig
     * @example
     * // Get one BatchSchedulerConfig
     * const batchSchedulerConfig = await prisma.batchSchedulerConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchSchedulerConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchSchedulerConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchSchedulerConfigClient<$Result.GetResult<Prisma.$BatchSchedulerConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchSchedulerConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchSchedulerConfigFindFirstArgs} args - Arguments to find a BatchSchedulerConfig
     * @example
     * // Get one BatchSchedulerConfig
     * const batchSchedulerConfig = await prisma.batchSchedulerConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchSchedulerConfigFindFirstArgs>(args?: SelectSubset<T, BatchSchedulerConfigFindFirstArgs<ExtArgs>>): Prisma__BatchSchedulerConfigClient<$Result.GetResult<Prisma.$BatchSchedulerConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchSchedulerConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchSchedulerConfigFindFirstOrThrowArgs} args - Arguments to find a BatchSchedulerConfig
     * @example
     * // Get one BatchSchedulerConfig
     * const batchSchedulerConfig = await prisma.batchSchedulerConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchSchedulerConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchSchedulerConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchSchedulerConfigClient<$Result.GetResult<Prisma.$BatchSchedulerConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BatchSchedulerConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchSchedulerConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchSchedulerConfigs
     * const batchSchedulerConfigs = await prisma.batchSchedulerConfig.findMany()
     * 
     * // Get first 10 BatchSchedulerConfigs
     * const batchSchedulerConfigs = await prisma.batchSchedulerConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchSchedulerConfigWithIdOnly = await prisma.batchSchedulerConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchSchedulerConfigFindManyArgs>(args?: SelectSubset<T, BatchSchedulerConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchSchedulerConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BatchSchedulerConfig.
     * @param {BatchSchedulerConfigCreateArgs} args - Arguments to create a BatchSchedulerConfig.
     * @example
     * // Create one BatchSchedulerConfig
     * const BatchSchedulerConfig = await prisma.batchSchedulerConfig.create({
     *   data: {
     *     // ... data to create a BatchSchedulerConfig
     *   }
     * })
     * 
     */
    create<T extends BatchSchedulerConfigCreateArgs>(args: SelectSubset<T, BatchSchedulerConfigCreateArgs<ExtArgs>>): Prisma__BatchSchedulerConfigClient<$Result.GetResult<Prisma.$BatchSchedulerConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BatchSchedulerConfigs.
     * @param {BatchSchedulerConfigCreateManyArgs} args - Arguments to create many BatchSchedulerConfigs.
     * @example
     * // Create many BatchSchedulerConfigs
     * const batchSchedulerConfig = await prisma.batchSchedulerConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchSchedulerConfigCreateManyArgs>(args?: SelectSubset<T, BatchSchedulerConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BatchSchedulerConfigs and returns the data saved in the database.
     * @param {BatchSchedulerConfigCreateManyAndReturnArgs} args - Arguments to create many BatchSchedulerConfigs.
     * @example
     * // Create many BatchSchedulerConfigs
     * const batchSchedulerConfig = await prisma.batchSchedulerConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BatchSchedulerConfigs and only return the `id`
     * const batchSchedulerConfigWithIdOnly = await prisma.batchSchedulerConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchSchedulerConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchSchedulerConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchSchedulerConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BatchSchedulerConfig.
     * @param {BatchSchedulerConfigDeleteArgs} args - Arguments to delete one BatchSchedulerConfig.
     * @example
     * // Delete one BatchSchedulerConfig
     * const BatchSchedulerConfig = await prisma.batchSchedulerConfig.delete({
     *   where: {
     *     // ... filter to delete one BatchSchedulerConfig
     *   }
     * })
     * 
     */
    delete<T extends BatchSchedulerConfigDeleteArgs>(args: SelectSubset<T, BatchSchedulerConfigDeleteArgs<ExtArgs>>): Prisma__BatchSchedulerConfigClient<$Result.GetResult<Prisma.$BatchSchedulerConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BatchSchedulerConfig.
     * @param {BatchSchedulerConfigUpdateArgs} args - Arguments to update one BatchSchedulerConfig.
     * @example
     * // Update one BatchSchedulerConfig
     * const batchSchedulerConfig = await prisma.batchSchedulerConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchSchedulerConfigUpdateArgs>(args: SelectSubset<T, BatchSchedulerConfigUpdateArgs<ExtArgs>>): Prisma__BatchSchedulerConfigClient<$Result.GetResult<Prisma.$BatchSchedulerConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BatchSchedulerConfigs.
     * @param {BatchSchedulerConfigDeleteManyArgs} args - Arguments to filter BatchSchedulerConfigs to delete.
     * @example
     * // Delete a few BatchSchedulerConfigs
     * const { count } = await prisma.batchSchedulerConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchSchedulerConfigDeleteManyArgs>(args?: SelectSubset<T, BatchSchedulerConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchSchedulerConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchSchedulerConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchSchedulerConfigs
     * const batchSchedulerConfig = await prisma.batchSchedulerConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchSchedulerConfigUpdateManyArgs>(args: SelectSubset<T, BatchSchedulerConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchSchedulerConfigs and returns the data updated in the database.
     * @param {BatchSchedulerConfigUpdateManyAndReturnArgs} args - Arguments to update many BatchSchedulerConfigs.
     * @example
     * // Update many BatchSchedulerConfigs
     * const batchSchedulerConfig = await prisma.batchSchedulerConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BatchSchedulerConfigs and only return the `id`
     * const batchSchedulerConfigWithIdOnly = await prisma.batchSchedulerConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchSchedulerConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchSchedulerConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchSchedulerConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BatchSchedulerConfig.
     * @param {BatchSchedulerConfigUpsertArgs} args - Arguments to update or create a BatchSchedulerConfig.
     * @example
     * // Update or create a BatchSchedulerConfig
     * const batchSchedulerConfig = await prisma.batchSchedulerConfig.upsert({
     *   create: {
     *     // ... data to create a BatchSchedulerConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchSchedulerConfig we want to update
     *   }
     * })
     */
    upsert<T extends BatchSchedulerConfigUpsertArgs>(args: SelectSubset<T, BatchSchedulerConfigUpsertArgs<ExtArgs>>): Prisma__BatchSchedulerConfigClient<$Result.GetResult<Prisma.$BatchSchedulerConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BatchSchedulerConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchSchedulerConfigCountArgs} args - Arguments to filter BatchSchedulerConfigs to count.
     * @example
     * // Count the number of BatchSchedulerConfigs
     * const count = await prisma.batchSchedulerConfig.count({
     *   where: {
     *     // ... the filter for the BatchSchedulerConfigs we want to count
     *   }
     * })
    **/
    count<T extends BatchSchedulerConfigCountArgs>(
      args?: Subset<T, BatchSchedulerConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchSchedulerConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchSchedulerConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchSchedulerConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchSchedulerConfigAggregateArgs>(args: Subset<T, BatchSchedulerConfigAggregateArgs>): Prisma.PrismaPromise<GetBatchSchedulerConfigAggregateType<T>>

    /**
     * Group by BatchSchedulerConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchSchedulerConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchSchedulerConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchSchedulerConfigGroupByArgs['orderBy'] }
        : { orderBy?: BatchSchedulerConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchSchedulerConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchSchedulerConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchSchedulerConfig model
   */
  readonly fields: BatchSchedulerConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchSchedulerConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchSchedulerConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchSchedulerConfig model
   */
  interface BatchSchedulerConfigFieldRefs {
    readonly id: FieldRef<"BatchSchedulerConfig", 'String'>
    readonly name: FieldRef<"BatchSchedulerConfig", 'String'>
    readonly isEnabled: FieldRef<"BatchSchedulerConfig", 'Boolean'>
    readonly hour: FieldRef<"BatchSchedulerConfig", 'Int'>
    readonly minute: FieldRef<"BatchSchedulerConfig", 'Int'>
    readonly daysOfWeek: FieldRef<"BatchSchedulerConfig", 'String'>
    readonly timeZone: FieldRef<"BatchSchedulerConfig", 'String'>
    readonly targetTenantId: FieldRef<"BatchSchedulerConfig", 'String'>
    readonly sampleSize: FieldRef<"BatchSchedulerConfig", 'Int'>
    readonly promptTemplateId: FieldRef<"BatchSchedulerConfig", 'String'>
    readonly createdAt: FieldRef<"BatchSchedulerConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"BatchSchedulerConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BatchSchedulerConfig findUnique
   */
  export type BatchSchedulerConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
    /**
     * Filter, which BatchSchedulerConfig to fetch.
     */
    where: BatchSchedulerConfigWhereUniqueInput
  }

  /**
   * BatchSchedulerConfig findUniqueOrThrow
   */
  export type BatchSchedulerConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
    /**
     * Filter, which BatchSchedulerConfig to fetch.
     */
    where: BatchSchedulerConfigWhereUniqueInput
  }

  /**
   * BatchSchedulerConfig findFirst
   */
  export type BatchSchedulerConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
    /**
     * Filter, which BatchSchedulerConfig to fetch.
     */
    where?: BatchSchedulerConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchSchedulerConfigs to fetch.
     */
    orderBy?: BatchSchedulerConfigOrderByWithRelationInput | BatchSchedulerConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchSchedulerConfigs.
     */
    cursor?: BatchSchedulerConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchSchedulerConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchSchedulerConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchSchedulerConfigs.
     */
    distinct?: BatchSchedulerConfigScalarFieldEnum | BatchSchedulerConfigScalarFieldEnum[]
  }

  /**
   * BatchSchedulerConfig findFirstOrThrow
   */
  export type BatchSchedulerConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
    /**
     * Filter, which BatchSchedulerConfig to fetch.
     */
    where?: BatchSchedulerConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchSchedulerConfigs to fetch.
     */
    orderBy?: BatchSchedulerConfigOrderByWithRelationInput | BatchSchedulerConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchSchedulerConfigs.
     */
    cursor?: BatchSchedulerConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchSchedulerConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchSchedulerConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchSchedulerConfigs.
     */
    distinct?: BatchSchedulerConfigScalarFieldEnum | BatchSchedulerConfigScalarFieldEnum[]
  }

  /**
   * BatchSchedulerConfig findMany
   */
  export type BatchSchedulerConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
    /**
     * Filter, which BatchSchedulerConfigs to fetch.
     */
    where?: BatchSchedulerConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchSchedulerConfigs to fetch.
     */
    orderBy?: BatchSchedulerConfigOrderByWithRelationInput | BatchSchedulerConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchSchedulerConfigs.
     */
    cursor?: BatchSchedulerConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchSchedulerConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchSchedulerConfigs.
     */
    skip?: number
    distinct?: BatchSchedulerConfigScalarFieldEnum | BatchSchedulerConfigScalarFieldEnum[]
  }

  /**
   * BatchSchedulerConfig create
   */
  export type BatchSchedulerConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a BatchSchedulerConfig.
     */
    data: XOR<BatchSchedulerConfigCreateInput, BatchSchedulerConfigUncheckedCreateInput>
  }

  /**
   * BatchSchedulerConfig createMany
   */
  export type BatchSchedulerConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchSchedulerConfigs.
     */
    data: BatchSchedulerConfigCreateManyInput | BatchSchedulerConfigCreateManyInput[]
  }

  /**
   * BatchSchedulerConfig createManyAndReturn
   */
  export type BatchSchedulerConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
    /**
     * The data used to create many BatchSchedulerConfigs.
     */
    data: BatchSchedulerConfigCreateManyInput | BatchSchedulerConfigCreateManyInput[]
  }

  /**
   * BatchSchedulerConfig update
   */
  export type BatchSchedulerConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a BatchSchedulerConfig.
     */
    data: XOR<BatchSchedulerConfigUpdateInput, BatchSchedulerConfigUncheckedUpdateInput>
    /**
     * Choose, which BatchSchedulerConfig to update.
     */
    where: BatchSchedulerConfigWhereUniqueInput
  }

  /**
   * BatchSchedulerConfig updateMany
   */
  export type BatchSchedulerConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchSchedulerConfigs.
     */
    data: XOR<BatchSchedulerConfigUpdateManyMutationInput, BatchSchedulerConfigUncheckedUpdateManyInput>
    /**
     * Filter which BatchSchedulerConfigs to update
     */
    where?: BatchSchedulerConfigWhereInput
    /**
     * Limit how many BatchSchedulerConfigs to update.
     */
    limit?: number
  }

  /**
   * BatchSchedulerConfig updateManyAndReturn
   */
  export type BatchSchedulerConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
    /**
     * The data used to update BatchSchedulerConfigs.
     */
    data: XOR<BatchSchedulerConfigUpdateManyMutationInput, BatchSchedulerConfigUncheckedUpdateManyInput>
    /**
     * Filter which BatchSchedulerConfigs to update
     */
    where?: BatchSchedulerConfigWhereInput
    /**
     * Limit how many BatchSchedulerConfigs to update.
     */
    limit?: number
  }

  /**
   * BatchSchedulerConfig upsert
   */
  export type BatchSchedulerConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the BatchSchedulerConfig to update in case it exists.
     */
    where: BatchSchedulerConfigWhereUniqueInput
    /**
     * In case the BatchSchedulerConfig found by the `where` argument doesn't exist, create a new BatchSchedulerConfig with this data.
     */
    create: XOR<BatchSchedulerConfigCreateInput, BatchSchedulerConfigUncheckedCreateInput>
    /**
     * In case the BatchSchedulerConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchSchedulerConfigUpdateInput, BatchSchedulerConfigUncheckedUpdateInput>
  }

  /**
   * BatchSchedulerConfig delete
   */
  export type BatchSchedulerConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
    /**
     * Filter which BatchSchedulerConfig to delete.
     */
    where: BatchSchedulerConfigWhereUniqueInput
  }

  /**
   * BatchSchedulerConfig deleteMany
   */
  export type BatchSchedulerConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchSchedulerConfigs to delete
     */
    where?: BatchSchedulerConfigWhereInput
    /**
     * Limit how many BatchSchedulerConfigs to delete.
     */
    limit?: number
  }

  /**
   * BatchSchedulerConfig without action
   */
  export type BatchSchedulerConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchSchedulerConfig
     */
    select?: BatchSchedulerConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchSchedulerConfig
     */
    omit?: BatchSchedulerConfigOmit<ExtArgs> | null
  }


  /**
   * Model FAQAnalysisJob
   */

  export type AggregateFAQAnalysisJob = {
    _count: FAQAnalysisJobCountAggregateOutputType | null
    _avg: FAQAnalysisJobAvgAggregateOutputType | null
    _sum: FAQAnalysisJobSumAggregateOutputType | null
    _min: FAQAnalysisJobMinAggregateOutputType | null
    _max: FAQAnalysisJobMaxAggregateOutputType | null
  }

  export type FAQAnalysisJobAvgAggregateOutputType = {
    periodDays: number | null
    topN: number | null
    totalQuestions: number | null
    clusterCount: number | null
  }

  export type FAQAnalysisJobSumAggregateOutputType = {
    periodDays: number | null
    topN: number | null
    totalQuestions: number | null
    clusterCount: number | null
  }

  export type FAQAnalysisJobMinAggregateOutputType = {
    id: string | null
    status: string | null
    tenantId: string | null
    periodDays: number | null
    topN: number | null
    totalQuestions: number | null
    clusterCount: number | null
    llmMergeApplied: boolean | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type FAQAnalysisJobMaxAggregateOutputType = {
    id: string | null
    status: string | null
    tenantId: string | null
    periodDays: number | null
    topN: number | null
    totalQuestions: number | null
    clusterCount: number | null
    llmMergeApplied: boolean | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type FAQAnalysisJobCountAggregateOutputType = {
    id: number
    status: number
    tenantId: number
    periodDays: number
    topN: number
    totalQuestions: number
    clusterCount: number
    llmMergeApplied: number
    startedAt: number
    completedAt: number
    errorMessage: number
    createdAt: number
    _all: number
  }


  export type FAQAnalysisJobAvgAggregateInputType = {
    periodDays?: true
    topN?: true
    totalQuestions?: true
    clusterCount?: true
  }

  export type FAQAnalysisJobSumAggregateInputType = {
    periodDays?: true
    topN?: true
    totalQuestions?: true
    clusterCount?: true
  }

  export type FAQAnalysisJobMinAggregateInputType = {
    id?: true
    status?: true
    tenantId?: true
    periodDays?: true
    topN?: true
    totalQuestions?: true
    clusterCount?: true
    llmMergeApplied?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
  }

  export type FAQAnalysisJobMaxAggregateInputType = {
    id?: true
    status?: true
    tenantId?: true
    periodDays?: true
    topN?: true
    totalQuestions?: true
    clusterCount?: true
    llmMergeApplied?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
  }

  export type FAQAnalysisJobCountAggregateInputType = {
    id?: true
    status?: true
    tenantId?: true
    periodDays?: true
    topN?: true
    totalQuestions?: true
    clusterCount?: true
    llmMergeApplied?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
    _all?: true
  }

  export type FAQAnalysisJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQAnalysisJob to aggregate.
     */
    where?: FAQAnalysisJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQAnalysisJobs to fetch.
     */
    orderBy?: FAQAnalysisJobOrderByWithRelationInput | FAQAnalysisJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQAnalysisJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQAnalysisJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQAnalysisJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQAnalysisJobs
    **/
    _count?: true | FAQAnalysisJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FAQAnalysisJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FAQAnalysisJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQAnalysisJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQAnalysisJobMaxAggregateInputType
  }

  export type GetFAQAnalysisJobAggregateType<T extends FAQAnalysisJobAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQAnalysisJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQAnalysisJob[P]>
      : GetScalarType<T[P], AggregateFAQAnalysisJob[P]>
  }




  export type FAQAnalysisJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQAnalysisJobWhereInput
    orderBy?: FAQAnalysisJobOrderByWithAggregationInput | FAQAnalysisJobOrderByWithAggregationInput[]
    by: FAQAnalysisJobScalarFieldEnum[] | FAQAnalysisJobScalarFieldEnum
    having?: FAQAnalysisJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQAnalysisJobCountAggregateInputType | true
    _avg?: FAQAnalysisJobAvgAggregateInputType
    _sum?: FAQAnalysisJobSumAggregateInputType
    _min?: FAQAnalysisJobMinAggregateInputType
    _max?: FAQAnalysisJobMaxAggregateInputType
  }

  export type FAQAnalysisJobGroupByOutputType = {
    id: string
    status: string
    tenantId: string | null
    periodDays: number
    topN: number
    totalQuestions: number | null
    clusterCount: number | null
    llmMergeApplied: boolean
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date
    _count: FAQAnalysisJobCountAggregateOutputType | null
    _avg: FAQAnalysisJobAvgAggregateOutputType | null
    _sum: FAQAnalysisJobSumAggregateOutputType | null
    _min: FAQAnalysisJobMinAggregateOutputType | null
    _max: FAQAnalysisJobMaxAggregateOutputType | null
  }

  type GetFAQAnalysisJobGroupByPayload<T extends FAQAnalysisJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQAnalysisJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQAnalysisJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQAnalysisJobGroupByOutputType[P]>
            : GetScalarType<T[P], FAQAnalysisJobGroupByOutputType[P]>
        }
      >
    >


  export type FAQAnalysisJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    tenantId?: boolean
    periodDays?: boolean
    topN?: boolean
    totalQuestions?: boolean
    clusterCount?: boolean
    llmMergeApplied?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    results?: boolean | FAQAnalysisJob$resultsArgs<ExtArgs>
    _count?: boolean | FAQAnalysisJobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fAQAnalysisJob"]>

  export type FAQAnalysisJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    tenantId?: boolean
    periodDays?: boolean
    topN?: boolean
    totalQuestions?: boolean
    clusterCount?: boolean
    llmMergeApplied?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["fAQAnalysisJob"]>

  export type FAQAnalysisJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    tenantId?: boolean
    periodDays?: boolean
    topN?: boolean
    totalQuestions?: boolean
    clusterCount?: boolean
    llmMergeApplied?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["fAQAnalysisJob"]>

  export type FAQAnalysisJobSelectScalar = {
    id?: boolean
    status?: boolean
    tenantId?: boolean
    periodDays?: boolean
    topN?: boolean
    totalQuestions?: boolean
    clusterCount?: boolean
    llmMergeApplied?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }

  export type FAQAnalysisJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "tenantId" | "periodDays" | "topN" | "totalQuestions" | "clusterCount" | "llmMergeApplied" | "startedAt" | "completedAt" | "errorMessage" | "createdAt", ExtArgs["result"]["fAQAnalysisJob"]>
  export type FAQAnalysisJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | FAQAnalysisJob$resultsArgs<ExtArgs>
    _count?: boolean | FAQAnalysisJobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FAQAnalysisJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FAQAnalysisJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FAQAnalysisJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQAnalysisJob"
    objects: {
      results: Prisma.$FAQAnalysisResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      tenantId: string | null
      periodDays: number
      topN: number
      totalQuestions: number | null
      clusterCount: number | null
      llmMergeApplied: boolean
      startedAt: Date | null
      completedAt: Date | null
      errorMessage: string | null
      createdAt: Date
    }, ExtArgs["result"]["fAQAnalysisJob"]>
    composites: {}
  }

  type FAQAnalysisJobGetPayload<S extends boolean | null | undefined | FAQAnalysisJobDefaultArgs> = $Result.GetResult<Prisma.$FAQAnalysisJobPayload, S>

  type FAQAnalysisJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FAQAnalysisJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FAQAnalysisJobCountAggregateInputType | true
    }

  export interface FAQAnalysisJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQAnalysisJob'], meta: { name: 'FAQAnalysisJob' } }
    /**
     * Find zero or one FAQAnalysisJob that matches the filter.
     * @param {FAQAnalysisJobFindUniqueArgs} args - Arguments to find a FAQAnalysisJob
     * @example
     * // Get one FAQAnalysisJob
     * const fAQAnalysisJob = await prisma.fAQAnalysisJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FAQAnalysisJobFindUniqueArgs>(args: SelectSubset<T, FAQAnalysisJobFindUniqueArgs<ExtArgs>>): Prisma__FAQAnalysisJobClient<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FAQAnalysisJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FAQAnalysisJobFindUniqueOrThrowArgs} args - Arguments to find a FAQAnalysisJob
     * @example
     * // Get one FAQAnalysisJob
     * const fAQAnalysisJob = await prisma.fAQAnalysisJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FAQAnalysisJobFindUniqueOrThrowArgs>(args: SelectSubset<T, FAQAnalysisJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FAQAnalysisJobClient<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQAnalysisJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisJobFindFirstArgs} args - Arguments to find a FAQAnalysisJob
     * @example
     * // Get one FAQAnalysisJob
     * const fAQAnalysisJob = await prisma.fAQAnalysisJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FAQAnalysisJobFindFirstArgs>(args?: SelectSubset<T, FAQAnalysisJobFindFirstArgs<ExtArgs>>): Prisma__FAQAnalysisJobClient<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQAnalysisJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisJobFindFirstOrThrowArgs} args - Arguments to find a FAQAnalysisJob
     * @example
     * // Get one FAQAnalysisJob
     * const fAQAnalysisJob = await prisma.fAQAnalysisJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FAQAnalysisJobFindFirstOrThrowArgs>(args?: SelectSubset<T, FAQAnalysisJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__FAQAnalysisJobClient<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FAQAnalysisJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQAnalysisJobs
     * const fAQAnalysisJobs = await prisma.fAQAnalysisJob.findMany()
     * 
     * // Get first 10 FAQAnalysisJobs
     * const fAQAnalysisJobs = await prisma.fAQAnalysisJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fAQAnalysisJobWithIdOnly = await prisma.fAQAnalysisJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FAQAnalysisJobFindManyArgs>(args?: SelectSubset<T, FAQAnalysisJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FAQAnalysisJob.
     * @param {FAQAnalysisJobCreateArgs} args - Arguments to create a FAQAnalysisJob.
     * @example
     * // Create one FAQAnalysisJob
     * const FAQAnalysisJob = await prisma.fAQAnalysisJob.create({
     *   data: {
     *     // ... data to create a FAQAnalysisJob
     *   }
     * })
     * 
     */
    create<T extends FAQAnalysisJobCreateArgs>(args: SelectSubset<T, FAQAnalysisJobCreateArgs<ExtArgs>>): Prisma__FAQAnalysisJobClient<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FAQAnalysisJobs.
     * @param {FAQAnalysisJobCreateManyArgs} args - Arguments to create many FAQAnalysisJobs.
     * @example
     * // Create many FAQAnalysisJobs
     * const fAQAnalysisJob = await prisma.fAQAnalysisJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FAQAnalysisJobCreateManyArgs>(args?: SelectSubset<T, FAQAnalysisJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FAQAnalysisJobs and returns the data saved in the database.
     * @param {FAQAnalysisJobCreateManyAndReturnArgs} args - Arguments to create many FAQAnalysisJobs.
     * @example
     * // Create many FAQAnalysisJobs
     * const fAQAnalysisJob = await prisma.fAQAnalysisJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FAQAnalysisJobs and only return the `id`
     * const fAQAnalysisJobWithIdOnly = await prisma.fAQAnalysisJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FAQAnalysisJobCreateManyAndReturnArgs>(args?: SelectSubset<T, FAQAnalysisJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FAQAnalysisJob.
     * @param {FAQAnalysisJobDeleteArgs} args - Arguments to delete one FAQAnalysisJob.
     * @example
     * // Delete one FAQAnalysisJob
     * const FAQAnalysisJob = await prisma.fAQAnalysisJob.delete({
     *   where: {
     *     // ... filter to delete one FAQAnalysisJob
     *   }
     * })
     * 
     */
    delete<T extends FAQAnalysisJobDeleteArgs>(args: SelectSubset<T, FAQAnalysisJobDeleteArgs<ExtArgs>>): Prisma__FAQAnalysisJobClient<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FAQAnalysisJob.
     * @param {FAQAnalysisJobUpdateArgs} args - Arguments to update one FAQAnalysisJob.
     * @example
     * // Update one FAQAnalysisJob
     * const fAQAnalysisJob = await prisma.fAQAnalysisJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FAQAnalysisJobUpdateArgs>(args: SelectSubset<T, FAQAnalysisJobUpdateArgs<ExtArgs>>): Prisma__FAQAnalysisJobClient<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FAQAnalysisJobs.
     * @param {FAQAnalysisJobDeleteManyArgs} args - Arguments to filter FAQAnalysisJobs to delete.
     * @example
     * // Delete a few FAQAnalysisJobs
     * const { count } = await prisma.fAQAnalysisJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FAQAnalysisJobDeleteManyArgs>(args?: SelectSubset<T, FAQAnalysisJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQAnalysisJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQAnalysisJobs
     * const fAQAnalysisJob = await prisma.fAQAnalysisJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FAQAnalysisJobUpdateManyArgs>(args: SelectSubset<T, FAQAnalysisJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQAnalysisJobs and returns the data updated in the database.
     * @param {FAQAnalysisJobUpdateManyAndReturnArgs} args - Arguments to update many FAQAnalysisJobs.
     * @example
     * // Update many FAQAnalysisJobs
     * const fAQAnalysisJob = await prisma.fAQAnalysisJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FAQAnalysisJobs and only return the `id`
     * const fAQAnalysisJobWithIdOnly = await prisma.fAQAnalysisJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FAQAnalysisJobUpdateManyAndReturnArgs>(args: SelectSubset<T, FAQAnalysisJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FAQAnalysisJob.
     * @param {FAQAnalysisJobUpsertArgs} args - Arguments to update or create a FAQAnalysisJob.
     * @example
     * // Update or create a FAQAnalysisJob
     * const fAQAnalysisJob = await prisma.fAQAnalysisJob.upsert({
     *   create: {
     *     // ... data to create a FAQAnalysisJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQAnalysisJob we want to update
     *   }
     * })
     */
    upsert<T extends FAQAnalysisJobUpsertArgs>(args: SelectSubset<T, FAQAnalysisJobUpsertArgs<ExtArgs>>): Prisma__FAQAnalysisJobClient<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FAQAnalysisJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisJobCountArgs} args - Arguments to filter FAQAnalysisJobs to count.
     * @example
     * // Count the number of FAQAnalysisJobs
     * const count = await prisma.fAQAnalysisJob.count({
     *   where: {
     *     // ... the filter for the FAQAnalysisJobs we want to count
     *   }
     * })
    **/
    count<T extends FAQAnalysisJobCountArgs>(
      args?: Subset<T, FAQAnalysisJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQAnalysisJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQAnalysisJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQAnalysisJobAggregateArgs>(args: Subset<T, FAQAnalysisJobAggregateArgs>): Prisma.PrismaPromise<GetFAQAnalysisJobAggregateType<T>>

    /**
     * Group by FAQAnalysisJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQAnalysisJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQAnalysisJobGroupByArgs['orderBy'] }
        : { orderBy?: FAQAnalysisJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQAnalysisJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQAnalysisJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQAnalysisJob model
   */
  readonly fields: FAQAnalysisJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQAnalysisJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQAnalysisJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    results<T extends FAQAnalysisJob$resultsArgs<ExtArgs> = {}>(args?: Subset<T, FAQAnalysisJob$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FAQAnalysisJob model
   */
  interface FAQAnalysisJobFieldRefs {
    readonly id: FieldRef<"FAQAnalysisJob", 'String'>
    readonly status: FieldRef<"FAQAnalysisJob", 'String'>
    readonly tenantId: FieldRef<"FAQAnalysisJob", 'String'>
    readonly periodDays: FieldRef<"FAQAnalysisJob", 'Int'>
    readonly topN: FieldRef<"FAQAnalysisJob", 'Int'>
    readonly totalQuestions: FieldRef<"FAQAnalysisJob", 'Int'>
    readonly clusterCount: FieldRef<"FAQAnalysisJob", 'Int'>
    readonly llmMergeApplied: FieldRef<"FAQAnalysisJob", 'Boolean'>
    readonly startedAt: FieldRef<"FAQAnalysisJob", 'DateTime'>
    readonly completedAt: FieldRef<"FAQAnalysisJob", 'DateTime'>
    readonly errorMessage: FieldRef<"FAQAnalysisJob", 'String'>
    readonly createdAt: FieldRef<"FAQAnalysisJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FAQAnalysisJob findUnique
   */
  export type FAQAnalysisJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter, which FAQAnalysisJob to fetch.
     */
    where: FAQAnalysisJobWhereUniqueInput
  }

  /**
   * FAQAnalysisJob findUniqueOrThrow
   */
  export type FAQAnalysisJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter, which FAQAnalysisJob to fetch.
     */
    where: FAQAnalysisJobWhereUniqueInput
  }

  /**
   * FAQAnalysisJob findFirst
   */
  export type FAQAnalysisJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter, which FAQAnalysisJob to fetch.
     */
    where?: FAQAnalysisJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQAnalysisJobs to fetch.
     */
    orderBy?: FAQAnalysisJobOrderByWithRelationInput | FAQAnalysisJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQAnalysisJobs.
     */
    cursor?: FAQAnalysisJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQAnalysisJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQAnalysisJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQAnalysisJobs.
     */
    distinct?: FAQAnalysisJobScalarFieldEnum | FAQAnalysisJobScalarFieldEnum[]
  }

  /**
   * FAQAnalysisJob findFirstOrThrow
   */
  export type FAQAnalysisJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter, which FAQAnalysisJob to fetch.
     */
    where?: FAQAnalysisJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQAnalysisJobs to fetch.
     */
    orderBy?: FAQAnalysisJobOrderByWithRelationInput | FAQAnalysisJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQAnalysisJobs.
     */
    cursor?: FAQAnalysisJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQAnalysisJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQAnalysisJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQAnalysisJobs.
     */
    distinct?: FAQAnalysisJobScalarFieldEnum | FAQAnalysisJobScalarFieldEnum[]
  }

  /**
   * FAQAnalysisJob findMany
   */
  export type FAQAnalysisJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter, which FAQAnalysisJobs to fetch.
     */
    where?: FAQAnalysisJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQAnalysisJobs to fetch.
     */
    orderBy?: FAQAnalysisJobOrderByWithRelationInput | FAQAnalysisJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQAnalysisJobs.
     */
    cursor?: FAQAnalysisJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQAnalysisJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQAnalysisJobs.
     */
    skip?: number
    distinct?: FAQAnalysisJobScalarFieldEnum | FAQAnalysisJobScalarFieldEnum[]
  }

  /**
   * FAQAnalysisJob create
   */
  export type FAQAnalysisJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisJobInclude<ExtArgs> | null
    /**
     * The data needed to create a FAQAnalysisJob.
     */
    data?: XOR<FAQAnalysisJobCreateInput, FAQAnalysisJobUncheckedCreateInput>
  }

  /**
   * FAQAnalysisJob createMany
   */
  export type FAQAnalysisJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQAnalysisJobs.
     */
    data: FAQAnalysisJobCreateManyInput | FAQAnalysisJobCreateManyInput[]
  }

  /**
   * FAQAnalysisJob createManyAndReturn
   */
  export type FAQAnalysisJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * The data used to create many FAQAnalysisJobs.
     */
    data: FAQAnalysisJobCreateManyInput | FAQAnalysisJobCreateManyInput[]
  }

  /**
   * FAQAnalysisJob update
   */
  export type FAQAnalysisJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisJobInclude<ExtArgs> | null
    /**
     * The data needed to update a FAQAnalysisJob.
     */
    data: XOR<FAQAnalysisJobUpdateInput, FAQAnalysisJobUncheckedUpdateInput>
    /**
     * Choose, which FAQAnalysisJob to update.
     */
    where: FAQAnalysisJobWhereUniqueInput
  }

  /**
   * FAQAnalysisJob updateMany
   */
  export type FAQAnalysisJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQAnalysisJobs.
     */
    data: XOR<FAQAnalysisJobUpdateManyMutationInput, FAQAnalysisJobUncheckedUpdateManyInput>
    /**
     * Filter which FAQAnalysisJobs to update
     */
    where?: FAQAnalysisJobWhereInput
    /**
     * Limit how many FAQAnalysisJobs to update.
     */
    limit?: number
  }

  /**
   * FAQAnalysisJob updateManyAndReturn
   */
  export type FAQAnalysisJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * The data used to update FAQAnalysisJobs.
     */
    data: XOR<FAQAnalysisJobUpdateManyMutationInput, FAQAnalysisJobUncheckedUpdateManyInput>
    /**
     * Filter which FAQAnalysisJobs to update
     */
    where?: FAQAnalysisJobWhereInput
    /**
     * Limit how many FAQAnalysisJobs to update.
     */
    limit?: number
  }

  /**
   * FAQAnalysisJob upsert
   */
  export type FAQAnalysisJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisJobInclude<ExtArgs> | null
    /**
     * The filter to search for the FAQAnalysisJob to update in case it exists.
     */
    where: FAQAnalysisJobWhereUniqueInput
    /**
     * In case the FAQAnalysisJob found by the `where` argument doesn't exist, create a new FAQAnalysisJob with this data.
     */
    create: XOR<FAQAnalysisJobCreateInput, FAQAnalysisJobUncheckedCreateInput>
    /**
     * In case the FAQAnalysisJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQAnalysisJobUpdateInput, FAQAnalysisJobUncheckedUpdateInput>
  }

  /**
   * FAQAnalysisJob delete
   */
  export type FAQAnalysisJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisJobInclude<ExtArgs> | null
    /**
     * Filter which FAQAnalysisJob to delete.
     */
    where: FAQAnalysisJobWhereUniqueInput
  }

  /**
   * FAQAnalysisJob deleteMany
   */
  export type FAQAnalysisJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQAnalysisJobs to delete
     */
    where?: FAQAnalysisJobWhereInput
    /**
     * Limit how many FAQAnalysisJobs to delete.
     */
    limit?: number
  }

  /**
   * FAQAnalysisJob.results
   */
  export type FAQAnalysisJob$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultInclude<ExtArgs> | null
    where?: FAQAnalysisResultWhereInput
    orderBy?: FAQAnalysisResultOrderByWithRelationInput | FAQAnalysisResultOrderByWithRelationInput[]
    cursor?: FAQAnalysisResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FAQAnalysisResultScalarFieldEnum | FAQAnalysisResultScalarFieldEnum[]
  }

  /**
   * FAQAnalysisJob without action
   */
  export type FAQAnalysisJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisJob
     */
    select?: FAQAnalysisJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisJob
     */
    omit?: FAQAnalysisJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisJobInclude<ExtArgs> | null
  }


  /**
   * Model FAQAnalysisResult
   */

  export type AggregateFAQAnalysisResult = {
    _count: FAQAnalysisResultCountAggregateOutputType | null
    _avg: FAQAnalysisResultAvgAggregateOutputType | null
    _sum: FAQAnalysisResultSumAggregateOutputType | null
    _min: FAQAnalysisResultMinAggregateOutputType | null
    _max: FAQAnalysisResultMaxAggregateOutputType | null
  }

  export type FAQAnalysisResultAvgAggregateOutputType = {
    rank: number | null
    frequency: number | null
  }

  export type FAQAnalysisResultSumAggregateOutputType = {
    rank: number | null
    frequency: number | null
  }

  export type FAQAnalysisResultMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    rank: number | null
    representativeQuestion: string | null
    frequency: number | null
    reasonAnalysis: string | null
    isMerged: boolean | null
    questions: string | null
    createdAt: Date | null
  }

  export type FAQAnalysisResultMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    rank: number | null
    representativeQuestion: string | null
    frequency: number | null
    reasonAnalysis: string | null
    isMerged: boolean | null
    questions: string | null
    createdAt: Date | null
  }

  export type FAQAnalysisResultCountAggregateOutputType = {
    id: number
    jobId: number
    rank: number
    representativeQuestion: number
    frequency: number
    reasonAnalysis: number
    isMerged: number
    questions: number
    createdAt: number
    _all: number
  }


  export type FAQAnalysisResultAvgAggregateInputType = {
    rank?: true
    frequency?: true
  }

  export type FAQAnalysisResultSumAggregateInputType = {
    rank?: true
    frequency?: true
  }

  export type FAQAnalysisResultMinAggregateInputType = {
    id?: true
    jobId?: true
    rank?: true
    representativeQuestion?: true
    frequency?: true
    reasonAnalysis?: true
    isMerged?: true
    questions?: true
    createdAt?: true
  }

  export type FAQAnalysisResultMaxAggregateInputType = {
    id?: true
    jobId?: true
    rank?: true
    representativeQuestion?: true
    frequency?: true
    reasonAnalysis?: true
    isMerged?: true
    questions?: true
    createdAt?: true
  }

  export type FAQAnalysisResultCountAggregateInputType = {
    id?: true
    jobId?: true
    rank?: true
    representativeQuestion?: true
    frequency?: true
    reasonAnalysis?: true
    isMerged?: true
    questions?: true
    createdAt?: true
    _all?: true
  }

  export type FAQAnalysisResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQAnalysisResult to aggregate.
     */
    where?: FAQAnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQAnalysisResults to fetch.
     */
    orderBy?: FAQAnalysisResultOrderByWithRelationInput | FAQAnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQAnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQAnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQAnalysisResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQAnalysisResults
    **/
    _count?: true | FAQAnalysisResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FAQAnalysisResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FAQAnalysisResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQAnalysisResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQAnalysisResultMaxAggregateInputType
  }

  export type GetFAQAnalysisResultAggregateType<T extends FAQAnalysisResultAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQAnalysisResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQAnalysisResult[P]>
      : GetScalarType<T[P], AggregateFAQAnalysisResult[P]>
  }




  export type FAQAnalysisResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQAnalysisResultWhereInput
    orderBy?: FAQAnalysisResultOrderByWithAggregationInput | FAQAnalysisResultOrderByWithAggregationInput[]
    by: FAQAnalysisResultScalarFieldEnum[] | FAQAnalysisResultScalarFieldEnum
    having?: FAQAnalysisResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQAnalysisResultCountAggregateInputType | true
    _avg?: FAQAnalysisResultAvgAggregateInputType
    _sum?: FAQAnalysisResultSumAggregateInputType
    _min?: FAQAnalysisResultMinAggregateInputType
    _max?: FAQAnalysisResultMaxAggregateInputType
  }

  export type FAQAnalysisResultGroupByOutputType = {
    id: string
    jobId: string
    rank: number
    representativeQuestion: string
    frequency: number
    reasonAnalysis: string
    isMerged: boolean
    questions: string
    createdAt: Date
    _count: FAQAnalysisResultCountAggregateOutputType | null
    _avg: FAQAnalysisResultAvgAggregateOutputType | null
    _sum: FAQAnalysisResultSumAggregateOutputType | null
    _min: FAQAnalysisResultMinAggregateOutputType | null
    _max: FAQAnalysisResultMaxAggregateOutputType | null
  }

  type GetFAQAnalysisResultGroupByPayload<T extends FAQAnalysisResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQAnalysisResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQAnalysisResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQAnalysisResultGroupByOutputType[P]>
            : GetScalarType<T[P], FAQAnalysisResultGroupByOutputType[P]>
        }
      >
    >


  export type FAQAnalysisResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    rank?: boolean
    representativeQuestion?: boolean
    frequency?: boolean
    reasonAnalysis?: boolean
    isMerged?: boolean
    questions?: boolean
    createdAt?: boolean
    job?: boolean | FAQAnalysisJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fAQAnalysisResult"]>

  export type FAQAnalysisResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    rank?: boolean
    representativeQuestion?: boolean
    frequency?: boolean
    reasonAnalysis?: boolean
    isMerged?: boolean
    questions?: boolean
    createdAt?: boolean
    job?: boolean | FAQAnalysisJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fAQAnalysisResult"]>

  export type FAQAnalysisResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    rank?: boolean
    representativeQuestion?: boolean
    frequency?: boolean
    reasonAnalysis?: boolean
    isMerged?: boolean
    questions?: boolean
    createdAt?: boolean
    job?: boolean | FAQAnalysisJobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fAQAnalysisResult"]>

  export type FAQAnalysisResultSelectScalar = {
    id?: boolean
    jobId?: boolean
    rank?: boolean
    representativeQuestion?: boolean
    frequency?: boolean
    reasonAnalysis?: boolean
    isMerged?: boolean
    questions?: boolean
    createdAt?: boolean
  }

  export type FAQAnalysisResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobId" | "rank" | "representativeQuestion" | "frequency" | "reasonAnalysis" | "isMerged" | "questions" | "createdAt", ExtArgs["result"]["fAQAnalysisResult"]>
  export type FAQAnalysisResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | FAQAnalysisJobDefaultArgs<ExtArgs>
  }
  export type FAQAnalysisResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | FAQAnalysisJobDefaultArgs<ExtArgs>
  }
  export type FAQAnalysisResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | FAQAnalysisJobDefaultArgs<ExtArgs>
  }

  export type $FAQAnalysisResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQAnalysisResult"
    objects: {
      job: Prisma.$FAQAnalysisJobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      rank: number
      representativeQuestion: string
      frequency: number
      reasonAnalysis: string
      isMerged: boolean
      questions: string
      createdAt: Date
    }, ExtArgs["result"]["fAQAnalysisResult"]>
    composites: {}
  }

  type FAQAnalysisResultGetPayload<S extends boolean | null | undefined | FAQAnalysisResultDefaultArgs> = $Result.GetResult<Prisma.$FAQAnalysisResultPayload, S>

  type FAQAnalysisResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FAQAnalysisResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FAQAnalysisResultCountAggregateInputType | true
    }

  export interface FAQAnalysisResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQAnalysisResult'], meta: { name: 'FAQAnalysisResult' } }
    /**
     * Find zero or one FAQAnalysisResult that matches the filter.
     * @param {FAQAnalysisResultFindUniqueArgs} args - Arguments to find a FAQAnalysisResult
     * @example
     * // Get one FAQAnalysisResult
     * const fAQAnalysisResult = await prisma.fAQAnalysisResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FAQAnalysisResultFindUniqueArgs>(args: SelectSubset<T, FAQAnalysisResultFindUniqueArgs<ExtArgs>>): Prisma__FAQAnalysisResultClient<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FAQAnalysisResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FAQAnalysisResultFindUniqueOrThrowArgs} args - Arguments to find a FAQAnalysisResult
     * @example
     * // Get one FAQAnalysisResult
     * const fAQAnalysisResult = await prisma.fAQAnalysisResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FAQAnalysisResultFindUniqueOrThrowArgs>(args: SelectSubset<T, FAQAnalysisResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FAQAnalysisResultClient<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQAnalysisResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisResultFindFirstArgs} args - Arguments to find a FAQAnalysisResult
     * @example
     * // Get one FAQAnalysisResult
     * const fAQAnalysisResult = await prisma.fAQAnalysisResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FAQAnalysisResultFindFirstArgs>(args?: SelectSubset<T, FAQAnalysisResultFindFirstArgs<ExtArgs>>): Prisma__FAQAnalysisResultClient<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FAQAnalysisResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisResultFindFirstOrThrowArgs} args - Arguments to find a FAQAnalysisResult
     * @example
     * // Get one FAQAnalysisResult
     * const fAQAnalysisResult = await prisma.fAQAnalysisResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FAQAnalysisResultFindFirstOrThrowArgs>(args?: SelectSubset<T, FAQAnalysisResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__FAQAnalysisResultClient<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FAQAnalysisResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQAnalysisResults
     * const fAQAnalysisResults = await prisma.fAQAnalysisResult.findMany()
     * 
     * // Get first 10 FAQAnalysisResults
     * const fAQAnalysisResults = await prisma.fAQAnalysisResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fAQAnalysisResultWithIdOnly = await prisma.fAQAnalysisResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FAQAnalysisResultFindManyArgs>(args?: SelectSubset<T, FAQAnalysisResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FAQAnalysisResult.
     * @param {FAQAnalysisResultCreateArgs} args - Arguments to create a FAQAnalysisResult.
     * @example
     * // Create one FAQAnalysisResult
     * const FAQAnalysisResult = await prisma.fAQAnalysisResult.create({
     *   data: {
     *     // ... data to create a FAQAnalysisResult
     *   }
     * })
     * 
     */
    create<T extends FAQAnalysisResultCreateArgs>(args: SelectSubset<T, FAQAnalysisResultCreateArgs<ExtArgs>>): Prisma__FAQAnalysisResultClient<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FAQAnalysisResults.
     * @param {FAQAnalysisResultCreateManyArgs} args - Arguments to create many FAQAnalysisResults.
     * @example
     * // Create many FAQAnalysisResults
     * const fAQAnalysisResult = await prisma.fAQAnalysisResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FAQAnalysisResultCreateManyArgs>(args?: SelectSubset<T, FAQAnalysisResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FAQAnalysisResults and returns the data saved in the database.
     * @param {FAQAnalysisResultCreateManyAndReturnArgs} args - Arguments to create many FAQAnalysisResults.
     * @example
     * // Create many FAQAnalysisResults
     * const fAQAnalysisResult = await prisma.fAQAnalysisResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FAQAnalysisResults and only return the `id`
     * const fAQAnalysisResultWithIdOnly = await prisma.fAQAnalysisResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FAQAnalysisResultCreateManyAndReturnArgs>(args?: SelectSubset<T, FAQAnalysisResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FAQAnalysisResult.
     * @param {FAQAnalysisResultDeleteArgs} args - Arguments to delete one FAQAnalysisResult.
     * @example
     * // Delete one FAQAnalysisResult
     * const FAQAnalysisResult = await prisma.fAQAnalysisResult.delete({
     *   where: {
     *     // ... filter to delete one FAQAnalysisResult
     *   }
     * })
     * 
     */
    delete<T extends FAQAnalysisResultDeleteArgs>(args: SelectSubset<T, FAQAnalysisResultDeleteArgs<ExtArgs>>): Prisma__FAQAnalysisResultClient<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FAQAnalysisResult.
     * @param {FAQAnalysisResultUpdateArgs} args - Arguments to update one FAQAnalysisResult.
     * @example
     * // Update one FAQAnalysisResult
     * const fAQAnalysisResult = await prisma.fAQAnalysisResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FAQAnalysisResultUpdateArgs>(args: SelectSubset<T, FAQAnalysisResultUpdateArgs<ExtArgs>>): Prisma__FAQAnalysisResultClient<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FAQAnalysisResults.
     * @param {FAQAnalysisResultDeleteManyArgs} args - Arguments to filter FAQAnalysisResults to delete.
     * @example
     * // Delete a few FAQAnalysisResults
     * const { count } = await prisma.fAQAnalysisResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FAQAnalysisResultDeleteManyArgs>(args?: SelectSubset<T, FAQAnalysisResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQAnalysisResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQAnalysisResults
     * const fAQAnalysisResult = await prisma.fAQAnalysisResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FAQAnalysisResultUpdateManyArgs>(args: SelectSubset<T, FAQAnalysisResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQAnalysisResults and returns the data updated in the database.
     * @param {FAQAnalysisResultUpdateManyAndReturnArgs} args - Arguments to update many FAQAnalysisResults.
     * @example
     * // Update many FAQAnalysisResults
     * const fAQAnalysisResult = await prisma.fAQAnalysisResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FAQAnalysisResults and only return the `id`
     * const fAQAnalysisResultWithIdOnly = await prisma.fAQAnalysisResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FAQAnalysisResultUpdateManyAndReturnArgs>(args: SelectSubset<T, FAQAnalysisResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FAQAnalysisResult.
     * @param {FAQAnalysisResultUpsertArgs} args - Arguments to update or create a FAQAnalysisResult.
     * @example
     * // Update or create a FAQAnalysisResult
     * const fAQAnalysisResult = await prisma.fAQAnalysisResult.upsert({
     *   create: {
     *     // ... data to create a FAQAnalysisResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQAnalysisResult we want to update
     *   }
     * })
     */
    upsert<T extends FAQAnalysisResultUpsertArgs>(args: SelectSubset<T, FAQAnalysisResultUpsertArgs<ExtArgs>>): Prisma__FAQAnalysisResultClient<$Result.GetResult<Prisma.$FAQAnalysisResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FAQAnalysisResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisResultCountArgs} args - Arguments to filter FAQAnalysisResults to count.
     * @example
     * // Count the number of FAQAnalysisResults
     * const count = await prisma.fAQAnalysisResult.count({
     *   where: {
     *     // ... the filter for the FAQAnalysisResults we want to count
     *   }
     * })
    **/
    count<T extends FAQAnalysisResultCountArgs>(
      args?: Subset<T, FAQAnalysisResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQAnalysisResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQAnalysisResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQAnalysisResultAggregateArgs>(args: Subset<T, FAQAnalysisResultAggregateArgs>): Prisma.PrismaPromise<GetFAQAnalysisResultAggregateType<T>>

    /**
     * Group by FAQAnalysisResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAnalysisResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQAnalysisResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQAnalysisResultGroupByArgs['orderBy'] }
        : { orderBy?: FAQAnalysisResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQAnalysisResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQAnalysisResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQAnalysisResult model
   */
  readonly fields: FAQAnalysisResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQAnalysisResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQAnalysisResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends FAQAnalysisJobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FAQAnalysisJobDefaultArgs<ExtArgs>>): Prisma__FAQAnalysisJobClient<$Result.GetResult<Prisma.$FAQAnalysisJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FAQAnalysisResult model
   */
  interface FAQAnalysisResultFieldRefs {
    readonly id: FieldRef<"FAQAnalysisResult", 'String'>
    readonly jobId: FieldRef<"FAQAnalysisResult", 'String'>
    readonly rank: FieldRef<"FAQAnalysisResult", 'Int'>
    readonly representativeQuestion: FieldRef<"FAQAnalysisResult", 'String'>
    readonly frequency: FieldRef<"FAQAnalysisResult", 'Int'>
    readonly reasonAnalysis: FieldRef<"FAQAnalysisResult", 'String'>
    readonly isMerged: FieldRef<"FAQAnalysisResult", 'Boolean'>
    readonly questions: FieldRef<"FAQAnalysisResult", 'String'>
    readonly createdAt: FieldRef<"FAQAnalysisResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FAQAnalysisResult findUnique
   */
  export type FAQAnalysisResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which FAQAnalysisResult to fetch.
     */
    where: FAQAnalysisResultWhereUniqueInput
  }

  /**
   * FAQAnalysisResult findUniqueOrThrow
   */
  export type FAQAnalysisResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which FAQAnalysisResult to fetch.
     */
    where: FAQAnalysisResultWhereUniqueInput
  }

  /**
   * FAQAnalysisResult findFirst
   */
  export type FAQAnalysisResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which FAQAnalysisResult to fetch.
     */
    where?: FAQAnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQAnalysisResults to fetch.
     */
    orderBy?: FAQAnalysisResultOrderByWithRelationInput | FAQAnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQAnalysisResults.
     */
    cursor?: FAQAnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQAnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQAnalysisResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQAnalysisResults.
     */
    distinct?: FAQAnalysisResultScalarFieldEnum | FAQAnalysisResultScalarFieldEnum[]
  }

  /**
   * FAQAnalysisResult findFirstOrThrow
   */
  export type FAQAnalysisResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which FAQAnalysisResult to fetch.
     */
    where?: FAQAnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQAnalysisResults to fetch.
     */
    orderBy?: FAQAnalysisResultOrderByWithRelationInput | FAQAnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQAnalysisResults.
     */
    cursor?: FAQAnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQAnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQAnalysisResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQAnalysisResults.
     */
    distinct?: FAQAnalysisResultScalarFieldEnum | FAQAnalysisResultScalarFieldEnum[]
  }

  /**
   * FAQAnalysisResult findMany
   */
  export type FAQAnalysisResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which FAQAnalysisResults to fetch.
     */
    where?: FAQAnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQAnalysisResults to fetch.
     */
    orderBy?: FAQAnalysisResultOrderByWithRelationInput | FAQAnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQAnalysisResults.
     */
    cursor?: FAQAnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQAnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQAnalysisResults.
     */
    skip?: number
    distinct?: FAQAnalysisResultScalarFieldEnum | FAQAnalysisResultScalarFieldEnum[]
  }

  /**
   * FAQAnalysisResult create
   */
  export type FAQAnalysisResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultInclude<ExtArgs> | null
    /**
     * The data needed to create a FAQAnalysisResult.
     */
    data: XOR<FAQAnalysisResultCreateInput, FAQAnalysisResultUncheckedCreateInput>
  }

  /**
   * FAQAnalysisResult createMany
   */
  export type FAQAnalysisResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQAnalysisResults.
     */
    data: FAQAnalysisResultCreateManyInput | FAQAnalysisResultCreateManyInput[]
  }

  /**
   * FAQAnalysisResult createManyAndReturn
   */
  export type FAQAnalysisResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * The data used to create many FAQAnalysisResults.
     */
    data: FAQAnalysisResultCreateManyInput | FAQAnalysisResultCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FAQAnalysisResult update
   */
  export type FAQAnalysisResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultInclude<ExtArgs> | null
    /**
     * The data needed to update a FAQAnalysisResult.
     */
    data: XOR<FAQAnalysisResultUpdateInput, FAQAnalysisResultUncheckedUpdateInput>
    /**
     * Choose, which FAQAnalysisResult to update.
     */
    where: FAQAnalysisResultWhereUniqueInput
  }

  /**
   * FAQAnalysisResult updateMany
   */
  export type FAQAnalysisResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQAnalysisResults.
     */
    data: XOR<FAQAnalysisResultUpdateManyMutationInput, FAQAnalysisResultUncheckedUpdateManyInput>
    /**
     * Filter which FAQAnalysisResults to update
     */
    where?: FAQAnalysisResultWhereInput
    /**
     * Limit how many FAQAnalysisResults to update.
     */
    limit?: number
  }

  /**
   * FAQAnalysisResult updateManyAndReturn
   */
  export type FAQAnalysisResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * The data used to update FAQAnalysisResults.
     */
    data: XOR<FAQAnalysisResultUpdateManyMutationInput, FAQAnalysisResultUncheckedUpdateManyInput>
    /**
     * Filter which FAQAnalysisResults to update
     */
    where?: FAQAnalysisResultWhereInput
    /**
     * Limit how many FAQAnalysisResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FAQAnalysisResult upsert
   */
  export type FAQAnalysisResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultInclude<ExtArgs> | null
    /**
     * The filter to search for the FAQAnalysisResult to update in case it exists.
     */
    where: FAQAnalysisResultWhereUniqueInput
    /**
     * In case the FAQAnalysisResult found by the `where` argument doesn't exist, create a new FAQAnalysisResult with this data.
     */
    create: XOR<FAQAnalysisResultCreateInput, FAQAnalysisResultUncheckedCreateInput>
    /**
     * In case the FAQAnalysisResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQAnalysisResultUpdateInput, FAQAnalysisResultUncheckedUpdateInput>
  }

  /**
   * FAQAnalysisResult delete
   */
  export type FAQAnalysisResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultInclude<ExtArgs> | null
    /**
     * Filter which FAQAnalysisResult to delete.
     */
    where: FAQAnalysisResultWhereUniqueInput
  }

  /**
   * FAQAnalysisResult deleteMany
   */
  export type FAQAnalysisResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQAnalysisResults to delete
     */
    where?: FAQAnalysisResultWhereInput
    /**
     * Limit how many FAQAnalysisResults to delete.
     */
    limit?: number
  }

  /**
   * FAQAnalysisResult without action
   */
  export type FAQAnalysisResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQAnalysisResult
     */
    select?: FAQAnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FAQAnalysisResult
     */
    omit?: FAQAnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQAnalysisResultInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    frustrationRate: number | null
    aggressiveCount: number | null
    totalMessages: number | null
    analyzedMessages: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    frustrationRate: number | null
    aggressiveCount: number | null
    totalMessages: number | null
    analyzedMessages: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    frustrationRate: number | null
    aggressiveCount: number | null
    categoryDistribution: string | null
    behaviorSummary: string | null
    mainInterests: string | null
    painPoints: string | null
    totalMessages: number | null
    analyzedMessages: number | null
    lastAnalyzedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    frustrationRate: number | null
    aggressiveCount: number | null
    categoryDistribution: string | null
    behaviorSummary: string | null
    mainInterests: string | null
    painPoints: string | null
    totalMessages: number | null
    analyzedMessages: number | null
    lastAnalyzedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    tenantId: number
    frustrationRate: number
    aggressiveCount: number
    categoryDistribution: number
    behaviorSummary: number
    mainInterests: number
    painPoints: number
    totalMessages: number
    analyzedMessages: number
    lastAnalyzedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    frustrationRate?: true
    aggressiveCount?: true
    totalMessages?: true
    analyzedMessages?: true
  }

  export type UserProfileSumAggregateInputType = {
    frustrationRate?: true
    aggressiveCount?: true
    totalMessages?: true
    analyzedMessages?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    frustrationRate?: true
    aggressiveCount?: true
    categoryDistribution?: true
    behaviorSummary?: true
    mainInterests?: true
    painPoints?: true
    totalMessages?: true
    analyzedMessages?: true
    lastAnalyzedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    frustrationRate?: true
    aggressiveCount?: true
    categoryDistribution?: true
    behaviorSummary?: true
    mainInterests?: true
    painPoints?: true
    totalMessages?: true
    analyzedMessages?: true
    lastAnalyzedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    frustrationRate?: true
    aggressiveCount?: true
    categoryDistribution?: true
    behaviorSummary?: true
    mainInterests?: true
    painPoints?: true
    totalMessages?: true
    analyzedMessages?: true
    lastAnalyzedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    userId: string
    tenantId: string
    frustrationRate: number
    aggressiveCount: number
    categoryDistribution: string
    behaviorSummary: string | null
    mainInterests: string | null
    painPoints: string | null
    totalMessages: number
    analyzedMessages: number
    lastAnalyzedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    frustrationRate?: boolean
    aggressiveCount?: boolean
    categoryDistribution?: boolean
    behaviorSummary?: boolean
    mainInterests?: boolean
    painPoints?: boolean
    totalMessages?: boolean
    analyzedMessages?: boolean
    lastAnalyzedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    frustrationRate?: boolean
    aggressiveCount?: boolean
    categoryDistribution?: boolean
    behaviorSummary?: boolean
    mainInterests?: boolean
    painPoints?: boolean
    totalMessages?: boolean
    analyzedMessages?: boolean
    lastAnalyzedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    frustrationRate?: boolean
    aggressiveCount?: boolean
    categoryDistribution?: boolean
    behaviorSummary?: boolean
    mainInterests?: boolean
    painPoints?: boolean
    totalMessages?: boolean
    analyzedMessages?: boolean
    lastAnalyzedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    frustrationRate?: boolean
    aggressiveCount?: boolean
    categoryDistribution?: boolean
    behaviorSummary?: boolean
    mainInterests?: boolean
    painPoints?: boolean
    totalMessages?: boolean
    analyzedMessages?: boolean
    lastAnalyzedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tenantId" | "frustrationRate" | "aggressiveCount" | "categoryDistribution" | "behaviorSummary" | "mainInterests" | "painPoints" | "totalMessages" | "analyzedMessages" | "lastAnalyzedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userProfile"]>

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tenantId: string
      frustrationRate: number
      aggressiveCount: number
      categoryDistribution: string
      behaviorSummary: string | null
      mainInterests: string | null
      painPoints: string | null
      totalMessages: number
      analyzedMessages: number
      lastAnalyzedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly tenantId: FieldRef<"UserProfile", 'String'>
    readonly frustrationRate: FieldRef<"UserProfile", 'Float'>
    readonly aggressiveCount: FieldRef<"UserProfile", 'Int'>
    readonly categoryDistribution: FieldRef<"UserProfile", 'String'>
    readonly behaviorSummary: FieldRef<"UserProfile", 'String'>
    readonly mainInterests: FieldRef<"UserProfile", 'String'>
    readonly painPoints: FieldRef<"UserProfile", 'String'>
    readonly totalMessages: FieldRef<"UserProfile", 'Int'>
    readonly analyzedMessages: FieldRef<"UserProfile", 'Int'>
    readonly lastAnalyzedAt: FieldRef<"UserProfile", 'DateTime'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
  }


  /**
   * Model MessageCategoryAnalysis
   */

  export type AggregateMessageCategoryAnalysis = {
    _count: MessageCategoryAnalysisCountAggregateOutputType | null
    _avg: MessageCategoryAnalysisAvgAggregateOutputType | null
    _sum: MessageCategoryAnalysisSumAggregateOutputType | null
    _min: MessageCategoryAnalysisMinAggregateOutputType | null
    _max: MessageCategoryAnalysisMaxAggregateOutputType | null
  }

  export type MessageCategoryAnalysisAvgAggregateOutputType = {
    confidence: number | null
  }

  export type MessageCategoryAnalysisSumAggregateOutputType = {
    confidence: number | null
  }

  export type MessageCategoryAnalysisMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    messageHash: string | null
    category: string | null
    confidence: number | null
    sentiment: string | null
    isAggressive: boolean | null
    userInput: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type MessageCategoryAnalysisMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    messageHash: string | null
    category: string | null
    confidence: number | null
    sentiment: string | null
    isAggressive: boolean | null
    userInput: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type MessageCategoryAnalysisCountAggregateOutputType = {
    id: number
    userId: number
    tenantId: number
    messageHash: number
    category: number
    confidence: number
    sentiment: number
    isAggressive: number
    userInput: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type MessageCategoryAnalysisAvgAggregateInputType = {
    confidence?: true
  }

  export type MessageCategoryAnalysisSumAggregateInputType = {
    confidence?: true
  }

  export type MessageCategoryAnalysisMinAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    messageHash?: true
    category?: true
    confidence?: true
    sentiment?: true
    isAggressive?: true
    userInput?: true
    timestamp?: true
    createdAt?: true
  }

  export type MessageCategoryAnalysisMaxAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    messageHash?: true
    category?: true
    confidence?: true
    sentiment?: true
    isAggressive?: true
    userInput?: true
    timestamp?: true
    createdAt?: true
  }

  export type MessageCategoryAnalysisCountAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    messageHash?: true
    category?: true
    confidence?: true
    sentiment?: true
    isAggressive?: true
    userInput?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type MessageCategoryAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageCategoryAnalysis to aggregate.
     */
    where?: MessageCategoryAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageCategoryAnalyses to fetch.
     */
    orderBy?: MessageCategoryAnalysisOrderByWithRelationInput | MessageCategoryAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageCategoryAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageCategoryAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageCategoryAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageCategoryAnalyses
    **/
    _count?: true | MessageCategoryAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageCategoryAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageCategoryAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageCategoryAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageCategoryAnalysisMaxAggregateInputType
  }

  export type GetMessageCategoryAnalysisAggregateType<T extends MessageCategoryAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageCategoryAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageCategoryAnalysis[P]>
      : GetScalarType<T[P], AggregateMessageCategoryAnalysis[P]>
  }




  export type MessageCategoryAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageCategoryAnalysisWhereInput
    orderBy?: MessageCategoryAnalysisOrderByWithAggregationInput | MessageCategoryAnalysisOrderByWithAggregationInput[]
    by: MessageCategoryAnalysisScalarFieldEnum[] | MessageCategoryAnalysisScalarFieldEnum
    having?: MessageCategoryAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCategoryAnalysisCountAggregateInputType | true
    _avg?: MessageCategoryAnalysisAvgAggregateInputType
    _sum?: MessageCategoryAnalysisSumAggregateInputType
    _min?: MessageCategoryAnalysisMinAggregateInputType
    _max?: MessageCategoryAnalysisMaxAggregateInputType
  }

  export type MessageCategoryAnalysisGroupByOutputType = {
    id: string
    userId: string
    tenantId: string
    messageHash: string
    category: string
    confidence: number
    sentiment: string
    isAggressive: boolean
    userInput: string
    timestamp: Date
    createdAt: Date
    _count: MessageCategoryAnalysisCountAggregateOutputType | null
    _avg: MessageCategoryAnalysisAvgAggregateOutputType | null
    _sum: MessageCategoryAnalysisSumAggregateOutputType | null
    _min: MessageCategoryAnalysisMinAggregateOutputType | null
    _max: MessageCategoryAnalysisMaxAggregateOutputType | null
  }

  type GetMessageCategoryAnalysisGroupByPayload<T extends MessageCategoryAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageCategoryAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageCategoryAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageCategoryAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], MessageCategoryAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type MessageCategoryAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    messageHash?: boolean
    category?: boolean
    confidence?: boolean
    sentiment?: boolean
    isAggressive?: boolean
    userInput?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["messageCategoryAnalysis"]>

  export type MessageCategoryAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    messageHash?: boolean
    category?: boolean
    confidence?: boolean
    sentiment?: boolean
    isAggressive?: boolean
    userInput?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["messageCategoryAnalysis"]>

  export type MessageCategoryAnalysisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    messageHash?: boolean
    category?: boolean
    confidence?: boolean
    sentiment?: boolean
    isAggressive?: boolean
    userInput?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["messageCategoryAnalysis"]>

  export type MessageCategoryAnalysisSelectScalar = {
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    messageHash?: boolean
    category?: boolean
    confidence?: boolean
    sentiment?: boolean
    isAggressive?: boolean
    userInput?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type MessageCategoryAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tenantId" | "messageHash" | "category" | "confidence" | "sentiment" | "isAggressive" | "userInput" | "timestamp" | "createdAt", ExtArgs["result"]["messageCategoryAnalysis"]>

  export type $MessageCategoryAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageCategoryAnalysis"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tenantId: string
      messageHash: string
      category: string
      confidence: number
      sentiment: string
      isAggressive: boolean
      userInput: string
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["messageCategoryAnalysis"]>
    composites: {}
  }

  type MessageCategoryAnalysisGetPayload<S extends boolean | null | undefined | MessageCategoryAnalysisDefaultArgs> = $Result.GetResult<Prisma.$MessageCategoryAnalysisPayload, S>

  type MessageCategoryAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageCategoryAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCategoryAnalysisCountAggregateInputType | true
    }

  export interface MessageCategoryAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageCategoryAnalysis'], meta: { name: 'MessageCategoryAnalysis' } }
    /**
     * Find zero or one MessageCategoryAnalysis that matches the filter.
     * @param {MessageCategoryAnalysisFindUniqueArgs} args - Arguments to find a MessageCategoryAnalysis
     * @example
     * // Get one MessageCategoryAnalysis
     * const messageCategoryAnalysis = await prisma.messageCategoryAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageCategoryAnalysisFindUniqueArgs>(args: SelectSubset<T, MessageCategoryAnalysisFindUniqueArgs<ExtArgs>>): Prisma__MessageCategoryAnalysisClient<$Result.GetResult<Prisma.$MessageCategoryAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageCategoryAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageCategoryAnalysisFindUniqueOrThrowArgs} args - Arguments to find a MessageCategoryAnalysis
     * @example
     * // Get one MessageCategoryAnalysis
     * const messageCategoryAnalysis = await prisma.messageCategoryAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageCategoryAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageCategoryAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageCategoryAnalysisClient<$Result.GetResult<Prisma.$MessageCategoryAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageCategoryAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryAnalysisFindFirstArgs} args - Arguments to find a MessageCategoryAnalysis
     * @example
     * // Get one MessageCategoryAnalysis
     * const messageCategoryAnalysis = await prisma.messageCategoryAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageCategoryAnalysisFindFirstArgs>(args?: SelectSubset<T, MessageCategoryAnalysisFindFirstArgs<ExtArgs>>): Prisma__MessageCategoryAnalysisClient<$Result.GetResult<Prisma.$MessageCategoryAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageCategoryAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryAnalysisFindFirstOrThrowArgs} args - Arguments to find a MessageCategoryAnalysis
     * @example
     * // Get one MessageCategoryAnalysis
     * const messageCategoryAnalysis = await prisma.messageCategoryAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageCategoryAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageCategoryAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageCategoryAnalysisClient<$Result.GetResult<Prisma.$MessageCategoryAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageCategoryAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageCategoryAnalyses
     * const messageCategoryAnalyses = await prisma.messageCategoryAnalysis.findMany()
     * 
     * // Get first 10 MessageCategoryAnalyses
     * const messageCategoryAnalyses = await prisma.messageCategoryAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageCategoryAnalysisWithIdOnly = await prisma.messageCategoryAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageCategoryAnalysisFindManyArgs>(args?: SelectSubset<T, MessageCategoryAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageCategoryAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageCategoryAnalysis.
     * @param {MessageCategoryAnalysisCreateArgs} args - Arguments to create a MessageCategoryAnalysis.
     * @example
     * // Create one MessageCategoryAnalysis
     * const MessageCategoryAnalysis = await prisma.messageCategoryAnalysis.create({
     *   data: {
     *     // ... data to create a MessageCategoryAnalysis
     *   }
     * })
     * 
     */
    create<T extends MessageCategoryAnalysisCreateArgs>(args: SelectSubset<T, MessageCategoryAnalysisCreateArgs<ExtArgs>>): Prisma__MessageCategoryAnalysisClient<$Result.GetResult<Prisma.$MessageCategoryAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageCategoryAnalyses.
     * @param {MessageCategoryAnalysisCreateManyArgs} args - Arguments to create many MessageCategoryAnalyses.
     * @example
     * // Create many MessageCategoryAnalyses
     * const messageCategoryAnalysis = await prisma.messageCategoryAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCategoryAnalysisCreateManyArgs>(args?: SelectSubset<T, MessageCategoryAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageCategoryAnalyses and returns the data saved in the database.
     * @param {MessageCategoryAnalysisCreateManyAndReturnArgs} args - Arguments to create many MessageCategoryAnalyses.
     * @example
     * // Create many MessageCategoryAnalyses
     * const messageCategoryAnalysis = await prisma.messageCategoryAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageCategoryAnalyses and only return the `id`
     * const messageCategoryAnalysisWithIdOnly = await prisma.messageCategoryAnalysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCategoryAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCategoryAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageCategoryAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageCategoryAnalysis.
     * @param {MessageCategoryAnalysisDeleteArgs} args - Arguments to delete one MessageCategoryAnalysis.
     * @example
     * // Delete one MessageCategoryAnalysis
     * const MessageCategoryAnalysis = await prisma.messageCategoryAnalysis.delete({
     *   where: {
     *     // ... filter to delete one MessageCategoryAnalysis
     *   }
     * })
     * 
     */
    delete<T extends MessageCategoryAnalysisDeleteArgs>(args: SelectSubset<T, MessageCategoryAnalysisDeleteArgs<ExtArgs>>): Prisma__MessageCategoryAnalysisClient<$Result.GetResult<Prisma.$MessageCategoryAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageCategoryAnalysis.
     * @param {MessageCategoryAnalysisUpdateArgs} args - Arguments to update one MessageCategoryAnalysis.
     * @example
     * // Update one MessageCategoryAnalysis
     * const messageCategoryAnalysis = await prisma.messageCategoryAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageCategoryAnalysisUpdateArgs>(args: SelectSubset<T, MessageCategoryAnalysisUpdateArgs<ExtArgs>>): Prisma__MessageCategoryAnalysisClient<$Result.GetResult<Prisma.$MessageCategoryAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageCategoryAnalyses.
     * @param {MessageCategoryAnalysisDeleteManyArgs} args - Arguments to filter MessageCategoryAnalyses to delete.
     * @example
     * // Delete a few MessageCategoryAnalyses
     * const { count } = await prisma.messageCategoryAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageCategoryAnalysisDeleteManyArgs>(args?: SelectSubset<T, MessageCategoryAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageCategoryAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageCategoryAnalyses
     * const messageCategoryAnalysis = await prisma.messageCategoryAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageCategoryAnalysisUpdateManyArgs>(args: SelectSubset<T, MessageCategoryAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageCategoryAnalyses and returns the data updated in the database.
     * @param {MessageCategoryAnalysisUpdateManyAndReturnArgs} args - Arguments to update many MessageCategoryAnalyses.
     * @example
     * // Update many MessageCategoryAnalyses
     * const messageCategoryAnalysis = await prisma.messageCategoryAnalysis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageCategoryAnalyses and only return the `id`
     * const messageCategoryAnalysisWithIdOnly = await prisma.messageCategoryAnalysis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageCategoryAnalysisUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageCategoryAnalysisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageCategoryAnalysisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageCategoryAnalysis.
     * @param {MessageCategoryAnalysisUpsertArgs} args - Arguments to update or create a MessageCategoryAnalysis.
     * @example
     * // Update or create a MessageCategoryAnalysis
     * const messageCategoryAnalysis = await prisma.messageCategoryAnalysis.upsert({
     *   create: {
     *     // ... data to create a MessageCategoryAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageCategoryAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends MessageCategoryAnalysisUpsertArgs>(args: SelectSubset<T, MessageCategoryAnalysisUpsertArgs<ExtArgs>>): Prisma__MessageCategoryAnalysisClient<$Result.GetResult<Prisma.$MessageCategoryAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageCategoryAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryAnalysisCountArgs} args - Arguments to filter MessageCategoryAnalyses to count.
     * @example
     * // Count the number of MessageCategoryAnalyses
     * const count = await prisma.messageCategoryAnalysis.count({
     *   where: {
     *     // ... the filter for the MessageCategoryAnalyses we want to count
     *   }
     * })
    **/
    count<T extends MessageCategoryAnalysisCountArgs>(
      args?: Subset<T, MessageCategoryAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCategoryAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageCategoryAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageCategoryAnalysisAggregateArgs>(args: Subset<T, MessageCategoryAnalysisAggregateArgs>): Prisma.PrismaPromise<GetMessageCategoryAnalysisAggregateType<T>>

    /**
     * Group by MessageCategoryAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCategoryAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageCategoryAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageCategoryAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: MessageCategoryAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageCategoryAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageCategoryAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageCategoryAnalysis model
   */
  readonly fields: MessageCategoryAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageCategoryAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageCategoryAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageCategoryAnalysis model
   */
  interface MessageCategoryAnalysisFieldRefs {
    readonly id: FieldRef<"MessageCategoryAnalysis", 'String'>
    readonly userId: FieldRef<"MessageCategoryAnalysis", 'String'>
    readonly tenantId: FieldRef<"MessageCategoryAnalysis", 'String'>
    readonly messageHash: FieldRef<"MessageCategoryAnalysis", 'String'>
    readonly category: FieldRef<"MessageCategoryAnalysis", 'String'>
    readonly confidence: FieldRef<"MessageCategoryAnalysis", 'Float'>
    readonly sentiment: FieldRef<"MessageCategoryAnalysis", 'String'>
    readonly isAggressive: FieldRef<"MessageCategoryAnalysis", 'Boolean'>
    readonly userInput: FieldRef<"MessageCategoryAnalysis", 'String'>
    readonly timestamp: FieldRef<"MessageCategoryAnalysis", 'DateTime'>
    readonly createdAt: FieldRef<"MessageCategoryAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageCategoryAnalysis findUnique
   */
  export type MessageCategoryAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which MessageCategoryAnalysis to fetch.
     */
    where: MessageCategoryAnalysisWhereUniqueInput
  }

  /**
   * MessageCategoryAnalysis findUniqueOrThrow
   */
  export type MessageCategoryAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which MessageCategoryAnalysis to fetch.
     */
    where: MessageCategoryAnalysisWhereUniqueInput
  }

  /**
   * MessageCategoryAnalysis findFirst
   */
  export type MessageCategoryAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which MessageCategoryAnalysis to fetch.
     */
    where?: MessageCategoryAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageCategoryAnalyses to fetch.
     */
    orderBy?: MessageCategoryAnalysisOrderByWithRelationInput | MessageCategoryAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageCategoryAnalyses.
     */
    cursor?: MessageCategoryAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageCategoryAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageCategoryAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageCategoryAnalyses.
     */
    distinct?: MessageCategoryAnalysisScalarFieldEnum | MessageCategoryAnalysisScalarFieldEnum[]
  }

  /**
   * MessageCategoryAnalysis findFirstOrThrow
   */
  export type MessageCategoryAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which MessageCategoryAnalysis to fetch.
     */
    where?: MessageCategoryAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageCategoryAnalyses to fetch.
     */
    orderBy?: MessageCategoryAnalysisOrderByWithRelationInput | MessageCategoryAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageCategoryAnalyses.
     */
    cursor?: MessageCategoryAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageCategoryAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageCategoryAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageCategoryAnalyses.
     */
    distinct?: MessageCategoryAnalysisScalarFieldEnum | MessageCategoryAnalysisScalarFieldEnum[]
  }

  /**
   * MessageCategoryAnalysis findMany
   */
  export type MessageCategoryAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which MessageCategoryAnalyses to fetch.
     */
    where?: MessageCategoryAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageCategoryAnalyses to fetch.
     */
    orderBy?: MessageCategoryAnalysisOrderByWithRelationInput | MessageCategoryAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageCategoryAnalyses.
     */
    cursor?: MessageCategoryAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageCategoryAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageCategoryAnalyses.
     */
    skip?: number
    distinct?: MessageCategoryAnalysisScalarFieldEnum | MessageCategoryAnalysisScalarFieldEnum[]
  }

  /**
   * MessageCategoryAnalysis create
   */
  export type MessageCategoryAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
    /**
     * The data needed to create a MessageCategoryAnalysis.
     */
    data: XOR<MessageCategoryAnalysisCreateInput, MessageCategoryAnalysisUncheckedCreateInput>
  }

  /**
   * MessageCategoryAnalysis createMany
   */
  export type MessageCategoryAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageCategoryAnalyses.
     */
    data: MessageCategoryAnalysisCreateManyInput | MessageCategoryAnalysisCreateManyInput[]
  }

  /**
   * MessageCategoryAnalysis createManyAndReturn
   */
  export type MessageCategoryAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many MessageCategoryAnalyses.
     */
    data: MessageCategoryAnalysisCreateManyInput | MessageCategoryAnalysisCreateManyInput[]
  }

  /**
   * MessageCategoryAnalysis update
   */
  export type MessageCategoryAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
    /**
     * The data needed to update a MessageCategoryAnalysis.
     */
    data: XOR<MessageCategoryAnalysisUpdateInput, MessageCategoryAnalysisUncheckedUpdateInput>
    /**
     * Choose, which MessageCategoryAnalysis to update.
     */
    where: MessageCategoryAnalysisWhereUniqueInput
  }

  /**
   * MessageCategoryAnalysis updateMany
   */
  export type MessageCategoryAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageCategoryAnalyses.
     */
    data: XOR<MessageCategoryAnalysisUpdateManyMutationInput, MessageCategoryAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which MessageCategoryAnalyses to update
     */
    where?: MessageCategoryAnalysisWhereInput
    /**
     * Limit how many MessageCategoryAnalyses to update.
     */
    limit?: number
  }

  /**
   * MessageCategoryAnalysis updateManyAndReturn
   */
  export type MessageCategoryAnalysisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
    /**
     * The data used to update MessageCategoryAnalyses.
     */
    data: XOR<MessageCategoryAnalysisUpdateManyMutationInput, MessageCategoryAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which MessageCategoryAnalyses to update
     */
    where?: MessageCategoryAnalysisWhereInput
    /**
     * Limit how many MessageCategoryAnalyses to update.
     */
    limit?: number
  }

  /**
   * MessageCategoryAnalysis upsert
   */
  export type MessageCategoryAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
    /**
     * The filter to search for the MessageCategoryAnalysis to update in case it exists.
     */
    where: MessageCategoryAnalysisWhereUniqueInput
    /**
     * In case the MessageCategoryAnalysis found by the `where` argument doesn't exist, create a new MessageCategoryAnalysis with this data.
     */
    create: XOR<MessageCategoryAnalysisCreateInput, MessageCategoryAnalysisUncheckedCreateInput>
    /**
     * In case the MessageCategoryAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageCategoryAnalysisUpdateInput, MessageCategoryAnalysisUncheckedUpdateInput>
  }

  /**
   * MessageCategoryAnalysis delete
   */
  export type MessageCategoryAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
    /**
     * Filter which MessageCategoryAnalysis to delete.
     */
    where: MessageCategoryAnalysisWhereUniqueInput
  }

  /**
   * MessageCategoryAnalysis deleteMany
   */
  export type MessageCategoryAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageCategoryAnalyses to delete
     */
    where?: MessageCategoryAnalysisWhereInput
    /**
     * Limit how many MessageCategoryAnalyses to delete.
     */
    limit?: number
  }

  /**
   * MessageCategoryAnalysis without action
   */
  export type MessageCategoryAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCategoryAnalysis
     */
    select?: MessageCategoryAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageCategoryAnalysis
     */
    omit?: MessageCategoryAnalysisOmit<ExtArgs> | null
  }


  /**
   * Model UserProfilingJob
   */

  export type AggregateUserProfilingJob = {
    _count: UserProfilingJobCountAggregateOutputType | null
    _avg: UserProfilingJobAvgAggregateOutputType | null
    _sum: UserProfilingJobSumAggregateOutputType | null
    _min: UserProfilingJobMinAggregateOutputType | null
    _max: UserProfilingJobMaxAggregateOutputType | null
  }

  export type UserProfilingJobAvgAggregateOutputType = {
    totalUsers: number | null
    processedUsers: number | null
    failedUsers: number | null
  }

  export type UserProfilingJobSumAggregateOutputType = {
    totalUsers: number | null
    processedUsers: number | null
    failedUsers: number | null
  }

  export type UserProfilingJobMinAggregateOutputType = {
    id: string | null
    status: string | null
    targetDate: Date | null
    tenantId: string | null
    totalUsers: number | null
    processedUsers: number | null
    failedUsers: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type UserProfilingJobMaxAggregateOutputType = {
    id: string | null
    status: string | null
    targetDate: Date | null
    tenantId: string | null
    totalUsers: number | null
    processedUsers: number | null
    failedUsers: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type UserProfilingJobCountAggregateOutputType = {
    id: number
    status: number
    targetDate: number
    tenantId: number
    totalUsers: number
    processedUsers: number
    failedUsers: number
    startedAt: number
    completedAt: number
    errorMessage: number
    createdAt: number
    _all: number
  }


  export type UserProfilingJobAvgAggregateInputType = {
    totalUsers?: true
    processedUsers?: true
    failedUsers?: true
  }

  export type UserProfilingJobSumAggregateInputType = {
    totalUsers?: true
    processedUsers?: true
    failedUsers?: true
  }

  export type UserProfilingJobMinAggregateInputType = {
    id?: true
    status?: true
    targetDate?: true
    tenantId?: true
    totalUsers?: true
    processedUsers?: true
    failedUsers?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
  }

  export type UserProfilingJobMaxAggregateInputType = {
    id?: true
    status?: true
    targetDate?: true
    tenantId?: true
    totalUsers?: true
    processedUsers?: true
    failedUsers?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
  }

  export type UserProfilingJobCountAggregateInputType = {
    id?: true
    status?: true
    targetDate?: true
    tenantId?: true
    totalUsers?: true
    processedUsers?: true
    failedUsers?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
    _all?: true
  }

  export type UserProfilingJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfilingJob to aggregate.
     */
    where?: UserProfilingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfilingJobs to fetch.
     */
    orderBy?: UserProfilingJobOrderByWithRelationInput | UserProfilingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfilingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfilingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfilingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfilingJobs
    **/
    _count?: true | UserProfilingJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfilingJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfilingJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfilingJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfilingJobMaxAggregateInputType
  }

  export type GetUserProfilingJobAggregateType<T extends UserProfilingJobAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfilingJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfilingJob[P]>
      : GetScalarType<T[P], AggregateUserProfilingJob[P]>
  }




  export type UserProfilingJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfilingJobWhereInput
    orderBy?: UserProfilingJobOrderByWithAggregationInput | UserProfilingJobOrderByWithAggregationInput[]
    by: UserProfilingJobScalarFieldEnum[] | UserProfilingJobScalarFieldEnum
    having?: UserProfilingJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfilingJobCountAggregateInputType | true
    _avg?: UserProfilingJobAvgAggregateInputType
    _sum?: UserProfilingJobSumAggregateInputType
    _min?: UserProfilingJobMinAggregateInputType
    _max?: UserProfilingJobMaxAggregateInputType
  }

  export type UserProfilingJobGroupByOutputType = {
    id: string
    status: string
    targetDate: Date
    tenantId: string | null
    totalUsers: number
    processedUsers: number
    failedUsers: number
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date
    _count: UserProfilingJobCountAggregateOutputType | null
    _avg: UserProfilingJobAvgAggregateOutputType | null
    _sum: UserProfilingJobSumAggregateOutputType | null
    _min: UserProfilingJobMinAggregateOutputType | null
    _max: UserProfilingJobMaxAggregateOutputType | null
  }

  type GetUserProfilingJobGroupByPayload<T extends UserProfilingJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfilingJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfilingJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfilingJobGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfilingJobGroupByOutputType[P]>
        }
      >
    >


  export type UserProfilingJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    targetDate?: boolean
    tenantId?: boolean
    totalUsers?: boolean
    processedUsers?: boolean
    failedUsers?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userProfilingJob"]>

  export type UserProfilingJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    targetDate?: boolean
    tenantId?: boolean
    totalUsers?: boolean
    processedUsers?: boolean
    failedUsers?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userProfilingJob"]>

  export type UserProfilingJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    targetDate?: boolean
    tenantId?: boolean
    totalUsers?: boolean
    processedUsers?: boolean
    failedUsers?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userProfilingJob"]>

  export type UserProfilingJobSelectScalar = {
    id?: boolean
    status?: boolean
    targetDate?: boolean
    tenantId?: boolean
    totalUsers?: boolean
    processedUsers?: boolean
    failedUsers?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }

  export type UserProfilingJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "targetDate" | "tenantId" | "totalUsers" | "processedUsers" | "failedUsers" | "startedAt" | "completedAt" | "errorMessage" | "createdAt", ExtArgs["result"]["userProfilingJob"]>

  export type $UserProfilingJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfilingJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      targetDate: Date
      tenantId: string | null
      totalUsers: number
      processedUsers: number
      failedUsers: number
      startedAt: Date | null
      completedAt: Date | null
      errorMessage: string | null
      createdAt: Date
    }, ExtArgs["result"]["userProfilingJob"]>
    composites: {}
  }

  type UserProfilingJobGetPayload<S extends boolean | null | undefined | UserProfilingJobDefaultArgs> = $Result.GetResult<Prisma.$UserProfilingJobPayload, S>

  type UserProfilingJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfilingJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfilingJobCountAggregateInputType | true
    }

  export interface UserProfilingJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfilingJob'], meta: { name: 'UserProfilingJob' } }
    /**
     * Find zero or one UserProfilingJob that matches the filter.
     * @param {UserProfilingJobFindUniqueArgs} args - Arguments to find a UserProfilingJob
     * @example
     * // Get one UserProfilingJob
     * const userProfilingJob = await prisma.userProfilingJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfilingJobFindUniqueArgs>(args: SelectSubset<T, UserProfilingJobFindUniqueArgs<ExtArgs>>): Prisma__UserProfilingJobClient<$Result.GetResult<Prisma.$UserProfilingJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfilingJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfilingJobFindUniqueOrThrowArgs} args - Arguments to find a UserProfilingJob
     * @example
     * // Get one UserProfilingJob
     * const userProfilingJob = await prisma.userProfilingJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfilingJobFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfilingJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfilingJobClient<$Result.GetResult<Prisma.$UserProfilingJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfilingJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfilingJobFindFirstArgs} args - Arguments to find a UserProfilingJob
     * @example
     * // Get one UserProfilingJob
     * const userProfilingJob = await prisma.userProfilingJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfilingJobFindFirstArgs>(args?: SelectSubset<T, UserProfilingJobFindFirstArgs<ExtArgs>>): Prisma__UserProfilingJobClient<$Result.GetResult<Prisma.$UserProfilingJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfilingJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfilingJobFindFirstOrThrowArgs} args - Arguments to find a UserProfilingJob
     * @example
     * // Get one UserProfilingJob
     * const userProfilingJob = await prisma.userProfilingJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfilingJobFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfilingJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfilingJobClient<$Result.GetResult<Prisma.$UserProfilingJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfilingJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfilingJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfilingJobs
     * const userProfilingJobs = await prisma.userProfilingJob.findMany()
     * 
     * // Get first 10 UserProfilingJobs
     * const userProfilingJobs = await prisma.userProfilingJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfilingJobWithIdOnly = await prisma.userProfilingJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfilingJobFindManyArgs>(args?: SelectSubset<T, UserProfilingJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilingJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfilingJob.
     * @param {UserProfilingJobCreateArgs} args - Arguments to create a UserProfilingJob.
     * @example
     * // Create one UserProfilingJob
     * const UserProfilingJob = await prisma.userProfilingJob.create({
     *   data: {
     *     // ... data to create a UserProfilingJob
     *   }
     * })
     * 
     */
    create<T extends UserProfilingJobCreateArgs>(args: SelectSubset<T, UserProfilingJobCreateArgs<ExtArgs>>): Prisma__UserProfilingJobClient<$Result.GetResult<Prisma.$UserProfilingJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfilingJobs.
     * @param {UserProfilingJobCreateManyArgs} args - Arguments to create many UserProfilingJobs.
     * @example
     * // Create many UserProfilingJobs
     * const userProfilingJob = await prisma.userProfilingJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfilingJobCreateManyArgs>(args?: SelectSubset<T, UserProfilingJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfilingJobs and returns the data saved in the database.
     * @param {UserProfilingJobCreateManyAndReturnArgs} args - Arguments to create many UserProfilingJobs.
     * @example
     * // Create many UserProfilingJobs
     * const userProfilingJob = await prisma.userProfilingJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfilingJobs and only return the `id`
     * const userProfilingJobWithIdOnly = await prisma.userProfilingJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfilingJobCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfilingJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilingJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfilingJob.
     * @param {UserProfilingJobDeleteArgs} args - Arguments to delete one UserProfilingJob.
     * @example
     * // Delete one UserProfilingJob
     * const UserProfilingJob = await prisma.userProfilingJob.delete({
     *   where: {
     *     // ... filter to delete one UserProfilingJob
     *   }
     * })
     * 
     */
    delete<T extends UserProfilingJobDeleteArgs>(args: SelectSubset<T, UserProfilingJobDeleteArgs<ExtArgs>>): Prisma__UserProfilingJobClient<$Result.GetResult<Prisma.$UserProfilingJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfilingJob.
     * @param {UserProfilingJobUpdateArgs} args - Arguments to update one UserProfilingJob.
     * @example
     * // Update one UserProfilingJob
     * const userProfilingJob = await prisma.userProfilingJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfilingJobUpdateArgs>(args: SelectSubset<T, UserProfilingJobUpdateArgs<ExtArgs>>): Prisma__UserProfilingJobClient<$Result.GetResult<Prisma.$UserProfilingJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfilingJobs.
     * @param {UserProfilingJobDeleteManyArgs} args - Arguments to filter UserProfilingJobs to delete.
     * @example
     * // Delete a few UserProfilingJobs
     * const { count } = await prisma.userProfilingJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfilingJobDeleteManyArgs>(args?: SelectSubset<T, UserProfilingJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfilingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfilingJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfilingJobs
     * const userProfilingJob = await prisma.userProfilingJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfilingJobUpdateManyArgs>(args: SelectSubset<T, UserProfilingJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfilingJobs and returns the data updated in the database.
     * @param {UserProfilingJobUpdateManyAndReturnArgs} args - Arguments to update many UserProfilingJobs.
     * @example
     * // Update many UserProfilingJobs
     * const userProfilingJob = await prisma.userProfilingJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfilingJobs and only return the `id`
     * const userProfilingJobWithIdOnly = await prisma.userProfilingJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfilingJobUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfilingJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilingJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfilingJob.
     * @param {UserProfilingJobUpsertArgs} args - Arguments to update or create a UserProfilingJob.
     * @example
     * // Update or create a UserProfilingJob
     * const userProfilingJob = await prisma.userProfilingJob.upsert({
     *   create: {
     *     // ... data to create a UserProfilingJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfilingJob we want to update
     *   }
     * })
     */
    upsert<T extends UserProfilingJobUpsertArgs>(args: SelectSubset<T, UserProfilingJobUpsertArgs<ExtArgs>>): Prisma__UserProfilingJobClient<$Result.GetResult<Prisma.$UserProfilingJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfilingJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfilingJobCountArgs} args - Arguments to filter UserProfilingJobs to count.
     * @example
     * // Count the number of UserProfilingJobs
     * const count = await prisma.userProfilingJob.count({
     *   where: {
     *     // ... the filter for the UserProfilingJobs we want to count
     *   }
     * })
    **/
    count<T extends UserProfilingJobCountArgs>(
      args?: Subset<T, UserProfilingJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfilingJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfilingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfilingJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfilingJobAggregateArgs>(args: Subset<T, UserProfilingJobAggregateArgs>): Prisma.PrismaPromise<GetUserProfilingJobAggregateType<T>>

    /**
     * Group by UserProfilingJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfilingJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfilingJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfilingJobGroupByArgs['orderBy'] }
        : { orderBy?: UserProfilingJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfilingJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfilingJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfilingJob model
   */
  readonly fields: UserProfilingJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfilingJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfilingJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfilingJob model
   */
  interface UserProfilingJobFieldRefs {
    readonly id: FieldRef<"UserProfilingJob", 'String'>
    readonly status: FieldRef<"UserProfilingJob", 'String'>
    readonly targetDate: FieldRef<"UserProfilingJob", 'DateTime'>
    readonly tenantId: FieldRef<"UserProfilingJob", 'String'>
    readonly totalUsers: FieldRef<"UserProfilingJob", 'Int'>
    readonly processedUsers: FieldRef<"UserProfilingJob", 'Int'>
    readonly failedUsers: FieldRef<"UserProfilingJob", 'Int'>
    readonly startedAt: FieldRef<"UserProfilingJob", 'DateTime'>
    readonly completedAt: FieldRef<"UserProfilingJob", 'DateTime'>
    readonly errorMessage: FieldRef<"UserProfilingJob", 'String'>
    readonly createdAt: FieldRef<"UserProfilingJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfilingJob findUnique
   */
  export type UserProfilingJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
    /**
     * Filter, which UserProfilingJob to fetch.
     */
    where: UserProfilingJobWhereUniqueInput
  }

  /**
   * UserProfilingJob findUniqueOrThrow
   */
  export type UserProfilingJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
    /**
     * Filter, which UserProfilingJob to fetch.
     */
    where: UserProfilingJobWhereUniqueInput
  }

  /**
   * UserProfilingJob findFirst
   */
  export type UserProfilingJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
    /**
     * Filter, which UserProfilingJob to fetch.
     */
    where?: UserProfilingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfilingJobs to fetch.
     */
    orderBy?: UserProfilingJobOrderByWithRelationInput | UserProfilingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfilingJobs.
     */
    cursor?: UserProfilingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfilingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfilingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfilingJobs.
     */
    distinct?: UserProfilingJobScalarFieldEnum | UserProfilingJobScalarFieldEnum[]
  }

  /**
   * UserProfilingJob findFirstOrThrow
   */
  export type UserProfilingJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
    /**
     * Filter, which UserProfilingJob to fetch.
     */
    where?: UserProfilingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfilingJobs to fetch.
     */
    orderBy?: UserProfilingJobOrderByWithRelationInput | UserProfilingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfilingJobs.
     */
    cursor?: UserProfilingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfilingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfilingJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfilingJobs.
     */
    distinct?: UserProfilingJobScalarFieldEnum | UserProfilingJobScalarFieldEnum[]
  }

  /**
   * UserProfilingJob findMany
   */
  export type UserProfilingJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
    /**
     * Filter, which UserProfilingJobs to fetch.
     */
    where?: UserProfilingJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfilingJobs to fetch.
     */
    orderBy?: UserProfilingJobOrderByWithRelationInput | UserProfilingJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfilingJobs.
     */
    cursor?: UserProfilingJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfilingJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfilingJobs.
     */
    skip?: number
    distinct?: UserProfilingJobScalarFieldEnum | UserProfilingJobScalarFieldEnum[]
  }

  /**
   * UserProfilingJob create
   */
  export type UserProfilingJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
    /**
     * The data needed to create a UserProfilingJob.
     */
    data: XOR<UserProfilingJobCreateInput, UserProfilingJobUncheckedCreateInput>
  }

  /**
   * UserProfilingJob createMany
   */
  export type UserProfilingJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfilingJobs.
     */
    data: UserProfilingJobCreateManyInput | UserProfilingJobCreateManyInput[]
  }

  /**
   * UserProfilingJob createManyAndReturn
   */
  export type UserProfilingJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfilingJobs.
     */
    data: UserProfilingJobCreateManyInput | UserProfilingJobCreateManyInput[]
  }

  /**
   * UserProfilingJob update
   */
  export type UserProfilingJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
    /**
     * The data needed to update a UserProfilingJob.
     */
    data: XOR<UserProfilingJobUpdateInput, UserProfilingJobUncheckedUpdateInput>
    /**
     * Choose, which UserProfilingJob to update.
     */
    where: UserProfilingJobWhereUniqueInput
  }

  /**
   * UserProfilingJob updateMany
   */
  export type UserProfilingJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfilingJobs.
     */
    data: XOR<UserProfilingJobUpdateManyMutationInput, UserProfilingJobUncheckedUpdateManyInput>
    /**
     * Filter which UserProfilingJobs to update
     */
    where?: UserProfilingJobWhereInput
    /**
     * Limit how many UserProfilingJobs to update.
     */
    limit?: number
  }

  /**
   * UserProfilingJob updateManyAndReturn
   */
  export type UserProfilingJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
    /**
     * The data used to update UserProfilingJobs.
     */
    data: XOR<UserProfilingJobUpdateManyMutationInput, UserProfilingJobUncheckedUpdateManyInput>
    /**
     * Filter which UserProfilingJobs to update
     */
    where?: UserProfilingJobWhereInput
    /**
     * Limit how many UserProfilingJobs to update.
     */
    limit?: number
  }

  /**
   * UserProfilingJob upsert
   */
  export type UserProfilingJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
    /**
     * The filter to search for the UserProfilingJob to update in case it exists.
     */
    where: UserProfilingJobWhereUniqueInput
    /**
     * In case the UserProfilingJob found by the `where` argument doesn't exist, create a new UserProfilingJob with this data.
     */
    create: XOR<UserProfilingJobCreateInput, UserProfilingJobUncheckedCreateInput>
    /**
     * In case the UserProfilingJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfilingJobUpdateInput, UserProfilingJobUncheckedUpdateInput>
  }

  /**
   * UserProfilingJob delete
   */
  export type UserProfilingJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
    /**
     * Filter which UserProfilingJob to delete.
     */
    where: UserProfilingJobWhereUniqueInput
  }

  /**
   * UserProfilingJob deleteMany
   */
  export type UserProfilingJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfilingJobs to delete
     */
    where?: UserProfilingJobWhereInput
    /**
     * Limit how many UserProfilingJobs to delete.
     */
    limit?: number
  }

  /**
   * UserProfilingJob without action
   */
  export type UserProfilingJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfilingJob
     */
    select?: UserProfilingJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfilingJob
     */
    omit?: UserProfilingJobOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    isActive: 'isActive',
    failedAttempts: 'failedAttempts',
    lockedUntil: 'lockedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    createdAt: 'createdAt'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const SavedFilterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    criteria: 'criteria',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SavedFilterScalarFieldEnum = (typeof SavedFilterScalarFieldEnum)[keyof typeof SavedFilterScalarFieldEnum]


  export const AnalysisSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    context: 'context',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalysisSessionScalarFieldEnum = (typeof AnalysisSessionScalarFieldEnum)[keyof typeof AnalysisSessionScalarFieldEnum]


  export const AnalysisMessageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    role: 'role',
    content: 'content',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AnalysisMessageScalarFieldEnum = (typeof AnalysisMessageScalarFieldEnum)[keyof typeof AnalysisMessageScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    key: 'key',
    permissions: 'permissions',
    expiresAt: 'expiresAt',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const BatchAnalysisJobScalarFieldEnum: {
    id: 'id',
    status: 'status',
    targetDate: 'targetDate',
    tenantId: 'tenantId',
    sampleSize: 'sampleSize',
    promptTemplate: 'promptTemplate',
    totalItems: 'totalItems',
    processedItems: 'processedItems',
    failedItems: 'failedItems',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage',
    cancelRequested: 'cancelRequested',
    createdAt: 'createdAt'
  };

  export type BatchAnalysisJobScalarFieldEnum = (typeof BatchAnalysisJobScalarFieldEnum)[keyof typeof BatchAnalysisJobScalarFieldEnum]


  export const BatchAnalysisResultScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    originalTimestamp: 'originalTimestamp',
    tenantId: 'tenantId',
    sessionId: 'sessionId',
    userInput: 'userInput',
    llmResponse: 'llmResponse',
    analysisPrompt: 'analysisPrompt',
    analysisResult: 'analysisResult',
    modelName: 'modelName',
    latencyMs: 'latencyMs',
    inputTokens: 'inputTokens',
    outputTokens: 'outputTokens',
    qualityScore: 'qualityScore',
    relevance: 'relevance',
    completeness: 'completeness',
    clarity: 'clarity',
    sentiment: 'sentiment',
    summaryText: 'summaryText',
    issues: 'issues',
    improvements: 'improvements',
    missingData: 'missingData',
    issueCount: 'issueCount',
    avgScore: 'avgScore',
    status: 'status',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt'
  };

  export type BatchAnalysisResultScalarFieldEnum = (typeof BatchAnalysisResultScalarFieldEnum)[keyof typeof BatchAnalysisResultScalarFieldEnum]


  export const AnalysisPromptTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    prompt: 'prompt',
    isDefault: 'isDefault',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalysisPromptTemplateScalarFieldEnum = (typeof AnalysisPromptTemplateScalarFieldEnum)[keyof typeof AnalysisPromptTemplateScalarFieldEnum]


  export const BatchSchedulerConfigScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isEnabled: 'isEnabled',
    hour: 'hour',
    minute: 'minute',
    daysOfWeek: 'daysOfWeek',
    timeZone: 'timeZone',
    targetTenantId: 'targetTenantId',
    sampleSize: 'sampleSize',
    promptTemplateId: 'promptTemplateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchSchedulerConfigScalarFieldEnum = (typeof BatchSchedulerConfigScalarFieldEnum)[keyof typeof BatchSchedulerConfigScalarFieldEnum]


  export const FAQAnalysisJobScalarFieldEnum: {
    id: 'id',
    status: 'status',
    tenantId: 'tenantId',
    periodDays: 'periodDays',
    topN: 'topN',
    totalQuestions: 'totalQuestions',
    clusterCount: 'clusterCount',
    llmMergeApplied: 'llmMergeApplied',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt'
  };

  export type FAQAnalysisJobScalarFieldEnum = (typeof FAQAnalysisJobScalarFieldEnum)[keyof typeof FAQAnalysisJobScalarFieldEnum]


  export const FAQAnalysisResultScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    rank: 'rank',
    representativeQuestion: 'representativeQuestion',
    frequency: 'frequency',
    reasonAnalysis: 'reasonAnalysis',
    isMerged: 'isMerged',
    questions: 'questions',
    createdAt: 'createdAt'
  };

  export type FAQAnalysisResultScalarFieldEnum = (typeof FAQAnalysisResultScalarFieldEnum)[keyof typeof FAQAnalysisResultScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenantId: 'tenantId',
    frustrationRate: 'frustrationRate',
    aggressiveCount: 'aggressiveCount',
    categoryDistribution: 'categoryDistribution',
    behaviorSummary: 'behaviorSummary',
    mainInterests: 'mainInterests',
    painPoints: 'painPoints',
    totalMessages: 'totalMessages',
    analyzedMessages: 'analyzedMessages',
    lastAnalyzedAt: 'lastAnalyzedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const MessageCategoryAnalysisScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenantId: 'tenantId',
    messageHash: 'messageHash',
    category: 'category',
    confidence: 'confidence',
    sentiment: 'sentiment',
    isAggressive: 'isAggressive',
    userInput: 'userInput',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type MessageCategoryAnalysisScalarFieldEnum = (typeof MessageCategoryAnalysisScalarFieldEnum)[keyof typeof MessageCategoryAnalysisScalarFieldEnum]


  export const UserProfilingJobScalarFieldEnum: {
    id: 'id',
    status: 'status',
    targetDate: 'targetDate',
    tenantId: 'tenantId',
    totalUsers: 'totalUsers',
    processedUsers: 'processedUsers',
    failedUsers: 'failedUsers',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt'
  };

  export type UserProfilingJobScalarFieldEnum = (typeof UserProfilingJobScalarFieldEnum)[keyof typeof UserProfilingJobScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    failedAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    userRoles?: UserRoleListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    savedFilters?: SavedFilterListRelationFilter
    analysisSessions?: AnalysisSessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    savedFilters?: SavedFilterOrderByRelationAggregateInput
    analysisSessions?: AnalysisSessionOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    failedAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    userRoles?: UserRoleListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    savedFilters?: SavedFilterListRelationFilter
    analysisSessions?: AnalysisSessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    failedAttempts?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePermission"> | string
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
  }

  export type SavedFilterWhereInput = {
    AND?: SavedFilterWhereInput | SavedFilterWhereInput[]
    OR?: SavedFilterWhereInput[]
    NOT?: SavedFilterWhereInput | SavedFilterWhereInput[]
    id?: StringFilter<"SavedFilter"> | string
    userId?: StringFilter<"SavedFilter"> | string
    name?: StringFilter<"SavedFilter"> | string
    description?: StringNullableFilter<"SavedFilter"> | string | null
    criteria?: StringFilter<"SavedFilter"> | string
    isDefault?: BoolFilter<"SavedFilter"> | boolean
    createdAt?: DateTimeFilter<"SavedFilter"> | Date | string
    updatedAt?: DateTimeFilter<"SavedFilter"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SavedFilterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    criteria?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SavedFilterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SavedFilterWhereInput | SavedFilterWhereInput[]
    OR?: SavedFilterWhereInput[]
    NOT?: SavedFilterWhereInput | SavedFilterWhereInput[]
    userId?: StringFilter<"SavedFilter"> | string
    name?: StringFilter<"SavedFilter"> | string
    description?: StringNullableFilter<"SavedFilter"> | string | null
    criteria?: StringFilter<"SavedFilter"> | string
    isDefault?: BoolFilter<"SavedFilter"> | boolean
    createdAt?: DateTimeFilter<"SavedFilter"> | Date | string
    updatedAt?: DateTimeFilter<"SavedFilter"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SavedFilterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    criteria?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SavedFilterCountOrderByAggregateInput
    _max?: SavedFilterMaxOrderByAggregateInput
    _min?: SavedFilterMinOrderByAggregateInput
  }

  export type SavedFilterScalarWhereWithAggregatesInput = {
    AND?: SavedFilterScalarWhereWithAggregatesInput | SavedFilterScalarWhereWithAggregatesInput[]
    OR?: SavedFilterScalarWhereWithAggregatesInput[]
    NOT?: SavedFilterScalarWhereWithAggregatesInput | SavedFilterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedFilter"> | string
    userId?: StringWithAggregatesFilter<"SavedFilter"> | string
    name?: StringWithAggregatesFilter<"SavedFilter"> | string
    description?: StringNullableWithAggregatesFilter<"SavedFilter"> | string | null
    criteria?: StringWithAggregatesFilter<"SavedFilter"> | string
    isDefault?: BoolWithAggregatesFilter<"SavedFilter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SavedFilter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SavedFilter"> | Date | string
  }

  export type AnalysisSessionWhereInput = {
    AND?: AnalysisSessionWhereInput | AnalysisSessionWhereInput[]
    OR?: AnalysisSessionWhereInput[]
    NOT?: AnalysisSessionWhereInput | AnalysisSessionWhereInput[]
    id?: StringFilter<"AnalysisSession"> | string
    userId?: StringFilter<"AnalysisSession"> | string
    title?: StringFilter<"AnalysisSession"> | string
    context?: StringNullableFilter<"AnalysisSession"> | string | null
    createdAt?: DateTimeFilter<"AnalysisSession"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: AnalysisMessageListRelationFilter
  }

  export type AnalysisSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    context?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: AnalysisMessageOrderByRelationAggregateInput
  }

  export type AnalysisSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalysisSessionWhereInput | AnalysisSessionWhereInput[]
    OR?: AnalysisSessionWhereInput[]
    NOT?: AnalysisSessionWhereInput | AnalysisSessionWhereInput[]
    userId?: StringFilter<"AnalysisSession"> | string
    title?: StringFilter<"AnalysisSession"> | string
    context?: StringNullableFilter<"AnalysisSession"> | string | null
    createdAt?: DateTimeFilter<"AnalysisSession"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: AnalysisMessageListRelationFilter
  }, "id">

  export type AnalysisSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    context?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalysisSessionCountOrderByAggregateInput
    _max?: AnalysisSessionMaxOrderByAggregateInput
    _min?: AnalysisSessionMinOrderByAggregateInput
  }

  export type AnalysisSessionScalarWhereWithAggregatesInput = {
    AND?: AnalysisSessionScalarWhereWithAggregatesInput | AnalysisSessionScalarWhereWithAggregatesInput[]
    OR?: AnalysisSessionScalarWhereWithAggregatesInput[]
    NOT?: AnalysisSessionScalarWhereWithAggregatesInput | AnalysisSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalysisSession"> | string
    userId?: StringWithAggregatesFilter<"AnalysisSession"> | string
    title?: StringWithAggregatesFilter<"AnalysisSession"> | string
    context?: StringNullableWithAggregatesFilter<"AnalysisSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalysisSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalysisSession"> | Date | string
  }

  export type AnalysisMessageWhereInput = {
    AND?: AnalysisMessageWhereInput | AnalysisMessageWhereInput[]
    OR?: AnalysisMessageWhereInput[]
    NOT?: AnalysisMessageWhereInput | AnalysisMessageWhereInput[]
    id?: StringFilter<"AnalysisMessage"> | string
    sessionId?: StringFilter<"AnalysisMessage"> | string
    role?: StringFilter<"AnalysisMessage"> | string
    content?: StringFilter<"AnalysisMessage"> | string
    metadata?: StringNullableFilter<"AnalysisMessage"> | string | null
    createdAt?: DateTimeFilter<"AnalysisMessage"> | Date | string
    session?: XOR<AnalysisSessionScalarRelationFilter, AnalysisSessionWhereInput>
  }

  export type AnalysisMessageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: AnalysisSessionOrderByWithRelationInput
  }

  export type AnalysisMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalysisMessageWhereInput | AnalysisMessageWhereInput[]
    OR?: AnalysisMessageWhereInput[]
    NOT?: AnalysisMessageWhereInput | AnalysisMessageWhereInput[]
    sessionId?: StringFilter<"AnalysisMessage"> | string
    role?: StringFilter<"AnalysisMessage"> | string
    content?: StringFilter<"AnalysisMessage"> | string
    metadata?: StringNullableFilter<"AnalysisMessage"> | string | null
    createdAt?: DateTimeFilter<"AnalysisMessage"> | Date | string
    session?: XOR<AnalysisSessionScalarRelationFilter, AnalysisSessionWhereInput>
  }, "id">

  export type AnalysisMessageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnalysisMessageCountOrderByAggregateInput
    _max?: AnalysisMessageMaxOrderByAggregateInput
    _min?: AnalysisMessageMinOrderByAggregateInput
  }

  export type AnalysisMessageScalarWhereWithAggregatesInput = {
    AND?: AnalysisMessageScalarWhereWithAggregatesInput | AnalysisMessageScalarWhereWithAggregatesInput[]
    OR?: AnalysisMessageScalarWhereWithAggregatesInput[]
    NOT?: AnalysisMessageScalarWhereWithAggregatesInput | AnalysisMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalysisMessage"> | string
    sessionId?: StringWithAggregatesFilter<"AnalysisMessage"> | string
    role?: StringWithAggregatesFilter<"AnalysisMessage"> | string
    content?: StringWithAggregatesFilter<"AnalysisMessage"> | string
    metadata?: StringNullableWithAggregatesFilter<"AnalysisMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnalysisMessage"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    permissions?: StringFilter<"ApiKey"> | string
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    permissions?: StringFilter<"ApiKey"> | string
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "key">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    userId?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    key?: StringWithAggregatesFilter<"ApiKey"> | string
    permissions?: StringWithAggregatesFilter<"ApiKey"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
  }

  export type BatchAnalysisJobWhereInput = {
    AND?: BatchAnalysisJobWhereInput | BatchAnalysisJobWhereInput[]
    OR?: BatchAnalysisJobWhereInput[]
    NOT?: BatchAnalysisJobWhereInput | BatchAnalysisJobWhereInput[]
    id?: StringFilter<"BatchAnalysisJob"> | string
    status?: StringFilter<"BatchAnalysisJob"> | string
    targetDate?: DateTimeFilter<"BatchAnalysisJob"> | Date | string
    tenantId?: StringNullableFilter<"BatchAnalysisJob"> | string | null
    sampleSize?: IntFilter<"BatchAnalysisJob"> | number
    promptTemplate?: StringFilter<"BatchAnalysisJob"> | string
    totalItems?: IntFilter<"BatchAnalysisJob"> | number
    processedItems?: IntFilter<"BatchAnalysisJob"> | number
    failedItems?: IntFilter<"BatchAnalysisJob"> | number
    startedAt?: DateTimeNullableFilter<"BatchAnalysisJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"BatchAnalysisJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"BatchAnalysisJob"> | string | null
    cancelRequested?: BoolFilter<"BatchAnalysisJob"> | boolean
    createdAt?: DateTimeFilter<"BatchAnalysisJob"> | Date | string
    results?: BatchAnalysisResultListRelationFilter
  }

  export type BatchAnalysisJobOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    sampleSize?: SortOrder
    promptTemplate?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    failedItems?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    cancelRequested?: SortOrder
    createdAt?: SortOrder
    results?: BatchAnalysisResultOrderByRelationAggregateInput
  }

  export type BatchAnalysisJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BatchAnalysisJobWhereInput | BatchAnalysisJobWhereInput[]
    OR?: BatchAnalysisJobWhereInput[]
    NOT?: BatchAnalysisJobWhereInput | BatchAnalysisJobWhereInput[]
    status?: StringFilter<"BatchAnalysisJob"> | string
    targetDate?: DateTimeFilter<"BatchAnalysisJob"> | Date | string
    tenantId?: StringNullableFilter<"BatchAnalysisJob"> | string | null
    sampleSize?: IntFilter<"BatchAnalysisJob"> | number
    promptTemplate?: StringFilter<"BatchAnalysisJob"> | string
    totalItems?: IntFilter<"BatchAnalysisJob"> | number
    processedItems?: IntFilter<"BatchAnalysisJob"> | number
    failedItems?: IntFilter<"BatchAnalysisJob"> | number
    startedAt?: DateTimeNullableFilter<"BatchAnalysisJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"BatchAnalysisJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"BatchAnalysisJob"> | string | null
    cancelRequested?: BoolFilter<"BatchAnalysisJob"> | boolean
    createdAt?: DateTimeFilter<"BatchAnalysisJob"> | Date | string
    results?: BatchAnalysisResultListRelationFilter
  }, "id">

  export type BatchAnalysisJobOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    sampleSize?: SortOrder
    promptTemplate?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    failedItems?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    cancelRequested?: SortOrder
    createdAt?: SortOrder
    _count?: BatchAnalysisJobCountOrderByAggregateInput
    _avg?: BatchAnalysisJobAvgOrderByAggregateInput
    _max?: BatchAnalysisJobMaxOrderByAggregateInput
    _min?: BatchAnalysisJobMinOrderByAggregateInput
    _sum?: BatchAnalysisJobSumOrderByAggregateInput
  }

  export type BatchAnalysisJobScalarWhereWithAggregatesInput = {
    AND?: BatchAnalysisJobScalarWhereWithAggregatesInput | BatchAnalysisJobScalarWhereWithAggregatesInput[]
    OR?: BatchAnalysisJobScalarWhereWithAggregatesInput[]
    NOT?: BatchAnalysisJobScalarWhereWithAggregatesInput | BatchAnalysisJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BatchAnalysisJob"> | string
    status?: StringWithAggregatesFilter<"BatchAnalysisJob"> | string
    targetDate?: DateTimeWithAggregatesFilter<"BatchAnalysisJob"> | Date | string
    tenantId?: StringNullableWithAggregatesFilter<"BatchAnalysisJob"> | string | null
    sampleSize?: IntWithAggregatesFilter<"BatchAnalysisJob"> | number
    promptTemplate?: StringWithAggregatesFilter<"BatchAnalysisJob"> | string
    totalItems?: IntWithAggregatesFilter<"BatchAnalysisJob"> | number
    processedItems?: IntWithAggregatesFilter<"BatchAnalysisJob"> | number
    failedItems?: IntWithAggregatesFilter<"BatchAnalysisJob"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"BatchAnalysisJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"BatchAnalysisJob"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"BatchAnalysisJob"> | string | null
    cancelRequested?: BoolWithAggregatesFilter<"BatchAnalysisJob"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BatchAnalysisJob"> | Date | string
  }

  export type BatchAnalysisResultWhereInput = {
    AND?: BatchAnalysisResultWhereInput | BatchAnalysisResultWhereInput[]
    OR?: BatchAnalysisResultWhereInput[]
    NOT?: BatchAnalysisResultWhereInput | BatchAnalysisResultWhereInput[]
    id?: StringFilter<"BatchAnalysisResult"> | string
    jobId?: StringFilter<"BatchAnalysisResult"> | string
    originalTimestamp?: DateTimeFilter<"BatchAnalysisResult"> | Date | string
    tenantId?: StringFilter<"BatchAnalysisResult"> | string
    sessionId?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    userInput?: StringFilter<"BatchAnalysisResult"> | string
    llmResponse?: StringFilter<"BatchAnalysisResult"> | string
    analysisPrompt?: StringFilter<"BatchAnalysisResult"> | string
    analysisResult?: StringFilter<"BatchAnalysisResult"> | string
    modelName?: StringFilter<"BatchAnalysisResult"> | string
    latencyMs?: IntFilter<"BatchAnalysisResult"> | number
    inputTokens?: IntFilter<"BatchAnalysisResult"> | number
    outputTokens?: IntFilter<"BatchAnalysisResult"> | number
    qualityScore?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    relevance?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    completeness?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    clarity?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    sentiment?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    summaryText?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    issues?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    improvements?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    missingData?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    issueCount?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    avgScore?: FloatNullableFilter<"BatchAnalysisResult"> | number | null
    status?: StringFilter<"BatchAnalysisResult"> | string
    errorMessage?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    createdAt?: DateTimeFilter<"BatchAnalysisResult"> | Date | string
    job?: XOR<BatchAnalysisJobScalarRelationFilter, BatchAnalysisJobWhereInput>
  }

  export type BatchAnalysisResultOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    originalTimestamp?: SortOrder
    tenantId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    userInput?: SortOrder
    llmResponse?: SortOrder
    analysisPrompt?: SortOrder
    analysisResult?: SortOrder
    modelName?: SortOrder
    latencyMs?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    relevance?: SortOrderInput | SortOrder
    completeness?: SortOrderInput | SortOrder
    clarity?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    summaryText?: SortOrderInput | SortOrder
    issues?: SortOrderInput | SortOrder
    improvements?: SortOrderInput | SortOrder
    missingData?: SortOrderInput | SortOrder
    issueCount?: SortOrderInput | SortOrder
    avgScore?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    job?: BatchAnalysisJobOrderByWithRelationInput
  }

  export type BatchAnalysisResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BatchAnalysisResultWhereInput | BatchAnalysisResultWhereInput[]
    OR?: BatchAnalysisResultWhereInput[]
    NOT?: BatchAnalysisResultWhereInput | BatchAnalysisResultWhereInput[]
    jobId?: StringFilter<"BatchAnalysisResult"> | string
    originalTimestamp?: DateTimeFilter<"BatchAnalysisResult"> | Date | string
    tenantId?: StringFilter<"BatchAnalysisResult"> | string
    sessionId?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    userInput?: StringFilter<"BatchAnalysisResult"> | string
    llmResponse?: StringFilter<"BatchAnalysisResult"> | string
    analysisPrompt?: StringFilter<"BatchAnalysisResult"> | string
    analysisResult?: StringFilter<"BatchAnalysisResult"> | string
    modelName?: StringFilter<"BatchAnalysisResult"> | string
    latencyMs?: IntFilter<"BatchAnalysisResult"> | number
    inputTokens?: IntFilter<"BatchAnalysisResult"> | number
    outputTokens?: IntFilter<"BatchAnalysisResult"> | number
    qualityScore?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    relevance?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    completeness?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    clarity?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    sentiment?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    summaryText?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    issues?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    improvements?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    missingData?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    issueCount?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    avgScore?: FloatNullableFilter<"BatchAnalysisResult"> | number | null
    status?: StringFilter<"BatchAnalysisResult"> | string
    errorMessage?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    createdAt?: DateTimeFilter<"BatchAnalysisResult"> | Date | string
    job?: XOR<BatchAnalysisJobScalarRelationFilter, BatchAnalysisJobWhereInput>
  }, "id">

  export type BatchAnalysisResultOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    originalTimestamp?: SortOrder
    tenantId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    userInput?: SortOrder
    llmResponse?: SortOrder
    analysisPrompt?: SortOrder
    analysisResult?: SortOrder
    modelName?: SortOrder
    latencyMs?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    relevance?: SortOrderInput | SortOrder
    completeness?: SortOrderInput | SortOrder
    clarity?: SortOrderInput | SortOrder
    sentiment?: SortOrderInput | SortOrder
    summaryText?: SortOrderInput | SortOrder
    issues?: SortOrderInput | SortOrder
    improvements?: SortOrderInput | SortOrder
    missingData?: SortOrderInput | SortOrder
    issueCount?: SortOrderInput | SortOrder
    avgScore?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BatchAnalysisResultCountOrderByAggregateInput
    _avg?: BatchAnalysisResultAvgOrderByAggregateInput
    _max?: BatchAnalysisResultMaxOrderByAggregateInput
    _min?: BatchAnalysisResultMinOrderByAggregateInput
    _sum?: BatchAnalysisResultSumOrderByAggregateInput
  }

  export type BatchAnalysisResultScalarWhereWithAggregatesInput = {
    AND?: BatchAnalysisResultScalarWhereWithAggregatesInput | BatchAnalysisResultScalarWhereWithAggregatesInput[]
    OR?: BatchAnalysisResultScalarWhereWithAggregatesInput[]
    NOT?: BatchAnalysisResultScalarWhereWithAggregatesInput | BatchAnalysisResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BatchAnalysisResult"> | string
    jobId?: StringWithAggregatesFilter<"BatchAnalysisResult"> | string
    originalTimestamp?: DateTimeWithAggregatesFilter<"BatchAnalysisResult"> | Date | string
    tenantId?: StringWithAggregatesFilter<"BatchAnalysisResult"> | string
    sessionId?: StringNullableWithAggregatesFilter<"BatchAnalysisResult"> | string | null
    userInput?: StringWithAggregatesFilter<"BatchAnalysisResult"> | string
    llmResponse?: StringWithAggregatesFilter<"BatchAnalysisResult"> | string
    analysisPrompt?: StringWithAggregatesFilter<"BatchAnalysisResult"> | string
    analysisResult?: StringWithAggregatesFilter<"BatchAnalysisResult"> | string
    modelName?: StringWithAggregatesFilter<"BatchAnalysisResult"> | string
    latencyMs?: IntWithAggregatesFilter<"BatchAnalysisResult"> | number
    inputTokens?: IntWithAggregatesFilter<"BatchAnalysisResult"> | number
    outputTokens?: IntWithAggregatesFilter<"BatchAnalysisResult"> | number
    qualityScore?: IntNullableWithAggregatesFilter<"BatchAnalysisResult"> | number | null
    relevance?: IntNullableWithAggregatesFilter<"BatchAnalysisResult"> | number | null
    completeness?: IntNullableWithAggregatesFilter<"BatchAnalysisResult"> | number | null
    clarity?: IntNullableWithAggregatesFilter<"BatchAnalysisResult"> | number | null
    sentiment?: StringNullableWithAggregatesFilter<"BatchAnalysisResult"> | string | null
    summaryText?: StringNullableWithAggregatesFilter<"BatchAnalysisResult"> | string | null
    issues?: StringNullableWithAggregatesFilter<"BatchAnalysisResult"> | string | null
    improvements?: StringNullableWithAggregatesFilter<"BatchAnalysisResult"> | string | null
    missingData?: StringNullableWithAggregatesFilter<"BatchAnalysisResult"> | string | null
    issueCount?: IntNullableWithAggregatesFilter<"BatchAnalysisResult"> | number | null
    avgScore?: FloatNullableWithAggregatesFilter<"BatchAnalysisResult"> | number | null
    status?: StringWithAggregatesFilter<"BatchAnalysisResult"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"BatchAnalysisResult"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BatchAnalysisResult"> | Date | string
  }

  export type AnalysisPromptTemplateWhereInput = {
    AND?: AnalysisPromptTemplateWhereInput | AnalysisPromptTemplateWhereInput[]
    OR?: AnalysisPromptTemplateWhereInput[]
    NOT?: AnalysisPromptTemplateWhereInput | AnalysisPromptTemplateWhereInput[]
    id?: StringFilter<"AnalysisPromptTemplate"> | string
    name?: StringFilter<"AnalysisPromptTemplate"> | string
    description?: StringNullableFilter<"AnalysisPromptTemplate"> | string | null
    prompt?: StringFilter<"AnalysisPromptTemplate"> | string
    isDefault?: BoolFilter<"AnalysisPromptTemplate"> | boolean
    isActive?: BoolFilter<"AnalysisPromptTemplate"> | boolean
    createdAt?: DateTimeFilter<"AnalysisPromptTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisPromptTemplate"> | Date | string
  }

  export type AnalysisPromptTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    prompt?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisPromptTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AnalysisPromptTemplateWhereInput | AnalysisPromptTemplateWhereInput[]
    OR?: AnalysisPromptTemplateWhereInput[]
    NOT?: AnalysisPromptTemplateWhereInput | AnalysisPromptTemplateWhereInput[]
    description?: StringNullableFilter<"AnalysisPromptTemplate"> | string | null
    prompt?: StringFilter<"AnalysisPromptTemplate"> | string
    isDefault?: BoolFilter<"AnalysisPromptTemplate"> | boolean
    isActive?: BoolFilter<"AnalysisPromptTemplate"> | boolean
    createdAt?: DateTimeFilter<"AnalysisPromptTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisPromptTemplate"> | Date | string
  }, "id" | "name">

  export type AnalysisPromptTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    prompt?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalysisPromptTemplateCountOrderByAggregateInput
    _max?: AnalysisPromptTemplateMaxOrderByAggregateInput
    _min?: AnalysisPromptTemplateMinOrderByAggregateInput
  }

  export type AnalysisPromptTemplateScalarWhereWithAggregatesInput = {
    AND?: AnalysisPromptTemplateScalarWhereWithAggregatesInput | AnalysisPromptTemplateScalarWhereWithAggregatesInput[]
    OR?: AnalysisPromptTemplateScalarWhereWithAggregatesInput[]
    NOT?: AnalysisPromptTemplateScalarWhereWithAggregatesInput | AnalysisPromptTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalysisPromptTemplate"> | string
    name?: StringWithAggregatesFilter<"AnalysisPromptTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"AnalysisPromptTemplate"> | string | null
    prompt?: StringWithAggregatesFilter<"AnalysisPromptTemplate"> | string
    isDefault?: BoolWithAggregatesFilter<"AnalysisPromptTemplate"> | boolean
    isActive?: BoolWithAggregatesFilter<"AnalysisPromptTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AnalysisPromptTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalysisPromptTemplate"> | Date | string
  }

  export type BatchSchedulerConfigWhereInput = {
    AND?: BatchSchedulerConfigWhereInput | BatchSchedulerConfigWhereInput[]
    OR?: BatchSchedulerConfigWhereInput[]
    NOT?: BatchSchedulerConfigWhereInput | BatchSchedulerConfigWhereInput[]
    id?: StringFilter<"BatchSchedulerConfig"> | string
    name?: StringFilter<"BatchSchedulerConfig"> | string
    isEnabled?: BoolFilter<"BatchSchedulerConfig"> | boolean
    hour?: IntFilter<"BatchSchedulerConfig"> | number
    minute?: IntFilter<"BatchSchedulerConfig"> | number
    daysOfWeek?: StringFilter<"BatchSchedulerConfig"> | string
    timeZone?: StringFilter<"BatchSchedulerConfig"> | string
    targetTenantId?: StringNullableFilter<"BatchSchedulerConfig"> | string | null
    sampleSize?: IntFilter<"BatchSchedulerConfig"> | number
    promptTemplateId?: StringNullableFilter<"BatchSchedulerConfig"> | string | null
    createdAt?: DateTimeFilter<"BatchSchedulerConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BatchSchedulerConfig"> | Date | string
  }

  export type BatchSchedulerConfigOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    hour?: SortOrder
    minute?: SortOrder
    daysOfWeek?: SortOrder
    timeZone?: SortOrder
    targetTenantId?: SortOrderInput | SortOrder
    sampleSize?: SortOrder
    promptTemplateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchSchedulerConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BatchSchedulerConfigWhereInput | BatchSchedulerConfigWhereInput[]
    OR?: BatchSchedulerConfigWhereInput[]
    NOT?: BatchSchedulerConfigWhereInput | BatchSchedulerConfigWhereInput[]
    name?: StringFilter<"BatchSchedulerConfig"> | string
    isEnabled?: BoolFilter<"BatchSchedulerConfig"> | boolean
    hour?: IntFilter<"BatchSchedulerConfig"> | number
    minute?: IntFilter<"BatchSchedulerConfig"> | number
    daysOfWeek?: StringFilter<"BatchSchedulerConfig"> | string
    timeZone?: StringFilter<"BatchSchedulerConfig"> | string
    targetTenantId?: StringNullableFilter<"BatchSchedulerConfig"> | string | null
    sampleSize?: IntFilter<"BatchSchedulerConfig"> | number
    promptTemplateId?: StringNullableFilter<"BatchSchedulerConfig"> | string | null
    createdAt?: DateTimeFilter<"BatchSchedulerConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BatchSchedulerConfig"> | Date | string
  }, "id">

  export type BatchSchedulerConfigOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    hour?: SortOrder
    minute?: SortOrder
    daysOfWeek?: SortOrder
    timeZone?: SortOrder
    targetTenantId?: SortOrderInput | SortOrder
    sampleSize?: SortOrder
    promptTemplateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BatchSchedulerConfigCountOrderByAggregateInput
    _avg?: BatchSchedulerConfigAvgOrderByAggregateInput
    _max?: BatchSchedulerConfigMaxOrderByAggregateInput
    _min?: BatchSchedulerConfigMinOrderByAggregateInput
    _sum?: BatchSchedulerConfigSumOrderByAggregateInput
  }

  export type BatchSchedulerConfigScalarWhereWithAggregatesInput = {
    AND?: BatchSchedulerConfigScalarWhereWithAggregatesInput | BatchSchedulerConfigScalarWhereWithAggregatesInput[]
    OR?: BatchSchedulerConfigScalarWhereWithAggregatesInput[]
    NOT?: BatchSchedulerConfigScalarWhereWithAggregatesInput | BatchSchedulerConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BatchSchedulerConfig"> | string
    name?: StringWithAggregatesFilter<"BatchSchedulerConfig"> | string
    isEnabled?: BoolWithAggregatesFilter<"BatchSchedulerConfig"> | boolean
    hour?: IntWithAggregatesFilter<"BatchSchedulerConfig"> | number
    minute?: IntWithAggregatesFilter<"BatchSchedulerConfig"> | number
    daysOfWeek?: StringWithAggregatesFilter<"BatchSchedulerConfig"> | string
    timeZone?: StringWithAggregatesFilter<"BatchSchedulerConfig"> | string
    targetTenantId?: StringNullableWithAggregatesFilter<"BatchSchedulerConfig"> | string | null
    sampleSize?: IntWithAggregatesFilter<"BatchSchedulerConfig"> | number
    promptTemplateId?: StringNullableWithAggregatesFilter<"BatchSchedulerConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BatchSchedulerConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BatchSchedulerConfig"> | Date | string
  }

  export type FAQAnalysisJobWhereInput = {
    AND?: FAQAnalysisJobWhereInput | FAQAnalysisJobWhereInput[]
    OR?: FAQAnalysisJobWhereInput[]
    NOT?: FAQAnalysisJobWhereInput | FAQAnalysisJobWhereInput[]
    id?: StringFilter<"FAQAnalysisJob"> | string
    status?: StringFilter<"FAQAnalysisJob"> | string
    tenantId?: StringNullableFilter<"FAQAnalysisJob"> | string | null
    periodDays?: IntFilter<"FAQAnalysisJob"> | number
    topN?: IntFilter<"FAQAnalysisJob"> | number
    totalQuestions?: IntNullableFilter<"FAQAnalysisJob"> | number | null
    clusterCount?: IntNullableFilter<"FAQAnalysisJob"> | number | null
    llmMergeApplied?: BoolFilter<"FAQAnalysisJob"> | boolean
    startedAt?: DateTimeNullableFilter<"FAQAnalysisJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"FAQAnalysisJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"FAQAnalysisJob"> | string | null
    createdAt?: DateTimeFilter<"FAQAnalysisJob"> | Date | string
    results?: FAQAnalysisResultListRelationFilter
  }

  export type FAQAnalysisJobOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    periodDays?: SortOrder
    topN?: SortOrder
    totalQuestions?: SortOrderInput | SortOrder
    clusterCount?: SortOrderInput | SortOrder
    llmMergeApplied?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    results?: FAQAnalysisResultOrderByRelationAggregateInput
  }

  export type FAQAnalysisJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FAQAnalysisJobWhereInput | FAQAnalysisJobWhereInput[]
    OR?: FAQAnalysisJobWhereInput[]
    NOT?: FAQAnalysisJobWhereInput | FAQAnalysisJobWhereInput[]
    status?: StringFilter<"FAQAnalysisJob"> | string
    tenantId?: StringNullableFilter<"FAQAnalysisJob"> | string | null
    periodDays?: IntFilter<"FAQAnalysisJob"> | number
    topN?: IntFilter<"FAQAnalysisJob"> | number
    totalQuestions?: IntNullableFilter<"FAQAnalysisJob"> | number | null
    clusterCount?: IntNullableFilter<"FAQAnalysisJob"> | number | null
    llmMergeApplied?: BoolFilter<"FAQAnalysisJob"> | boolean
    startedAt?: DateTimeNullableFilter<"FAQAnalysisJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"FAQAnalysisJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"FAQAnalysisJob"> | string | null
    createdAt?: DateTimeFilter<"FAQAnalysisJob"> | Date | string
    results?: FAQAnalysisResultListRelationFilter
  }, "id">

  export type FAQAnalysisJobOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    periodDays?: SortOrder
    topN?: SortOrder
    totalQuestions?: SortOrderInput | SortOrder
    clusterCount?: SortOrderInput | SortOrder
    llmMergeApplied?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FAQAnalysisJobCountOrderByAggregateInput
    _avg?: FAQAnalysisJobAvgOrderByAggregateInput
    _max?: FAQAnalysisJobMaxOrderByAggregateInput
    _min?: FAQAnalysisJobMinOrderByAggregateInput
    _sum?: FAQAnalysisJobSumOrderByAggregateInput
  }

  export type FAQAnalysisJobScalarWhereWithAggregatesInput = {
    AND?: FAQAnalysisJobScalarWhereWithAggregatesInput | FAQAnalysisJobScalarWhereWithAggregatesInput[]
    OR?: FAQAnalysisJobScalarWhereWithAggregatesInput[]
    NOT?: FAQAnalysisJobScalarWhereWithAggregatesInput | FAQAnalysisJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FAQAnalysisJob"> | string
    status?: StringWithAggregatesFilter<"FAQAnalysisJob"> | string
    tenantId?: StringNullableWithAggregatesFilter<"FAQAnalysisJob"> | string | null
    periodDays?: IntWithAggregatesFilter<"FAQAnalysisJob"> | number
    topN?: IntWithAggregatesFilter<"FAQAnalysisJob"> | number
    totalQuestions?: IntNullableWithAggregatesFilter<"FAQAnalysisJob"> | number | null
    clusterCount?: IntNullableWithAggregatesFilter<"FAQAnalysisJob"> | number | null
    llmMergeApplied?: BoolWithAggregatesFilter<"FAQAnalysisJob"> | boolean
    startedAt?: DateTimeNullableWithAggregatesFilter<"FAQAnalysisJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"FAQAnalysisJob"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"FAQAnalysisJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FAQAnalysisJob"> | Date | string
  }

  export type FAQAnalysisResultWhereInput = {
    AND?: FAQAnalysisResultWhereInput | FAQAnalysisResultWhereInput[]
    OR?: FAQAnalysisResultWhereInput[]
    NOT?: FAQAnalysisResultWhereInput | FAQAnalysisResultWhereInput[]
    id?: StringFilter<"FAQAnalysisResult"> | string
    jobId?: StringFilter<"FAQAnalysisResult"> | string
    rank?: IntFilter<"FAQAnalysisResult"> | number
    representativeQuestion?: StringFilter<"FAQAnalysisResult"> | string
    frequency?: IntFilter<"FAQAnalysisResult"> | number
    reasonAnalysis?: StringFilter<"FAQAnalysisResult"> | string
    isMerged?: BoolFilter<"FAQAnalysisResult"> | boolean
    questions?: StringFilter<"FAQAnalysisResult"> | string
    createdAt?: DateTimeFilter<"FAQAnalysisResult"> | Date | string
    job?: XOR<FAQAnalysisJobScalarRelationFilter, FAQAnalysisJobWhereInput>
  }

  export type FAQAnalysisResultOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    rank?: SortOrder
    representativeQuestion?: SortOrder
    frequency?: SortOrder
    reasonAnalysis?: SortOrder
    isMerged?: SortOrder
    questions?: SortOrder
    createdAt?: SortOrder
    job?: FAQAnalysisJobOrderByWithRelationInput
  }

  export type FAQAnalysisResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FAQAnalysisResultWhereInput | FAQAnalysisResultWhereInput[]
    OR?: FAQAnalysisResultWhereInput[]
    NOT?: FAQAnalysisResultWhereInput | FAQAnalysisResultWhereInput[]
    jobId?: StringFilter<"FAQAnalysisResult"> | string
    rank?: IntFilter<"FAQAnalysisResult"> | number
    representativeQuestion?: StringFilter<"FAQAnalysisResult"> | string
    frequency?: IntFilter<"FAQAnalysisResult"> | number
    reasonAnalysis?: StringFilter<"FAQAnalysisResult"> | string
    isMerged?: BoolFilter<"FAQAnalysisResult"> | boolean
    questions?: StringFilter<"FAQAnalysisResult"> | string
    createdAt?: DateTimeFilter<"FAQAnalysisResult"> | Date | string
    job?: XOR<FAQAnalysisJobScalarRelationFilter, FAQAnalysisJobWhereInput>
  }, "id">

  export type FAQAnalysisResultOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    rank?: SortOrder
    representativeQuestion?: SortOrder
    frequency?: SortOrder
    reasonAnalysis?: SortOrder
    isMerged?: SortOrder
    questions?: SortOrder
    createdAt?: SortOrder
    _count?: FAQAnalysisResultCountOrderByAggregateInput
    _avg?: FAQAnalysisResultAvgOrderByAggregateInput
    _max?: FAQAnalysisResultMaxOrderByAggregateInput
    _min?: FAQAnalysisResultMinOrderByAggregateInput
    _sum?: FAQAnalysisResultSumOrderByAggregateInput
  }

  export type FAQAnalysisResultScalarWhereWithAggregatesInput = {
    AND?: FAQAnalysisResultScalarWhereWithAggregatesInput | FAQAnalysisResultScalarWhereWithAggregatesInput[]
    OR?: FAQAnalysisResultScalarWhereWithAggregatesInput[]
    NOT?: FAQAnalysisResultScalarWhereWithAggregatesInput | FAQAnalysisResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FAQAnalysisResult"> | string
    jobId?: StringWithAggregatesFilter<"FAQAnalysisResult"> | string
    rank?: IntWithAggregatesFilter<"FAQAnalysisResult"> | number
    representativeQuestion?: StringWithAggregatesFilter<"FAQAnalysisResult"> | string
    frequency?: IntWithAggregatesFilter<"FAQAnalysisResult"> | number
    reasonAnalysis?: StringWithAggregatesFilter<"FAQAnalysisResult"> | string
    isMerged?: BoolWithAggregatesFilter<"FAQAnalysisResult"> | boolean
    questions?: StringWithAggregatesFilter<"FAQAnalysisResult"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FAQAnalysisResult"> | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    tenantId?: StringFilter<"UserProfile"> | string
    frustrationRate?: FloatFilter<"UserProfile"> | number
    aggressiveCount?: IntFilter<"UserProfile"> | number
    categoryDistribution?: StringFilter<"UserProfile"> | string
    behaviorSummary?: StringNullableFilter<"UserProfile"> | string | null
    mainInterests?: StringNullableFilter<"UserProfile"> | string | null
    painPoints?: StringNullableFilter<"UserProfile"> | string | null
    totalMessages?: IntFilter<"UserProfile"> | number
    analyzedMessages?: IntFilter<"UserProfile"> | number
    lastAnalyzedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    frustrationRate?: SortOrder
    aggressiveCount?: SortOrder
    categoryDistribution?: SortOrder
    behaviorSummary?: SortOrderInput | SortOrder
    mainInterests?: SortOrderInput | SortOrder
    painPoints?: SortOrderInput | SortOrder
    totalMessages?: SortOrder
    analyzedMessages?: SortOrder
    lastAnalyzedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    tenantId?: StringFilter<"UserProfile"> | string
    frustrationRate?: FloatFilter<"UserProfile"> | number
    aggressiveCount?: IntFilter<"UserProfile"> | number
    categoryDistribution?: StringFilter<"UserProfile"> | string
    behaviorSummary?: StringNullableFilter<"UserProfile"> | string | null
    mainInterests?: StringNullableFilter<"UserProfile"> | string | null
    painPoints?: StringNullableFilter<"UserProfile"> | string | null
    totalMessages?: IntFilter<"UserProfile"> | number
    analyzedMessages?: IntFilter<"UserProfile"> | number
    lastAnalyzedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    frustrationRate?: SortOrder
    aggressiveCount?: SortOrder
    categoryDistribution?: SortOrder
    behaviorSummary?: SortOrderInput | SortOrder
    mainInterests?: SortOrderInput | SortOrder
    painPoints?: SortOrderInput | SortOrder
    totalMessages?: SortOrder
    analyzedMessages?: SortOrder
    lastAnalyzedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    tenantId?: StringWithAggregatesFilter<"UserProfile"> | string
    frustrationRate?: FloatWithAggregatesFilter<"UserProfile"> | number
    aggressiveCount?: IntWithAggregatesFilter<"UserProfile"> | number
    categoryDistribution?: StringWithAggregatesFilter<"UserProfile"> | string
    behaviorSummary?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    mainInterests?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    painPoints?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    totalMessages?: IntWithAggregatesFilter<"UserProfile"> | number
    analyzedMessages?: IntWithAggregatesFilter<"UserProfile"> | number
    lastAnalyzedAt?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type MessageCategoryAnalysisWhereInput = {
    AND?: MessageCategoryAnalysisWhereInput | MessageCategoryAnalysisWhereInput[]
    OR?: MessageCategoryAnalysisWhereInput[]
    NOT?: MessageCategoryAnalysisWhereInput | MessageCategoryAnalysisWhereInput[]
    id?: StringFilter<"MessageCategoryAnalysis"> | string
    userId?: StringFilter<"MessageCategoryAnalysis"> | string
    tenantId?: StringFilter<"MessageCategoryAnalysis"> | string
    messageHash?: StringFilter<"MessageCategoryAnalysis"> | string
    category?: StringFilter<"MessageCategoryAnalysis"> | string
    confidence?: FloatFilter<"MessageCategoryAnalysis"> | number
    sentiment?: StringFilter<"MessageCategoryAnalysis"> | string
    isAggressive?: BoolFilter<"MessageCategoryAnalysis"> | boolean
    userInput?: StringFilter<"MessageCategoryAnalysis"> | string
    timestamp?: DateTimeFilter<"MessageCategoryAnalysis"> | Date | string
    createdAt?: DateTimeFilter<"MessageCategoryAnalysis"> | Date | string
  }

  export type MessageCategoryAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    messageHash?: SortOrder
    category?: SortOrder
    confidence?: SortOrder
    sentiment?: SortOrder
    isAggressive?: SortOrder
    userInput?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCategoryAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_messageHash?: MessageCategoryAnalysisUserIdMessageHashCompoundUniqueInput
    AND?: MessageCategoryAnalysisWhereInput | MessageCategoryAnalysisWhereInput[]
    OR?: MessageCategoryAnalysisWhereInput[]
    NOT?: MessageCategoryAnalysisWhereInput | MessageCategoryAnalysisWhereInput[]
    userId?: StringFilter<"MessageCategoryAnalysis"> | string
    tenantId?: StringFilter<"MessageCategoryAnalysis"> | string
    messageHash?: StringFilter<"MessageCategoryAnalysis"> | string
    category?: StringFilter<"MessageCategoryAnalysis"> | string
    confidence?: FloatFilter<"MessageCategoryAnalysis"> | number
    sentiment?: StringFilter<"MessageCategoryAnalysis"> | string
    isAggressive?: BoolFilter<"MessageCategoryAnalysis"> | boolean
    userInput?: StringFilter<"MessageCategoryAnalysis"> | string
    timestamp?: DateTimeFilter<"MessageCategoryAnalysis"> | Date | string
    createdAt?: DateTimeFilter<"MessageCategoryAnalysis"> | Date | string
  }, "id" | "userId_messageHash">

  export type MessageCategoryAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    messageHash?: SortOrder
    category?: SortOrder
    confidence?: SortOrder
    sentiment?: SortOrder
    isAggressive?: SortOrder
    userInput?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCategoryAnalysisCountOrderByAggregateInput
    _avg?: MessageCategoryAnalysisAvgOrderByAggregateInput
    _max?: MessageCategoryAnalysisMaxOrderByAggregateInput
    _min?: MessageCategoryAnalysisMinOrderByAggregateInput
    _sum?: MessageCategoryAnalysisSumOrderByAggregateInput
  }

  export type MessageCategoryAnalysisScalarWhereWithAggregatesInput = {
    AND?: MessageCategoryAnalysisScalarWhereWithAggregatesInput | MessageCategoryAnalysisScalarWhereWithAggregatesInput[]
    OR?: MessageCategoryAnalysisScalarWhereWithAggregatesInput[]
    NOT?: MessageCategoryAnalysisScalarWhereWithAggregatesInput | MessageCategoryAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageCategoryAnalysis"> | string
    userId?: StringWithAggregatesFilter<"MessageCategoryAnalysis"> | string
    tenantId?: StringWithAggregatesFilter<"MessageCategoryAnalysis"> | string
    messageHash?: StringWithAggregatesFilter<"MessageCategoryAnalysis"> | string
    category?: StringWithAggregatesFilter<"MessageCategoryAnalysis"> | string
    confidence?: FloatWithAggregatesFilter<"MessageCategoryAnalysis"> | number
    sentiment?: StringWithAggregatesFilter<"MessageCategoryAnalysis"> | string
    isAggressive?: BoolWithAggregatesFilter<"MessageCategoryAnalysis"> | boolean
    userInput?: StringWithAggregatesFilter<"MessageCategoryAnalysis"> | string
    timestamp?: DateTimeWithAggregatesFilter<"MessageCategoryAnalysis"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageCategoryAnalysis"> | Date | string
  }

  export type UserProfilingJobWhereInput = {
    AND?: UserProfilingJobWhereInput | UserProfilingJobWhereInput[]
    OR?: UserProfilingJobWhereInput[]
    NOT?: UserProfilingJobWhereInput | UserProfilingJobWhereInput[]
    id?: StringFilter<"UserProfilingJob"> | string
    status?: StringFilter<"UserProfilingJob"> | string
    targetDate?: DateTimeFilter<"UserProfilingJob"> | Date | string
    tenantId?: StringNullableFilter<"UserProfilingJob"> | string | null
    totalUsers?: IntFilter<"UserProfilingJob"> | number
    processedUsers?: IntFilter<"UserProfilingJob"> | number
    failedUsers?: IntFilter<"UserProfilingJob"> | number
    startedAt?: DateTimeNullableFilter<"UserProfilingJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"UserProfilingJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"UserProfilingJob"> | string | null
    createdAt?: DateTimeFilter<"UserProfilingJob"> | Date | string
  }

  export type UserProfilingJobOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    totalUsers?: SortOrder
    processedUsers?: SortOrder
    failedUsers?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type UserProfilingJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserProfilingJobWhereInput | UserProfilingJobWhereInput[]
    OR?: UserProfilingJobWhereInput[]
    NOT?: UserProfilingJobWhereInput | UserProfilingJobWhereInput[]
    status?: StringFilter<"UserProfilingJob"> | string
    targetDate?: DateTimeFilter<"UserProfilingJob"> | Date | string
    tenantId?: StringNullableFilter<"UserProfilingJob"> | string | null
    totalUsers?: IntFilter<"UserProfilingJob"> | number
    processedUsers?: IntFilter<"UserProfilingJob"> | number
    failedUsers?: IntFilter<"UserProfilingJob"> | number
    startedAt?: DateTimeNullableFilter<"UserProfilingJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"UserProfilingJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"UserProfilingJob"> | string | null
    createdAt?: DateTimeFilter<"UserProfilingJob"> | Date | string
  }, "id">

  export type UserProfilingJobOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    totalUsers?: SortOrder
    processedUsers?: SortOrder
    failedUsers?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserProfilingJobCountOrderByAggregateInput
    _avg?: UserProfilingJobAvgOrderByAggregateInput
    _max?: UserProfilingJobMaxOrderByAggregateInput
    _min?: UserProfilingJobMinOrderByAggregateInput
    _sum?: UserProfilingJobSumOrderByAggregateInput
  }

  export type UserProfilingJobScalarWhereWithAggregatesInput = {
    AND?: UserProfilingJobScalarWhereWithAggregatesInput | UserProfilingJobScalarWhereWithAggregatesInput[]
    OR?: UserProfilingJobScalarWhereWithAggregatesInput[]
    NOT?: UserProfilingJobScalarWhereWithAggregatesInput | UserProfilingJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfilingJob"> | string
    status?: StringWithAggregatesFilter<"UserProfilingJob"> | string
    targetDate?: DateTimeWithAggregatesFilter<"UserProfilingJob"> | Date | string
    tenantId?: StringNullableWithAggregatesFilter<"UserProfilingJob"> | string | null
    totalUsers?: IntWithAggregatesFilter<"UserProfilingJob"> | number
    processedUsers?: IntWithAggregatesFilter<"UserProfilingJob"> | number
    failedUsers?: IntWithAggregatesFilter<"UserProfilingJob"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"UserProfilingJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserProfilingJob"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"UserProfilingJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserProfilingJob"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterUncheckedCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUncheckedUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutRolePermissionsInput
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedFilterCreateInput = {
    id?: string
    name: string
    description?: string | null
    criteria: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSavedFiltersInput
  }

  export type SavedFilterUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    criteria: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedFilterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedFiltersNestedInput
  }

  export type SavedFilterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedFilterCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    criteria: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedFilterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedFilterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisSessionCreateInput = {
    id?: string
    title: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAnalysisSessionsInput
    messages?: AnalysisMessageCreateNestedManyWithoutSessionInput
  }

  export type AnalysisSessionUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: AnalysisMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AnalysisSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnalysisSessionsNestedInput
    messages?: AnalysisMessageUpdateManyWithoutSessionNestedInput
  }

  export type AnalysisSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AnalysisMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AnalysisSessionCreateManyInput = {
    id?: string
    userId: string
    title: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisMessageCreateInput = {
    id?: string
    role: string
    content: string
    metadata?: string | null
    createdAt?: Date | string
    session: AnalysisSessionCreateNestedOneWithoutMessagesInput
  }

  export type AnalysisMessageUncheckedCreateInput = {
    id?: string
    sessionId: string
    role: string
    content: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type AnalysisMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: AnalysisSessionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type AnalysisMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisMessageCreateManyInput = {
    id?: string
    sessionId: string
    role: string
    content: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type AnalysisMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    name: string
    key: string
    permissions: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    key: string
    permissions: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    userId: string
    name: string
    key: string
    permissions: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BatchAnalysisJobCreateInput = {
    id?: string
    status: string
    targetDate: Date | string
    tenantId?: string | null
    sampleSize?: number
    promptTemplate: string
    totalItems?: number
    processedItems?: number
    failedItems?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    cancelRequested?: boolean
    createdAt?: Date | string
    results?: BatchAnalysisResultCreateNestedManyWithoutJobInput
  }

  export type BatchAnalysisJobUncheckedCreateInput = {
    id?: string
    status: string
    targetDate: Date | string
    tenantId?: string | null
    sampleSize?: number
    promptTemplate: string
    totalItems?: number
    processedItems?: number
    failedItems?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    cancelRequested?: boolean
    createdAt?: Date | string
    results?: BatchAnalysisResultUncheckedCreateNestedManyWithoutJobInput
  }

  export type BatchAnalysisJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    promptTemplate?: StringFieldUpdateOperationsInput | string
    totalItems?: IntFieldUpdateOperationsInput | number
    processedItems?: IntFieldUpdateOperationsInput | number
    failedItems?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancelRequested?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: BatchAnalysisResultUpdateManyWithoutJobNestedInput
  }

  export type BatchAnalysisJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    promptTemplate?: StringFieldUpdateOperationsInput | string
    totalItems?: IntFieldUpdateOperationsInput | number
    processedItems?: IntFieldUpdateOperationsInput | number
    failedItems?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancelRequested?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: BatchAnalysisResultUncheckedUpdateManyWithoutJobNestedInput
  }

  export type BatchAnalysisJobCreateManyInput = {
    id?: string
    status: string
    targetDate: Date | string
    tenantId?: string | null
    sampleSize?: number
    promptTemplate: string
    totalItems?: number
    processedItems?: number
    failedItems?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    cancelRequested?: boolean
    createdAt?: Date | string
  }

  export type BatchAnalysisJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    promptTemplate?: StringFieldUpdateOperationsInput | string
    totalItems?: IntFieldUpdateOperationsInput | number
    processedItems?: IntFieldUpdateOperationsInput | number
    failedItems?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancelRequested?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchAnalysisJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    promptTemplate?: StringFieldUpdateOperationsInput | string
    totalItems?: IntFieldUpdateOperationsInput | number
    processedItems?: IntFieldUpdateOperationsInput | number
    failedItems?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancelRequested?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchAnalysisResultCreateInput = {
    id?: string
    originalTimestamp: Date | string
    tenantId: string
    sessionId?: string | null
    userInput: string
    llmResponse: string
    analysisPrompt: string
    analysisResult: string
    modelName: string
    latencyMs: number
    inputTokens?: number
    outputTokens?: number
    qualityScore?: number | null
    relevance?: number | null
    completeness?: number | null
    clarity?: number | null
    sentiment?: string | null
    summaryText?: string | null
    issues?: string | null
    improvements?: string | null
    missingData?: string | null
    issueCount?: number | null
    avgScore?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
    job: BatchAnalysisJobCreateNestedOneWithoutResultsInput
  }

  export type BatchAnalysisResultUncheckedCreateInput = {
    id?: string
    jobId: string
    originalTimestamp: Date | string
    tenantId: string
    sessionId?: string | null
    userInput: string
    llmResponse: string
    analysisPrompt: string
    analysisResult: string
    modelName: string
    latencyMs: number
    inputTokens?: number
    outputTokens?: number
    qualityScore?: number | null
    relevance?: number | null
    completeness?: number | null
    clarity?: number | null
    sentiment?: string | null
    summaryText?: string | null
    issues?: string | null
    improvements?: string | null
    missingData?: string | null
    issueCount?: number | null
    avgScore?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type BatchAnalysisResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userInput?: StringFieldUpdateOperationsInput | string
    llmResponse?: StringFieldUpdateOperationsInput | string
    analysisPrompt?: StringFieldUpdateOperationsInput | string
    analysisResult?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    latencyMs?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relevance?: NullableIntFieldUpdateOperationsInput | number | null
    completeness?: NullableIntFieldUpdateOperationsInput | number | null
    clarity?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    summaryText?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    missingData?: NullableStringFieldUpdateOperationsInput | string | null
    issueCount?: NullableIntFieldUpdateOperationsInput | number | null
    avgScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: BatchAnalysisJobUpdateOneRequiredWithoutResultsNestedInput
  }

  export type BatchAnalysisResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    originalTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userInput?: StringFieldUpdateOperationsInput | string
    llmResponse?: StringFieldUpdateOperationsInput | string
    analysisPrompt?: StringFieldUpdateOperationsInput | string
    analysisResult?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    latencyMs?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relevance?: NullableIntFieldUpdateOperationsInput | number | null
    completeness?: NullableIntFieldUpdateOperationsInput | number | null
    clarity?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    summaryText?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    missingData?: NullableStringFieldUpdateOperationsInput | string | null
    issueCount?: NullableIntFieldUpdateOperationsInput | number | null
    avgScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchAnalysisResultCreateManyInput = {
    id?: string
    jobId: string
    originalTimestamp: Date | string
    tenantId: string
    sessionId?: string | null
    userInput: string
    llmResponse: string
    analysisPrompt: string
    analysisResult: string
    modelName: string
    latencyMs: number
    inputTokens?: number
    outputTokens?: number
    qualityScore?: number | null
    relevance?: number | null
    completeness?: number | null
    clarity?: number | null
    sentiment?: string | null
    summaryText?: string | null
    issues?: string | null
    improvements?: string | null
    missingData?: string | null
    issueCount?: number | null
    avgScore?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type BatchAnalysisResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userInput?: StringFieldUpdateOperationsInput | string
    llmResponse?: StringFieldUpdateOperationsInput | string
    analysisPrompt?: StringFieldUpdateOperationsInput | string
    analysisResult?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    latencyMs?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relevance?: NullableIntFieldUpdateOperationsInput | number | null
    completeness?: NullableIntFieldUpdateOperationsInput | number | null
    clarity?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    summaryText?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    missingData?: NullableStringFieldUpdateOperationsInput | string | null
    issueCount?: NullableIntFieldUpdateOperationsInput | number | null
    avgScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchAnalysisResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    originalTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userInput?: StringFieldUpdateOperationsInput | string
    llmResponse?: StringFieldUpdateOperationsInput | string
    analysisPrompt?: StringFieldUpdateOperationsInput | string
    analysisResult?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    latencyMs?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relevance?: NullableIntFieldUpdateOperationsInput | number | null
    completeness?: NullableIntFieldUpdateOperationsInput | number | null
    clarity?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    summaryText?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    missingData?: NullableStringFieldUpdateOperationsInput | string | null
    issueCount?: NullableIntFieldUpdateOperationsInput | number | null
    avgScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisPromptTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    prompt: string
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisPromptTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    prompt: string
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisPromptTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisPromptTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisPromptTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    prompt: string
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisPromptTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisPromptTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchSchedulerConfigCreateInput = {
    id?: string
    name: string
    isEnabled?: boolean
    hour?: number
    minute?: number
    daysOfWeek?: string
    timeZone?: string
    targetTenantId?: string | null
    sampleSize?: number
    promptTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchSchedulerConfigUncheckedCreateInput = {
    id?: string
    name: string
    isEnabled?: boolean
    hour?: number
    minute?: number
    daysOfWeek?: string
    timeZone?: string
    targetTenantId?: string | null
    sampleSize?: number
    promptTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchSchedulerConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    hour?: IntFieldUpdateOperationsInput | number
    minute?: IntFieldUpdateOperationsInput | number
    daysOfWeek?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    targetTenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    promptTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchSchedulerConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    hour?: IntFieldUpdateOperationsInput | number
    minute?: IntFieldUpdateOperationsInput | number
    daysOfWeek?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    targetTenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    promptTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchSchedulerConfigCreateManyInput = {
    id?: string
    name: string
    isEnabled?: boolean
    hour?: number
    minute?: number
    daysOfWeek?: string
    timeZone?: string
    targetTenantId?: string | null
    sampleSize?: number
    promptTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchSchedulerConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    hour?: IntFieldUpdateOperationsInput | number
    minute?: IntFieldUpdateOperationsInput | number
    daysOfWeek?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    targetTenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    promptTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchSchedulerConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    hour?: IntFieldUpdateOperationsInput | number
    minute?: IntFieldUpdateOperationsInput | number
    daysOfWeek?: StringFieldUpdateOperationsInput | string
    timeZone?: StringFieldUpdateOperationsInput | string
    targetTenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    promptTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQAnalysisJobCreateInput = {
    id?: string
    status?: string
    tenantId?: string | null
    periodDays?: number
    topN?: number
    totalQuestions?: number | null
    clusterCount?: number | null
    llmMergeApplied?: boolean
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    results?: FAQAnalysisResultCreateNestedManyWithoutJobInput
  }

  export type FAQAnalysisJobUncheckedCreateInput = {
    id?: string
    status?: string
    tenantId?: string | null
    periodDays?: number
    topN?: number
    totalQuestions?: number | null
    clusterCount?: number | null
    llmMergeApplied?: boolean
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    results?: FAQAnalysisResultUncheckedCreateNestedManyWithoutJobInput
  }

  export type FAQAnalysisJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    periodDays?: IntFieldUpdateOperationsInput | number
    topN?: IntFieldUpdateOperationsInput | number
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    clusterCount?: NullableIntFieldUpdateOperationsInput | number | null
    llmMergeApplied?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: FAQAnalysisResultUpdateManyWithoutJobNestedInput
  }

  export type FAQAnalysisJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    periodDays?: IntFieldUpdateOperationsInput | number
    topN?: IntFieldUpdateOperationsInput | number
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    clusterCount?: NullableIntFieldUpdateOperationsInput | number | null
    llmMergeApplied?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: FAQAnalysisResultUncheckedUpdateManyWithoutJobNestedInput
  }

  export type FAQAnalysisJobCreateManyInput = {
    id?: string
    status?: string
    tenantId?: string | null
    periodDays?: number
    topN?: number
    totalQuestions?: number | null
    clusterCount?: number | null
    llmMergeApplied?: boolean
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type FAQAnalysisJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    periodDays?: IntFieldUpdateOperationsInput | number
    topN?: IntFieldUpdateOperationsInput | number
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    clusterCount?: NullableIntFieldUpdateOperationsInput | number | null
    llmMergeApplied?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQAnalysisJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    periodDays?: IntFieldUpdateOperationsInput | number
    topN?: IntFieldUpdateOperationsInput | number
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    clusterCount?: NullableIntFieldUpdateOperationsInput | number | null
    llmMergeApplied?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQAnalysisResultCreateInput = {
    id?: string
    rank: number
    representativeQuestion: string
    frequency: number
    reasonAnalysis: string
    isMerged?: boolean
    questions: string
    createdAt?: Date | string
    job: FAQAnalysisJobCreateNestedOneWithoutResultsInput
  }

  export type FAQAnalysisResultUncheckedCreateInput = {
    id?: string
    jobId: string
    rank: number
    representativeQuestion: string
    frequency: number
    reasonAnalysis: string
    isMerged?: boolean
    questions: string
    createdAt?: Date | string
  }

  export type FAQAnalysisResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    representativeQuestion?: StringFieldUpdateOperationsInput | string
    frequency?: IntFieldUpdateOperationsInput | number
    reasonAnalysis?: StringFieldUpdateOperationsInput | string
    isMerged?: BoolFieldUpdateOperationsInput | boolean
    questions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: FAQAnalysisJobUpdateOneRequiredWithoutResultsNestedInput
  }

  export type FAQAnalysisResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    representativeQuestion?: StringFieldUpdateOperationsInput | string
    frequency?: IntFieldUpdateOperationsInput | number
    reasonAnalysis?: StringFieldUpdateOperationsInput | string
    isMerged?: BoolFieldUpdateOperationsInput | boolean
    questions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQAnalysisResultCreateManyInput = {
    id?: string
    jobId: string
    rank: number
    representativeQuestion: string
    frequency: number
    reasonAnalysis: string
    isMerged?: boolean
    questions: string
    createdAt?: Date | string
  }

  export type FAQAnalysisResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    representativeQuestion?: StringFieldUpdateOperationsInput | string
    frequency?: IntFieldUpdateOperationsInput | number
    reasonAnalysis?: StringFieldUpdateOperationsInput | string
    isMerged?: BoolFieldUpdateOperationsInput | boolean
    questions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQAnalysisResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    representativeQuestion?: StringFieldUpdateOperationsInput | string
    frequency?: IntFieldUpdateOperationsInput | number
    reasonAnalysis?: StringFieldUpdateOperationsInput | string
    isMerged?: BoolFieldUpdateOperationsInput | boolean
    questions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    userId: string
    tenantId: string
    frustrationRate?: number
    aggressiveCount?: number
    categoryDistribution?: string
    behaviorSummary?: string | null
    mainInterests?: string | null
    painPoints?: string | null
    totalMessages?: number
    analyzedMessages?: number
    lastAnalyzedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    userId: string
    tenantId: string
    frustrationRate?: number
    aggressiveCount?: number
    categoryDistribution?: string
    behaviorSummary?: string | null
    mainInterests?: string | null
    painPoints?: string | null
    totalMessages?: number
    analyzedMessages?: number
    lastAnalyzedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    frustrationRate?: FloatFieldUpdateOperationsInput | number
    aggressiveCount?: IntFieldUpdateOperationsInput | number
    categoryDistribution?: StringFieldUpdateOperationsInput | string
    behaviorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    mainInterests?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    analyzedMessages?: IntFieldUpdateOperationsInput | number
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    frustrationRate?: FloatFieldUpdateOperationsInput | number
    aggressiveCount?: IntFieldUpdateOperationsInput | number
    categoryDistribution?: StringFieldUpdateOperationsInput | string
    behaviorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    mainInterests?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    analyzedMessages?: IntFieldUpdateOperationsInput | number
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateManyInput = {
    id?: string
    userId: string
    tenantId: string
    frustrationRate?: number
    aggressiveCount?: number
    categoryDistribution?: string
    behaviorSummary?: string | null
    mainInterests?: string | null
    painPoints?: string | null
    totalMessages?: number
    analyzedMessages?: number
    lastAnalyzedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    frustrationRate?: FloatFieldUpdateOperationsInput | number
    aggressiveCount?: IntFieldUpdateOperationsInput | number
    categoryDistribution?: StringFieldUpdateOperationsInput | string
    behaviorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    mainInterests?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    analyzedMessages?: IntFieldUpdateOperationsInput | number
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    frustrationRate?: FloatFieldUpdateOperationsInput | number
    aggressiveCount?: IntFieldUpdateOperationsInput | number
    categoryDistribution?: StringFieldUpdateOperationsInput | string
    behaviorSummary?: NullableStringFieldUpdateOperationsInput | string | null
    mainInterests?: NullableStringFieldUpdateOperationsInput | string | null
    painPoints?: NullableStringFieldUpdateOperationsInput | string | null
    totalMessages?: IntFieldUpdateOperationsInput | number
    analyzedMessages?: IntFieldUpdateOperationsInput | number
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCategoryAnalysisCreateInput = {
    id?: string
    userId: string
    tenantId: string
    messageHash: string
    category: string
    confidence?: number
    sentiment?: string
    isAggressive?: boolean
    userInput: string
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type MessageCategoryAnalysisUncheckedCreateInput = {
    id?: string
    userId: string
    tenantId: string
    messageHash: string
    category: string
    confidence?: number
    sentiment?: string
    isAggressive?: boolean
    userInput: string
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type MessageCategoryAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    messageHash?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    sentiment?: StringFieldUpdateOperationsInput | string
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    userInput?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCategoryAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    messageHash?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    sentiment?: StringFieldUpdateOperationsInput | string
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    userInput?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCategoryAnalysisCreateManyInput = {
    id?: string
    userId: string
    tenantId: string
    messageHash: string
    category: string
    confidence?: number
    sentiment?: string
    isAggressive?: boolean
    userInput: string
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type MessageCategoryAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    messageHash?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    sentiment?: StringFieldUpdateOperationsInput | string
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    userInput?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCategoryAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    messageHash?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    sentiment?: StringFieldUpdateOperationsInput | string
    isAggressive?: BoolFieldUpdateOperationsInput | boolean
    userInput?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfilingJobCreateInput = {
    id?: string
    status?: string
    targetDate: Date | string
    tenantId?: string | null
    totalUsers?: number
    processedUsers?: number
    failedUsers?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type UserProfilingJobUncheckedCreateInput = {
    id?: string
    status?: string
    targetDate: Date | string
    tenantId?: string | null
    totalUsers?: number
    processedUsers?: number
    failedUsers?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type UserProfilingJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    totalUsers?: IntFieldUpdateOperationsInput | number
    processedUsers?: IntFieldUpdateOperationsInput | number
    failedUsers?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfilingJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    totalUsers?: IntFieldUpdateOperationsInput | number
    processedUsers?: IntFieldUpdateOperationsInput | number
    failedUsers?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfilingJobCreateManyInput = {
    id?: string
    status?: string
    targetDate: Date | string
    tenantId?: string | null
    totalUsers?: number
    processedUsers?: number
    failedUsers?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type UserProfilingJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    totalUsers?: IntFieldUpdateOperationsInput | number
    processedUsers?: IntFieldUpdateOperationsInput | number
    failedUsers?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfilingJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    totalUsers?: IntFieldUpdateOperationsInput | number
    processedUsers?: IntFieldUpdateOperationsInput | number
    failedUsers?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type SavedFilterListRelationFilter = {
    every?: SavedFilterWhereInput
    some?: SavedFilterWhereInput
    none?: SavedFilterWhereInput
  }

  export type AnalysisSessionListRelationFilter = {
    every?: AnalysisSessionWhereInput
    some?: AnalysisSessionWhereInput
    none?: AnalysisSessionWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedFilterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalysisSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    failedAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    failedAttempts?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type SavedFilterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    criteria?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedFilterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    criteria?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedFilterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    criteria?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisMessageListRelationFilter = {
    every?: AnalysisMessageWhereInput
    some?: AnalysisMessageWhereInput
    none?: AnalysisMessageWhereInput
  }

  export type AnalysisMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalysisSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisSessionScalarRelationFilter = {
    is?: AnalysisSessionWhereInput
    isNot?: AnalysisSessionWhereInput
  }

  export type AnalysisMessageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalysisMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalysisMessageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    key?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type BatchAnalysisResultListRelationFilter = {
    every?: BatchAnalysisResultWhereInput
    some?: BatchAnalysisResultWhereInput
    none?: BatchAnalysisResultWhereInput
  }

  export type BatchAnalysisResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchAnalysisJobCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    tenantId?: SortOrder
    sampleSize?: SortOrder
    promptTemplate?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    failedItems?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    cancelRequested?: SortOrder
    createdAt?: SortOrder
  }

  export type BatchAnalysisJobAvgOrderByAggregateInput = {
    sampleSize?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    failedItems?: SortOrder
  }

  export type BatchAnalysisJobMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    tenantId?: SortOrder
    sampleSize?: SortOrder
    promptTemplate?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    failedItems?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    cancelRequested?: SortOrder
    createdAt?: SortOrder
  }

  export type BatchAnalysisJobMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    tenantId?: SortOrder
    sampleSize?: SortOrder
    promptTemplate?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    failedItems?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    cancelRequested?: SortOrder
    createdAt?: SortOrder
  }

  export type BatchAnalysisJobSumOrderByAggregateInput = {
    sampleSize?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    failedItems?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BatchAnalysisJobScalarRelationFilter = {
    is?: BatchAnalysisJobWhereInput
    isNot?: BatchAnalysisJobWhereInput
  }

  export type BatchAnalysisResultCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    originalTimestamp?: SortOrder
    tenantId?: SortOrder
    sessionId?: SortOrder
    userInput?: SortOrder
    llmResponse?: SortOrder
    analysisPrompt?: SortOrder
    analysisResult?: SortOrder
    modelName?: SortOrder
    latencyMs?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    qualityScore?: SortOrder
    relevance?: SortOrder
    completeness?: SortOrder
    clarity?: SortOrder
    sentiment?: SortOrder
    summaryText?: SortOrder
    issues?: SortOrder
    improvements?: SortOrder
    missingData?: SortOrder
    issueCount?: SortOrder
    avgScore?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type BatchAnalysisResultAvgOrderByAggregateInput = {
    latencyMs?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    qualityScore?: SortOrder
    relevance?: SortOrder
    completeness?: SortOrder
    clarity?: SortOrder
    issueCount?: SortOrder
    avgScore?: SortOrder
  }

  export type BatchAnalysisResultMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    originalTimestamp?: SortOrder
    tenantId?: SortOrder
    sessionId?: SortOrder
    userInput?: SortOrder
    llmResponse?: SortOrder
    analysisPrompt?: SortOrder
    analysisResult?: SortOrder
    modelName?: SortOrder
    latencyMs?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    qualityScore?: SortOrder
    relevance?: SortOrder
    completeness?: SortOrder
    clarity?: SortOrder
    sentiment?: SortOrder
    summaryText?: SortOrder
    issues?: SortOrder
    improvements?: SortOrder
    missingData?: SortOrder
    issueCount?: SortOrder
    avgScore?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type BatchAnalysisResultMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    originalTimestamp?: SortOrder
    tenantId?: SortOrder
    sessionId?: SortOrder
    userInput?: SortOrder
    llmResponse?: SortOrder
    analysisPrompt?: SortOrder
    analysisResult?: SortOrder
    modelName?: SortOrder
    latencyMs?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    qualityScore?: SortOrder
    relevance?: SortOrder
    completeness?: SortOrder
    clarity?: SortOrder
    sentiment?: SortOrder
    summaryText?: SortOrder
    issues?: SortOrder
    improvements?: SortOrder
    missingData?: SortOrder
    issueCount?: SortOrder
    avgScore?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type BatchAnalysisResultSumOrderByAggregateInput = {
    latencyMs?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    qualityScore?: SortOrder
    relevance?: SortOrder
    completeness?: SortOrder
    clarity?: SortOrder
    issueCount?: SortOrder
    avgScore?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AnalysisPromptTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    prompt?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisPromptTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    prompt?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisPromptTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    prompt?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchSchedulerConfigCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    hour?: SortOrder
    minute?: SortOrder
    daysOfWeek?: SortOrder
    timeZone?: SortOrder
    targetTenantId?: SortOrder
    sampleSize?: SortOrder
    promptTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchSchedulerConfigAvgOrderByAggregateInput = {
    hour?: SortOrder
    minute?: SortOrder
    sampleSize?: SortOrder
  }

  export type BatchSchedulerConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    hour?: SortOrder
    minute?: SortOrder
    daysOfWeek?: SortOrder
    timeZone?: SortOrder
    targetTenantId?: SortOrder
    sampleSize?: SortOrder
    promptTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchSchedulerConfigMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    hour?: SortOrder
    minute?: SortOrder
    daysOfWeek?: SortOrder
    timeZone?: SortOrder
    targetTenantId?: SortOrder
    sampleSize?: SortOrder
    promptTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchSchedulerConfigSumOrderByAggregateInput = {
    hour?: SortOrder
    minute?: SortOrder
    sampleSize?: SortOrder
  }

  export type FAQAnalysisResultListRelationFilter = {
    every?: FAQAnalysisResultWhereInput
    some?: FAQAnalysisResultWhereInput
    none?: FAQAnalysisResultWhereInput
  }

  export type FAQAnalysisResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FAQAnalysisJobCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    periodDays?: SortOrder
    topN?: SortOrder
    totalQuestions?: SortOrder
    clusterCount?: SortOrder
    llmMergeApplied?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type FAQAnalysisJobAvgOrderByAggregateInput = {
    periodDays?: SortOrder
    topN?: SortOrder
    totalQuestions?: SortOrder
    clusterCount?: SortOrder
  }

  export type FAQAnalysisJobMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    periodDays?: SortOrder
    topN?: SortOrder
    totalQuestions?: SortOrder
    clusterCount?: SortOrder
    llmMergeApplied?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type FAQAnalysisJobMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    periodDays?: SortOrder
    topN?: SortOrder
    totalQuestions?: SortOrder
    clusterCount?: SortOrder
    llmMergeApplied?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type FAQAnalysisJobSumOrderByAggregateInput = {
    periodDays?: SortOrder
    topN?: SortOrder
    totalQuestions?: SortOrder
    clusterCount?: SortOrder
  }

  export type FAQAnalysisJobScalarRelationFilter = {
    is?: FAQAnalysisJobWhereInput
    isNot?: FAQAnalysisJobWhereInput
  }

  export type FAQAnalysisResultCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    rank?: SortOrder
    representativeQuestion?: SortOrder
    frequency?: SortOrder
    reasonAnalysis?: SortOrder
    isMerged?: SortOrder
    questions?: SortOrder
    createdAt?: SortOrder
  }

  export type FAQAnalysisResultAvgOrderByAggregateInput = {
    rank?: SortOrder
    frequency?: SortOrder
  }

  export type FAQAnalysisResultMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    rank?: SortOrder
    representativeQuestion?: SortOrder
    frequency?: SortOrder
    reasonAnalysis?: SortOrder
    isMerged?: SortOrder
    questions?: SortOrder
    createdAt?: SortOrder
  }

  export type FAQAnalysisResultMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    rank?: SortOrder
    representativeQuestion?: SortOrder
    frequency?: SortOrder
    reasonAnalysis?: SortOrder
    isMerged?: SortOrder
    questions?: SortOrder
    createdAt?: SortOrder
  }

  export type FAQAnalysisResultSumOrderByAggregateInput = {
    rank?: SortOrder
    frequency?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    frustrationRate?: SortOrder
    aggressiveCount?: SortOrder
    categoryDistribution?: SortOrder
    behaviorSummary?: SortOrder
    mainInterests?: SortOrder
    painPoints?: SortOrder
    totalMessages?: SortOrder
    analyzedMessages?: SortOrder
    lastAnalyzedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    frustrationRate?: SortOrder
    aggressiveCount?: SortOrder
    totalMessages?: SortOrder
    analyzedMessages?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    frustrationRate?: SortOrder
    aggressiveCount?: SortOrder
    categoryDistribution?: SortOrder
    behaviorSummary?: SortOrder
    mainInterests?: SortOrder
    painPoints?: SortOrder
    totalMessages?: SortOrder
    analyzedMessages?: SortOrder
    lastAnalyzedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    frustrationRate?: SortOrder
    aggressiveCount?: SortOrder
    categoryDistribution?: SortOrder
    behaviorSummary?: SortOrder
    mainInterests?: SortOrder
    painPoints?: SortOrder
    totalMessages?: SortOrder
    analyzedMessages?: SortOrder
    lastAnalyzedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    frustrationRate?: SortOrder
    aggressiveCount?: SortOrder
    totalMessages?: SortOrder
    analyzedMessages?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type MessageCategoryAnalysisUserIdMessageHashCompoundUniqueInput = {
    userId: string
    messageHash: string
  }

  export type MessageCategoryAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    messageHash?: SortOrder
    category?: SortOrder
    confidence?: SortOrder
    sentiment?: SortOrder
    isAggressive?: SortOrder
    userInput?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCategoryAnalysisAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type MessageCategoryAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    messageHash?: SortOrder
    category?: SortOrder
    confidence?: SortOrder
    sentiment?: SortOrder
    isAggressive?: SortOrder
    userInput?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCategoryAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    messageHash?: SortOrder
    category?: SortOrder
    confidence?: SortOrder
    sentiment?: SortOrder
    isAggressive?: SortOrder
    userInput?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCategoryAnalysisSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type UserProfilingJobCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    tenantId?: SortOrder
    totalUsers?: SortOrder
    processedUsers?: SortOrder
    failedUsers?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type UserProfilingJobAvgOrderByAggregateInput = {
    totalUsers?: SortOrder
    processedUsers?: SortOrder
    failedUsers?: SortOrder
  }

  export type UserProfilingJobMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    tenantId?: SortOrder
    totalUsers?: SortOrder
    processedUsers?: SortOrder
    failedUsers?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type UserProfilingJobMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    targetDate?: SortOrder
    tenantId?: SortOrder
    totalUsers?: SortOrder
    processedUsers?: SortOrder
    failedUsers?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type UserProfilingJobSumOrderByAggregateInput = {
    totalUsers?: SortOrder
    processedUsers?: SortOrder
    failedUsers?: SortOrder
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type SavedFilterCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedFilterCreateWithoutUserInput, SavedFilterUncheckedCreateWithoutUserInput> | SavedFilterCreateWithoutUserInput[] | SavedFilterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedFilterCreateOrConnectWithoutUserInput | SavedFilterCreateOrConnectWithoutUserInput[]
    createMany?: SavedFilterCreateManyUserInputEnvelope
    connect?: SavedFilterWhereUniqueInput | SavedFilterWhereUniqueInput[]
  }

  export type AnalysisSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalysisSessionCreateWithoutUserInput, AnalysisSessionUncheckedCreateWithoutUserInput> | AnalysisSessionCreateWithoutUserInput[] | AnalysisSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisSessionCreateOrConnectWithoutUserInput | AnalysisSessionCreateOrConnectWithoutUserInput[]
    createMany?: AnalysisSessionCreateManyUserInputEnvelope
    connect?: AnalysisSessionWhereUniqueInput | AnalysisSessionWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type SavedFilterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedFilterCreateWithoutUserInput, SavedFilterUncheckedCreateWithoutUserInput> | SavedFilterCreateWithoutUserInput[] | SavedFilterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedFilterCreateOrConnectWithoutUserInput | SavedFilterCreateOrConnectWithoutUserInput[]
    createMany?: SavedFilterCreateManyUserInputEnvelope
    connect?: SavedFilterWhereUniqueInput | SavedFilterWhereUniqueInput[]
  }

  export type AnalysisSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AnalysisSessionCreateWithoutUserInput, AnalysisSessionUncheckedCreateWithoutUserInput> | AnalysisSessionCreateWithoutUserInput[] | AnalysisSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisSessionCreateOrConnectWithoutUserInput | AnalysisSessionCreateOrConnectWithoutUserInput[]
    createMany?: AnalysisSessionCreateManyUserInputEnvelope
    connect?: AnalysisSessionWhereUniqueInput | AnalysisSessionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type SavedFilterUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedFilterCreateWithoutUserInput, SavedFilterUncheckedCreateWithoutUserInput> | SavedFilterCreateWithoutUserInput[] | SavedFilterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedFilterCreateOrConnectWithoutUserInput | SavedFilterCreateOrConnectWithoutUserInput[]
    upsert?: SavedFilterUpsertWithWhereUniqueWithoutUserInput | SavedFilterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedFilterCreateManyUserInputEnvelope
    set?: SavedFilterWhereUniqueInput | SavedFilterWhereUniqueInput[]
    disconnect?: SavedFilterWhereUniqueInput | SavedFilterWhereUniqueInput[]
    delete?: SavedFilterWhereUniqueInput | SavedFilterWhereUniqueInput[]
    connect?: SavedFilterWhereUniqueInput | SavedFilterWhereUniqueInput[]
    update?: SavedFilterUpdateWithWhereUniqueWithoutUserInput | SavedFilterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedFilterUpdateManyWithWhereWithoutUserInput | SavedFilterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedFilterScalarWhereInput | SavedFilterScalarWhereInput[]
  }

  export type AnalysisSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalysisSessionCreateWithoutUserInput, AnalysisSessionUncheckedCreateWithoutUserInput> | AnalysisSessionCreateWithoutUserInput[] | AnalysisSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisSessionCreateOrConnectWithoutUserInput | AnalysisSessionCreateOrConnectWithoutUserInput[]
    upsert?: AnalysisSessionUpsertWithWhereUniqueWithoutUserInput | AnalysisSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalysisSessionCreateManyUserInputEnvelope
    set?: AnalysisSessionWhereUniqueInput | AnalysisSessionWhereUniqueInput[]
    disconnect?: AnalysisSessionWhereUniqueInput | AnalysisSessionWhereUniqueInput[]
    delete?: AnalysisSessionWhereUniqueInput | AnalysisSessionWhereUniqueInput[]
    connect?: AnalysisSessionWhereUniqueInput | AnalysisSessionWhereUniqueInput[]
    update?: AnalysisSessionUpdateWithWhereUniqueWithoutUserInput | AnalysisSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalysisSessionUpdateManyWithWhereWithoutUserInput | AnalysisSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalysisSessionScalarWhereInput | AnalysisSessionScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type SavedFilterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedFilterCreateWithoutUserInput, SavedFilterUncheckedCreateWithoutUserInput> | SavedFilterCreateWithoutUserInput[] | SavedFilterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedFilterCreateOrConnectWithoutUserInput | SavedFilterCreateOrConnectWithoutUserInput[]
    upsert?: SavedFilterUpsertWithWhereUniqueWithoutUserInput | SavedFilterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedFilterCreateManyUserInputEnvelope
    set?: SavedFilterWhereUniqueInput | SavedFilterWhereUniqueInput[]
    disconnect?: SavedFilterWhereUniqueInput | SavedFilterWhereUniqueInput[]
    delete?: SavedFilterWhereUniqueInput | SavedFilterWhereUniqueInput[]
    connect?: SavedFilterWhereUniqueInput | SavedFilterWhereUniqueInput[]
    update?: SavedFilterUpdateWithWhereUniqueWithoutUserInput | SavedFilterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedFilterUpdateManyWithWhereWithoutUserInput | SavedFilterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedFilterScalarWhereInput | SavedFilterScalarWhereInput[]
  }

  export type AnalysisSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AnalysisSessionCreateWithoutUserInput, AnalysisSessionUncheckedCreateWithoutUserInput> | AnalysisSessionCreateWithoutUserInput[] | AnalysisSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AnalysisSessionCreateOrConnectWithoutUserInput | AnalysisSessionCreateOrConnectWithoutUserInput[]
    upsert?: AnalysisSessionUpsertWithWhereUniqueWithoutUserInput | AnalysisSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AnalysisSessionCreateManyUserInputEnvelope
    set?: AnalysisSessionWhereUniqueInput | AnalysisSessionWhereUniqueInput[]
    disconnect?: AnalysisSessionWhereUniqueInput | AnalysisSessionWhereUniqueInput[]
    delete?: AnalysisSessionWhereUniqueInput | AnalysisSessionWhereUniqueInput[]
    connect?: AnalysisSessionWhereUniqueInput | AnalysisSessionWhereUniqueInput[]
    update?: AnalysisSessionUpdateWithWhereUniqueWithoutUserInput | AnalysisSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AnalysisSessionUpdateManyWithWhereWithoutUserInput | AnalysisSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AnalysisSessionScalarWhereInput | AnalysisSessionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    upsert?: RoleUpsertWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRolePermissionsInput, RoleUpdateWithoutRolePermissionsInput>, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionUpsertWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionUpdateWithoutRolePermissionsInput>, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutSavedFiltersInput = {
    create?: XOR<UserCreateWithoutSavedFiltersInput, UserUncheckedCreateWithoutSavedFiltersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedFiltersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSavedFiltersNestedInput = {
    create?: XOR<UserCreateWithoutSavedFiltersInput, UserUncheckedCreateWithoutSavedFiltersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedFiltersInput
    upsert?: UserUpsertWithoutSavedFiltersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedFiltersInput, UserUpdateWithoutSavedFiltersInput>, UserUncheckedUpdateWithoutSavedFiltersInput>
  }

  export type UserCreateNestedOneWithoutAnalysisSessionsInput = {
    create?: XOR<UserCreateWithoutAnalysisSessionsInput, UserUncheckedCreateWithoutAnalysisSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalysisSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type AnalysisMessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<AnalysisMessageCreateWithoutSessionInput, AnalysisMessageUncheckedCreateWithoutSessionInput> | AnalysisMessageCreateWithoutSessionInput[] | AnalysisMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AnalysisMessageCreateOrConnectWithoutSessionInput | AnalysisMessageCreateOrConnectWithoutSessionInput[]
    createMany?: AnalysisMessageCreateManySessionInputEnvelope
    connect?: AnalysisMessageWhereUniqueInput | AnalysisMessageWhereUniqueInput[]
  }

  export type AnalysisMessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AnalysisMessageCreateWithoutSessionInput, AnalysisMessageUncheckedCreateWithoutSessionInput> | AnalysisMessageCreateWithoutSessionInput[] | AnalysisMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AnalysisMessageCreateOrConnectWithoutSessionInput | AnalysisMessageCreateOrConnectWithoutSessionInput[]
    createMany?: AnalysisMessageCreateManySessionInputEnvelope
    connect?: AnalysisMessageWhereUniqueInput | AnalysisMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAnalysisSessionsNestedInput = {
    create?: XOR<UserCreateWithoutAnalysisSessionsInput, UserUncheckedCreateWithoutAnalysisSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalysisSessionsInput
    upsert?: UserUpsertWithoutAnalysisSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnalysisSessionsInput, UserUpdateWithoutAnalysisSessionsInput>, UserUncheckedUpdateWithoutAnalysisSessionsInput>
  }

  export type AnalysisMessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AnalysisMessageCreateWithoutSessionInput, AnalysisMessageUncheckedCreateWithoutSessionInput> | AnalysisMessageCreateWithoutSessionInput[] | AnalysisMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AnalysisMessageCreateOrConnectWithoutSessionInput | AnalysisMessageCreateOrConnectWithoutSessionInput[]
    upsert?: AnalysisMessageUpsertWithWhereUniqueWithoutSessionInput | AnalysisMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AnalysisMessageCreateManySessionInputEnvelope
    set?: AnalysisMessageWhereUniqueInput | AnalysisMessageWhereUniqueInput[]
    disconnect?: AnalysisMessageWhereUniqueInput | AnalysisMessageWhereUniqueInput[]
    delete?: AnalysisMessageWhereUniqueInput | AnalysisMessageWhereUniqueInput[]
    connect?: AnalysisMessageWhereUniqueInput | AnalysisMessageWhereUniqueInput[]
    update?: AnalysisMessageUpdateWithWhereUniqueWithoutSessionInput | AnalysisMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AnalysisMessageUpdateManyWithWhereWithoutSessionInput | AnalysisMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AnalysisMessageScalarWhereInput | AnalysisMessageScalarWhereInput[]
  }

  export type AnalysisMessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AnalysisMessageCreateWithoutSessionInput, AnalysisMessageUncheckedCreateWithoutSessionInput> | AnalysisMessageCreateWithoutSessionInput[] | AnalysisMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AnalysisMessageCreateOrConnectWithoutSessionInput | AnalysisMessageCreateOrConnectWithoutSessionInput[]
    upsert?: AnalysisMessageUpsertWithWhereUniqueWithoutSessionInput | AnalysisMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AnalysisMessageCreateManySessionInputEnvelope
    set?: AnalysisMessageWhereUniqueInput | AnalysisMessageWhereUniqueInput[]
    disconnect?: AnalysisMessageWhereUniqueInput | AnalysisMessageWhereUniqueInput[]
    delete?: AnalysisMessageWhereUniqueInput | AnalysisMessageWhereUniqueInput[]
    connect?: AnalysisMessageWhereUniqueInput | AnalysisMessageWhereUniqueInput[]
    update?: AnalysisMessageUpdateWithWhereUniqueWithoutSessionInput | AnalysisMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AnalysisMessageUpdateManyWithWhereWithoutSessionInput | AnalysisMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AnalysisMessageScalarWhereInput | AnalysisMessageScalarWhereInput[]
  }

  export type AnalysisSessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<AnalysisSessionCreateWithoutMessagesInput, AnalysisSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AnalysisSessionCreateOrConnectWithoutMessagesInput
    connect?: AnalysisSessionWhereUniqueInput
  }

  export type AnalysisSessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<AnalysisSessionCreateWithoutMessagesInput, AnalysisSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AnalysisSessionCreateOrConnectWithoutMessagesInput
    upsert?: AnalysisSessionUpsertWithoutMessagesInput
    connect?: AnalysisSessionWhereUniqueInput
    update?: XOR<XOR<AnalysisSessionUpdateToOneWithWhereWithoutMessagesInput, AnalysisSessionUpdateWithoutMessagesInput>, AnalysisSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type BatchAnalysisResultCreateNestedManyWithoutJobInput = {
    create?: XOR<BatchAnalysisResultCreateWithoutJobInput, BatchAnalysisResultUncheckedCreateWithoutJobInput> | BatchAnalysisResultCreateWithoutJobInput[] | BatchAnalysisResultUncheckedCreateWithoutJobInput[]
    connectOrCreate?: BatchAnalysisResultCreateOrConnectWithoutJobInput | BatchAnalysisResultCreateOrConnectWithoutJobInput[]
    createMany?: BatchAnalysisResultCreateManyJobInputEnvelope
    connect?: BatchAnalysisResultWhereUniqueInput | BatchAnalysisResultWhereUniqueInput[]
  }

  export type BatchAnalysisResultUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<BatchAnalysisResultCreateWithoutJobInput, BatchAnalysisResultUncheckedCreateWithoutJobInput> | BatchAnalysisResultCreateWithoutJobInput[] | BatchAnalysisResultUncheckedCreateWithoutJobInput[]
    connectOrCreate?: BatchAnalysisResultCreateOrConnectWithoutJobInput | BatchAnalysisResultCreateOrConnectWithoutJobInput[]
    createMany?: BatchAnalysisResultCreateManyJobInputEnvelope
    connect?: BatchAnalysisResultWhereUniqueInput | BatchAnalysisResultWhereUniqueInput[]
  }

  export type BatchAnalysisResultUpdateManyWithoutJobNestedInput = {
    create?: XOR<BatchAnalysisResultCreateWithoutJobInput, BatchAnalysisResultUncheckedCreateWithoutJobInput> | BatchAnalysisResultCreateWithoutJobInput[] | BatchAnalysisResultUncheckedCreateWithoutJobInput[]
    connectOrCreate?: BatchAnalysisResultCreateOrConnectWithoutJobInput | BatchAnalysisResultCreateOrConnectWithoutJobInput[]
    upsert?: BatchAnalysisResultUpsertWithWhereUniqueWithoutJobInput | BatchAnalysisResultUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: BatchAnalysisResultCreateManyJobInputEnvelope
    set?: BatchAnalysisResultWhereUniqueInput | BatchAnalysisResultWhereUniqueInput[]
    disconnect?: BatchAnalysisResultWhereUniqueInput | BatchAnalysisResultWhereUniqueInput[]
    delete?: BatchAnalysisResultWhereUniqueInput | BatchAnalysisResultWhereUniqueInput[]
    connect?: BatchAnalysisResultWhereUniqueInput | BatchAnalysisResultWhereUniqueInput[]
    update?: BatchAnalysisResultUpdateWithWhereUniqueWithoutJobInput | BatchAnalysisResultUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: BatchAnalysisResultUpdateManyWithWhereWithoutJobInput | BatchAnalysisResultUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: BatchAnalysisResultScalarWhereInput | BatchAnalysisResultScalarWhereInput[]
  }

  export type BatchAnalysisResultUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<BatchAnalysisResultCreateWithoutJobInput, BatchAnalysisResultUncheckedCreateWithoutJobInput> | BatchAnalysisResultCreateWithoutJobInput[] | BatchAnalysisResultUncheckedCreateWithoutJobInput[]
    connectOrCreate?: BatchAnalysisResultCreateOrConnectWithoutJobInput | BatchAnalysisResultCreateOrConnectWithoutJobInput[]
    upsert?: BatchAnalysisResultUpsertWithWhereUniqueWithoutJobInput | BatchAnalysisResultUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: BatchAnalysisResultCreateManyJobInputEnvelope
    set?: BatchAnalysisResultWhereUniqueInput | BatchAnalysisResultWhereUniqueInput[]
    disconnect?: BatchAnalysisResultWhereUniqueInput | BatchAnalysisResultWhereUniqueInput[]
    delete?: BatchAnalysisResultWhereUniqueInput | BatchAnalysisResultWhereUniqueInput[]
    connect?: BatchAnalysisResultWhereUniqueInput | BatchAnalysisResultWhereUniqueInput[]
    update?: BatchAnalysisResultUpdateWithWhereUniqueWithoutJobInput | BatchAnalysisResultUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: BatchAnalysisResultUpdateManyWithWhereWithoutJobInput | BatchAnalysisResultUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: BatchAnalysisResultScalarWhereInput | BatchAnalysisResultScalarWhereInput[]
  }

  export type BatchAnalysisJobCreateNestedOneWithoutResultsInput = {
    create?: XOR<BatchAnalysisJobCreateWithoutResultsInput, BatchAnalysisJobUncheckedCreateWithoutResultsInput>
    connectOrCreate?: BatchAnalysisJobCreateOrConnectWithoutResultsInput
    connect?: BatchAnalysisJobWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BatchAnalysisJobUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<BatchAnalysisJobCreateWithoutResultsInput, BatchAnalysisJobUncheckedCreateWithoutResultsInput>
    connectOrCreate?: BatchAnalysisJobCreateOrConnectWithoutResultsInput
    upsert?: BatchAnalysisJobUpsertWithoutResultsInput
    connect?: BatchAnalysisJobWhereUniqueInput
    update?: XOR<XOR<BatchAnalysisJobUpdateToOneWithWhereWithoutResultsInput, BatchAnalysisJobUpdateWithoutResultsInput>, BatchAnalysisJobUncheckedUpdateWithoutResultsInput>
  }

  export type FAQAnalysisResultCreateNestedManyWithoutJobInput = {
    create?: XOR<FAQAnalysisResultCreateWithoutJobInput, FAQAnalysisResultUncheckedCreateWithoutJobInput> | FAQAnalysisResultCreateWithoutJobInput[] | FAQAnalysisResultUncheckedCreateWithoutJobInput[]
    connectOrCreate?: FAQAnalysisResultCreateOrConnectWithoutJobInput | FAQAnalysisResultCreateOrConnectWithoutJobInput[]
    createMany?: FAQAnalysisResultCreateManyJobInputEnvelope
    connect?: FAQAnalysisResultWhereUniqueInput | FAQAnalysisResultWhereUniqueInput[]
  }

  export type FAQAnalysisResultUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<FAQAnalysisResultCreateWithoutJobInput, FAQAnalysisResultUncheckedCreateWithoutJobInput> | FAQAnalysisResultCreateWithoutJobInput[] | FAQAnalysisResultUncheckedCreateWithoutJobInput[]
    connectOrCreate?: FAQAnalysisResultCreateOrConnectWithoutJobInput | FAQAnalysisResultCreateOrConnectWithoutJobInput[]
    createMany?: FAQAnalysisResultCreateManyJobInputEnvelope
    connect?: FAQAnalysisResultWhereUniqueInput | FAQAnalysisResultWhereUniqueInput[]
  }

  export type FAQAnalysisResultUpdateManyWithoutJobNestedInput = {
    create?: XOR<FAQAnalysisResultCreateWithoutJobInput, FAQAnalysisResultUncheckedCreateWithoutJobInput> | FAQAnalysisResultCreateWithoutJobInput[] | FAQAnalysisResultUncheckedCreateWithoutJobInput[]
    connectOrCreate?: FAQAnalysisResultCreateOrConnectWithoutJobInput | FAQAnalysisResultCreateOrConnectWithoutJobInput[]
    upsert?: FAQAnalysisResultUpsertWithWhereUniqueWithoutJobInput | FAQAnalysisResultUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: FAQAnalysisResultCreateManyJobInputEnvelope
    set?: FAQAnalysisResultWhereUniqueInput | FAQAnalysisResultWhereUniqueInput[]
    disconnect?: FAQAnalysisResultWhereUniqueInput | FAQAnalysisResultWhereUniqueInput[]
    delete?: FAQAnalysisResultWhereUniqueInput | FAQAnalysisResultWhereUniqueInput[]
    connect?: FAQAnalysisResultWhereUniqueInput | FAQAnalysisResultWhereUniqueInput[]
    update?: FAQAnalysisResultUpdateWithWhereUniqueWithoutJobInput | FAQAnalysisResultUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: FAQAnalysisResultUpdateManyWithWhereWithoutJobInput | FAQAnalysisResultUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: FAQAnalysisResultScalarWhereInput | FAQAnalysisResultScalarWhereInput[]
  }

  export type FAQAnalysisResultUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<FAQAnalysisResultCreateWithoutJobInput, FAQAnalysisResultUncheckedCreateWithoutJobInput> | FAQAnalysisResultCreateWithoutJobInput[] | FAQAnalysisResultUncheckedCreateWithoutJobInput[]
    connectOrCreate?: FAQAnalysisResultCreateOrConnectWithoutJobInput | FAQAnalysisResultCreateOrConnectWithoutJobInput[]
    upsert?: FAQAnalysisResultUpsertWithWhereUniqueWithoutJobInput | FAQAnalysisResultUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: FAQAnalysisResultCreateManyJobInputEnvelope
    set?: FAQAnalysisResultWhereUniqueInput | FAQAnalysisResultWhereUniqueInput[]
    disconnect?: FAQAnalysisResultWhereUniqueInput | FAQAnalysisResultWhereUniqueInput[]
    delete?: FAQAnalysisResultWhereUniqueInput | FAQAnalysisResultWhereUniqueInput[]
    connect?: FAQAnalysisResultWhereUniqueInput | FAQAnalysisResultWhereUniqueInput[]
    update?: FAQAnalysisResultUpdateWithWhereUniqueWithoutJobInput | FAQAnalysisResultUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: FAQAnalysisResultUpdateManyWithWhereWithoutJobInput | FAQAnalysisResultUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: FAQAnalysisResultScalarWhereInput | FAQAnalysisResultScalarWhereInput[]
  }

  export type FAQAnalysisJobCreateNestedOneWithoutResultsInput = {
    create?: XOR<FAQAnalysisJobCreateWithoutResultsInput, FAQAnalysisJobUncheckedCreateWithoutResultsInput>
    connectOrCreate?: FAQAnalysisJobCreateOrConnectWithoutResultsInput
    connect?: FAQAnalysisJobWhereUniqueInput
  }

  export type FAQAnalysisJobUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<FAQAnalysisJobCreateWithoutResultsInput, FAQAnalysisJobUncheckedCreateWithoutResultsInput>
    connectOrCreate?: FAQAnalysisJobCreateOrConnectWithoutResultsInput
    upsert?: FAQAnalysisJobUpsertWithoutResultsInput
    connect?: FAQAnalysisJobWhereUniqueInput
    update?: XOR<XOR<FAQAnalysisJobUpdateToOneWithWhereWithoutResultsInput, FAQAnalysisJobUpdateWithoutResultsInput>, FAQAnalysisJobUncheckedUpdateWithoutResultsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
  }

  export type SavedFilterCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    criteria: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedFilterUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    criteria: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedFilterCreateOrConnectWithoutUserInput = {
    where: SavedFilterWhereUniqueInput
    create: XOR<SavedFilterCreateWithoutUserInput, SavedFilterUncheckedCreateWithoutUserInput>
  }

  export type SavedFilterCreateManyUserInputEnvelope = {
    data: SavedFilterCreateManyUserInput | SavedFilterCreateManyUserInput[]
  }

  export type AnalysisSessionCreateWithoutUserInput = {
    id?: string
    title: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: AnalysisMessageCreateNestedManyWithoutSessionInput
  }

  export type AnalysisSessionUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: AnalysisMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AnalysisSessionCreateOrConnectWithoutUserInput = {
    where: AnalysisSessionWhereUniqueInput
    create: XOR<AnalysisSessionCreateWithoutUserInput, AnalysisSessionUncheckedCreateWithoutUserInput>
  }

  export type AnalysisSessionCreateManyUserInputEnvelope = {
    data: AnalysisSessionCreateManyUserInput | AnalysisSessionCreateManyUserInput[]
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
  }

  export type ApiKeyCreateWithoutUserInput = {
    id?: string
    name: string
    key: string
    permissions: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    key: string
    permissions: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[]
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
  }

  export type SavedFilterUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedFilterWhereUniqueInput
    update: XOR<SavedFilterUpdateWithoutUserInput, SavedFilterUncheckedUpdateWithoutUserInput>
    create: XOR<SavedFilterCreateWithoutUserInput, SavedFilterUncheckedCreateWithoutUserInput>
  }

  export type SavedFilterUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedFilterWhereUniqueInput
    data: XOR<SavedFilterUpdateWithoutUserInput, SavedFilterUncheckedUpdateWithoutUserInput>
  }

  export type SavedFilterUpdateManyWithWhereWithoutUserInput = {
    where: SavedFilterScalarWhereInput
    data: XOR<SavedFilterUpdateManyMutationInput, SavedFilterUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedFilterScalarWhereInput = {
    AND?: SavedFilterScalarWhereInput | SavedFilterScalarWhereInput[]
    OR?: SavedFilterScalarWhereInput[]
    NOT?: SavedFilterScalarWhereInput | SavedFilterScalarWhereInput[]
    id?: StringFilter<"SavedFilter"> | string
    userId?: StringFilter<"SavedFilter"> | string
    name?: StringFilter<"SavedFilter"> | string
    description?: StringNullableFilter<"SavedFilter"> | string | null
    criteria?: StringFilter<"SavedFilter"> | string
    isDefault?: BoolFilter<"SavedFilter"> | boolean
    createdAt?: DateTimeFilter<"SavedFilter"> | Date | string
    updatedAt?: DateTimeFilter<"SavedFilter"> | Date | string
  }

  export type AnalysisSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: AnalysisSessionWhereUniqueInput
    update: XOR<AnalysisSessionUpdateWithoutUserInput, AnalysisSessionUncheckedUpdateWithoutUserInput>
    create: XOR<AnalysisSessionCreateWithoutUserInput, AnalysisSessionUncheckedCreateWithoutUserInput>
  }

  export type AnalysisSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: AnalysisSessionWhereUniqueInput
    data: XOR<AnalysisSessionUpdateWithoutUserInput, AnalysisSessionUncheckedUpdateWithoutUserInput>
  }

  export type AnalysisSessionUpdateManyWithWhereWithoutUserInput = {
    where: AnalysisSessionScalarWhereInput
    data: XOR<AnalysisSessionUpdateManyMutationInput, AnalysisSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type AnalysisSessionScalarWhereInput = {
    AND?: AnalysisSessionScalarWhereInput | AnalysisSessionScalarWhereInput[]
    OR?: AnalysisSessionScalarWhereInput[]
    NOT?: AnalysisSessionScalarWhereInput | AnalysisSessionScalarWhereInput[]
    id?: StringFilter<"AnalysisSession"> | string
    userId?: StringFilter<"AnalysisSession"> | string
    title?: StringFilter<"AnalysisSession"> | string
    context?: StringNullableFilter<"AnalysisSession"> | string | null
    createdAt?: DateTimeFilter<"AnalysisSession"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisSession"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    key?: StringFilter<"ApiKey"> | string
    permissions?: StringFilter<"ApiKey"> | string
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
  }

  export type UserRoleCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
  }

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterUncheckedCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type RoleCreateWithoutUserRolesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUncheckedUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRolePermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
  }

  export type PermissionCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RoleUpsertWithoutRolePermissionsInput = {
    update: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RoleUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterUncheckedCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUncheckedUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSavedFiltersInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavedFiltersInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavedFiltersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedFiltersInput, UserUncheckedCreateWithoutSavedFiltersInput>
  }

  export type UserUpsertWithoutSavedFiltersInput = {
    update: XOR<UserUpdateWithoutSavedFiltersInput, UserUncheckedUpdateWithoutSavedFiltersInput>
    create: XOR<UserCreateWithoutSavedFiltersInput, UserUncheckedCreateWithoutSavedFiltersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedFiltersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedFiltersInput, UserUncheckedUpdateWithoutSavedFiltersInput>
  }

  export type UserUpdateWithoutSavedFiltersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedFiltersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAnalysisSessionsInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnalysisSessionsInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnalysisSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalysisSessionsInput, UserUncheckedCreateWithoutAnalysisSessionsInput>
  }

  export type AnalysisMessageCreateWithoutSessionInput = {
    id?: string
    role: string
    content: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type AnalysisMessageUncheckedCreateWithoutSessionInput = {
    id?: string
    role: string
    content: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type AnalysisMessageCreateOrConnectWithoutSessionInput = {
    where: AnalysisMessageWhereUniqueInput
    create: XOR<AnalysisMessageCreateWithoutSessionInput, AnalysisMessageUncheckedCreateWithoutSessionInput>
  }

  export type AnalysisMessageCreateManySessionInputEnvelope = {
    data: AnalysisMessageCreateManySessionInput | AnalysisMessageCreateManySessionInput[]
  }

  export type UserUpsertWithoutAnalysisSessionsInput = {
    update: XOR<UserUpdateWithoutAnalysisSessionsInput, UserUncheckedUpdateWithoutAnalysisSessionsInput>
    create: XOR<UserCreateWithoutAnalysisSessionsInput, UserUncheckedCreateWithoutAnalysisSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnalysisSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnalysisSessionsInput, UserUncheckedUpdateWithoutAnalysisSessionsInput>
  }

  export type UserUpdateWithoutAnalysisSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalysisSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AnalysisMessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: AnalysisMessageWhereUniqueInput
    update: XOR<AnalysisMessageUpdateWithoutSessionInput, AnalysisMessageUncheckedUpdateWithoutSessionInput>
    create: XOR<AnalysisMessageCreateWithoutSessionInput, AnalysisMessageUncheckedCreateWithoutSessionInput>
  }

  export type AnalysisMessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: AnalysisMessageWhereUniqueInput
    data: XOR<AnalysisMessageUpdateWithoutSessionInput, AnalysisMessageUncheckedUpdateWithoutSessionInput>
  }

  export type AnalysisMessageUpdateManyWithWhereWithoutSessionInput = {
    where: AnalysisMessageScalarWhereInput
    data: XOR<AnalysisMessageUpdateManyMutationInput, AnalysisMessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type AnalysisMessageScalarWhereInput = {
    AND?: AnalysisMessageScalarWhereInput | AnalysisMessageScalarWhereInput[]
    OR?: AnalysisMessageScalarWhereInput[]
    NOT?: AnalysisMessageScalarWhereInput | AnalysisMessageScalarWhereInput[]
    id?: StringFilter<"AnalysisMessage"> | string
    sessionId?: StringFilter<"AnalysisMessage"> | string
    role?: StringFilter<"AnalysisMessage"> | string
    content?: StringFilter<"AnalysisMessage"> | string
    metadata?: StringNullableFilter<"AnalysisMessage"> | string | null
    createdAt?: DateTimeFilter<"AnalysisMessage"> | Date | string
  }

  export type AnalysisSessionCreateWithoutMessagesInput = {
    id?: string
    title: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAnalysisSessionsInput
  }

  export type AnalysisSessionUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    title: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisSessionCreateOrConnectWithoutMessagesInput = {
    where: AnalysisSessionWhereUniqueInput
    create: XOR<AnalysisSessionCreateWithoutMessagesInput, AnalysisSessionUncheckedCreateWithoutMessagesInput>
  }

  export type AnalysisSessionUpsertWithoutMessagesInput = {
    update: XOR<AnalysisSessionUpdateWithoutMessagesInput, AnalysisSessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<AnalysisSessionCreateWithoutMessagesInput, AnalysisSessionUncheckedCreateWithoutMessagesInput>
    where?: AnalysisSessionWhereInput
  }

  export type AnalysisSessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: AnalysisSessionWhereInput
    data: XOR<AnalysisSessionUpdateWithoutMessagesInput, AnalysisSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type AnalysisSessionUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnalysisSessionsNestedInput
  }

  export type AnalysisSessionUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterUncheckedCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUncheckedUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutApiKeysInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string
    email: string
    password: string
    name: string
    isActive?: boolean
    failedAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    savedFilters?: SavedFilterUncheckedCreateNestedManyWithoutUserInput
    analysisSessions?: AnalysisSessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    savedFilters?: SavedFilterUncheckedUpdateManyWithoutUserNestedInput
    analysisSessions?: AnalysisSessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BatchAnalysisResultCreateWithoutJobInput = {
    id?: string
    originalTimestamp: Date | string
    tenantId: string
    sessionId?: string | null
    userInput: string
    llmResponse: string
    analysisPrompt: string
    analysisResult: string
    modelName: string
    latencyMs: number
    inputTokens?: number
    outputTokens?: number
    qualityScore?: number | null
    relevance?: number | null
    completeness?: number | null
    clarity?: number | null
    sentiment?: string | null
    summaryText?: string | null
    issues?: string | null
    improvements?: string | null
    missingData?: string | null
    issueCount?: number | null
    avgScore?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type BatchAnalysisResultUncheckedCreateWithoutJobInput = {
    id?: string
    originalTimestamp: Date | string
    tenantId: string
    sessionId?: string | null
    userInput: string
    llmResponse: string
    analysisPrompt: string
    analysisResult: string
    modelName: string
    latencyMs: number
    inputTokens?: number
    outputTokens?: number
    qualityScore?: number | null
    relevance?: number | null
    completeness?: number | null
    clarity?: number | null
    sentiment?: string | null
    summaryText?: string | null
    issues?: string | null
    improvements?: string | null
    missingData?: string | null
    issueCount?: number | null
    avgScore?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type BatchAnalysisResultCreateOrConnectWithoutJobInput = {
    where: BatchAnalysisResultWhereUniqueInput
    create: XOR<BatchAnalysisResultCreateWithoutJobInput, BatchAnalysisResultUncheckedCreateWithoutJobInput>
  }

  export type BatchAnalysisResultCreateManyJobInputEnvelope = {
    data: BatchAnalysisResultCreateManyJobInput | BatchAnalysisResultCreateManyJobInput[]
  }

  export type BatchAnalysisResultUpsertWithWhereUniqueWithoutJobInput = {
    where: BatchAnalysisResultWhereUniqueInput
    update: XOR<BatchAnalysisResultUpdateWithoutJobInput, BatchAnalysisResultUncheckedUpdateWithoutJobInput>
    create: XOR<BatchAnalysisResultCreateWithoutJobInput, BatchAnalysisResultUncheckedCreateWithoutJobInput>
  }

  export type BatchAnalysisResultUpdateWithWhereUniqueWithoutJobInput = {
    where: BatchAnalysisResultWhereUniqueInput
    data: XOR<BatchAnalysisResultUpdateWithoutJobInput, BatchAnalysisResultUncheckedUpdateWithoutJobInput>
  }

  export type BatchAnalysisResultUpdateManyWithWhereWithoutJobInput = {
    where: BatchAnalysisResultScalarWhereInput
    data: XOR<BatchAnalysisResultUpdateManyMutationInput, BatchAnalysisResultUncheckedUpdateManyWithoutJobInput>
  }

  export type BatchAnalysisResultScalarWhereInput = {
    AND?: BatchAnalysisResultScalarWhereInput | BatchAnalysisResultScalarWhereInput[]
    OR?: BatchAnalysisResultScalarWhereInput[]
    NOT?: BatchAnalysisResultScalarWhereInput | BatchAnalysisResultScalarWhereInput[]
    id?: StringFilter<"BatchAnalysisResult"> | string
    jobId?: StringFilter<"BatchAnalysisResult"> | string
    originalTimestamp?: DateTimeFilter<"BatchAnalysisResult"> | Date | string
    tenantId?: StringFilter<"BatchAnalysisResult"> | string
    sessionId?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    userInput?: StringFilter<"BatchAnalysisResult"> | string
    llmResponse?: StringFilter<"BatchAnalysisResult"> | string
    analysisPrompt?: StringFilter<"BatchAnalysisResult"> | string
    analysisResult?: StringFilter<"BatchAnalysisResult"> | string
    modelName?: StringFilter<"BatchAnalysisResult"> | string
    latencyMs?: IntFilter<"BatchAnalysisResult"> | number
    inputTokens?: IntFilter<"BatchAnalysisResult"> | number
    outputTokens?: IntFilter<"BatchAnalysisResult"> | number
    qualityScore?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    relevance?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    completeness?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    clarity?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    sentiment?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    summaryText?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    issues?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    improvements?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    missingData?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    issueCount?: IntNullableFilter<"BatchAnalysisResult"> | number | null
    avgScore?: FloatNullableFilter<"BatchAnalysisResult"> | number | null
    status?: StringFilter<"BatchAnalysisResult"> | string
    errorMessage?: StringNullableFilter<"BatchAnalysisResult"> | string | null
    createdAt?: DateTimeFilter<"BatchAnalysisResult"> | Date | string
  }

  export type BatchAnalysisJobCreateWithoutResultsInput = {
    id?: string
    status: string
    targetDate: Date | string
    tenantId?: string | null
    sampleSize?: number
    promptTemplate: string
    totalItems?: number
    processedItems?: number
    failedItems?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    cancelRequested?: boolean
    createdAt?: Date | string
  }

  export type BatchAnalysisJobUncheckedCreateWithoutResultsInput = {
    id?: string
    status: string
    targetDate: Date | string
    tenantId?: string | null
    sampleSize?: number
    promptTemplate: string
    totalItems?: number
    processedItems?: number
    failedItems?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    cancelRequested?: boolean
    createdAt?: Date | string
  }

  export type BatchAnalysisJobCreateOrConnectWithoutResultsInput = {
    where: BatchAnalysisJobWhereUniqueInput
    create: XOR<BatchAnalysisJobCreateWithoutResultsInput, BatchAnalysisJobUncheckedCreateWithoutResultsInput>
  }

  export type BatchAnalysisJobUpsertWithoutResultsInput = {
    update: XOR<BatchAnalysisJobUpdateWithoutResultsInput, BatchAnalysisJobUncheckedUpdateWithoutResultsInput>
    create: XOR<BatchAnalysisJobCreateWithoutResultsInput, BatchAnalysisJobUncheckedCreateWithoutResultsInput>
    where?: BatchAnalysisJobWhereInput
  }

  export type BatchAnalysisJobUpdateToOneWithWhereWithoutResultsInput = {
    where?: BatchAnalysisJobWhereInput
    data: XOR<BatchAnalysisJobUpdateWithoutResultsInput, BatchAnalysisJobUncheckedUpdateWithoutResultsInput>
  }

  export type BatchAnalysisJobUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    promptTemplate?: StringFieldUpdateOperationsInput | string
    totalItems?: IntFieldUpdateOperationsInput | number
    processedItems?: IntFieldUpdateOperationsInput | number
    failedItems?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancelRequested?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchAnalysisJobUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    promptTemplate?: StringFieldUpdateOperationsInput | string
    totalItems?: IntFieldUpdateOperationsInput | number
    processedItems?: IntFieldUpdateOperationsInput | number
    failedItems?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    cancelRequested?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQAnalysisResultCreateWithoutJobInput = {
    id?: string
    rank: number
    representativeQuestion: string
    frequency: number
    reasonAnalysis: string
    isMerged?: boolean
    questions: string
    createdAt?: Date | string
  }

  export type FAQAnalysisResultUncheckedCreateWithoutJobInput = {
    id?: string
    rank: number
    representativeQuestion: string
    frequency: number
    reasonAnalysis: string
    isMerged?: boolean
    questions: string
    createdAt?: Date | string
  }

  export type FAQAnalysisResultCreateOrConnectWithoutJobInput = {
    where: FAQAnalysisResultWhereUniqueInput
    create: XOR<FAQAnalysisResultCreateWithoutJobInput, FAQAnalysisResultUncheckedCreateWithoutJobInput>
  }

  export type FAQAnalysisResultCreateManyJobInputEnvelope = {
    data: FAQAnalysisResultCreateManyJobInput | FAQAnalysisResultCreateManyJobInput[]
  }

  export type FAQAnalysisResultUpsertWithWhereUniqueWithoutJobInput = {
    where: FAQAnalysisResultWhereUniqueInput
    update: XOR<FAQAnalysisResultUpdateWithoutJobInput, FAQAnalysisResultUncheckedUpdateWithoutJobInput>
    create: XOR<FAQAnalysisResultCreateWithoutJobInput, FAQAnalysisResultUncheckedCreateWithoutJobInput>
  }

  export type FAQAnalysisResultUpdateWithWhereUniqueWithoutJobInput = {
    where: FAQAnalysisResultWhereUniqueInput
    data: XOR<FAQAnalysisResultUpdateWithoutJobInput, FAQAnalysisResultUncheckedUpdateWithoutJobInput>
  }

  export type FAQAnalysisResultUpdateManyWithWhereWithoutJobInput = {
    where: FAQAnalysisResultScalarWhereInput
    data: XOR<FAQAnalysisResultUpdateManyMutationInput, FAQAnalysisResultUncheckedUpdateManyWithoutJobInput>
  }

  export type FAQAnalysisResultScalarWhereInput = {
    AND?: FAQAnalysisResultScalarWhereInput | FAQAnalysisResultScalarWhereInput[]
    OR?: FAQAnalysisResultScalarWhereInput[]
    NOT?: FAQAnalysisResultScalarWhereInput | FAQAnalysisResultScalarWhereInput[]
    id?: StringFilter<"FAQAnalysisResult"> | string
    jobId?: StringFilter<"FAQAnalysisResult"> | string
    rank?: IntFilter<"FAQAnalysisResult"> | number
    representativeQuestion?: StringFilter<"FAQAnalysisResult"> | string
    frequency?: IntFilter<"FAQAnalysisResult"> | number
    reasonAnalysis?: StringFilter<"FAQAnalysisResult"> | string
    isMerged?: BoolFilter<"FAQAnalysisResult"> | boolean
    questions?: StringFilter<"FAQAnalysisResult"> | string
    createdAt?: DateTimeFilter<"FAQAnalysisResult"> | Date | string
  }

  export type FAQAnalysisJobCreateWithoutResultsInput = {
    id?: string
    status?: string
    tenantId?: string | null
    periodDays?: number
    topN?: number
    totalQuestions?: number | null
    clusterCount?: number | null
    llmMergeApplied?: boolean
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type FAQAnalysisJobUncheckedCreateWithoutResultsInput = {
    id?: string
    status?: string
    tenantId?: string | null
    periodDays?: number
    topN?: number
    totalQuestions?: number | null
    clusterCount?: number | null
    llmMergeApplied?: boolean
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type FAQAnalysisJobCreateOrConnectWithoutResultsInput = {
    where: FAQAnalysisJobWhereUniqueInput
    create: XOR<FAQAnalysisJobCreateWithoutResultsInput, FAQAnalysisJobUncheckedCreateWithoutResultsInput>
  }

  export type FAQAnalysisJobUpsertWithoutResultsInput = {
    update: XOR<FAQAnalysisJobUpdateWithoutResultsInput, FAQAnalysisJobUncheckedUpdateWithoutResultsInput>
    create: XOR<FAQAnalysisJobCreateWithoutResultsInput, FAQAnalysisJobUncheckedCreateWithoutResultsInput>
    where?: FAQAnalysisJobWhereInput
  }

  export type FAQAnalysisJobUpdateToOneWithWhereWithoutResultsInput = {
    where?: FAQAnalysisJobWhereInput
    data: XOR<FAQAnalysisJobUpdateWithoutResultsInput, FAQAnalysisJobUncheckedUpdateWithoutResultsInput>
  }

  export type FAQAnalysisJobUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    periodDays?: IntFieldUpdateOperationsInput | number
    topN?: IntFieldUpdateOperationsInput | number
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    clusterCount?: NullableIntFieldUpdateOperationsInput | number | null
    llmMergeApplied?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQAnalysisJobUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    periodDays?: IntFieldUpdateOperationsInput | number
    topN?: IntFieldUpdateOperationsInput | number
    totalQuestions?: NullableIntFieldUpdateOperationsInput | number | null
    clusterCount?: NullableIntFieldUpdateOperationsInput | number | null
    llmMergeApplied?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type SavedFilterCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    criteria: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisSessionCreateManyUserInput = {
    id?: string
    title: string
    context?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ApiKeyCreateManyUserInput = {
    id?: string
    name: string
    key: string
    permissions: string
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SavedFilterUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedFilterUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedFilterUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AnalysisMessageUpdateManyWithoutSessionNestedInput
  }

  export type AnalysisSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: AnalysisMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AnalysisSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRoleCreateManyRoleInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisMessageCreateManySessionInput = {
    id?: string
    role: string
    content: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type AnalysisMessageUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisMessageUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisMessageUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchAnalysisResultCreateManyJobInput = {
    id?: string
    originalTimestamp: Date | string
    tenantId: string
    sessionId?: string | null
    userInput: string
    llmResponse: string
    analysisPrompt: string
    analysisResult: string
    modelName: string
    latencyMs: number
    inputTokens?: number
    outputTokens?: number
    qualityScore?: number | null
    relevance?: number | null
    completeness?: number | null
    clarity?: number | null
    sentiment?: string | null
    summaryText?: string | null
    issues?: string | null
    improvements?: string | null
    missingData?: string | null
    issueCount?: number | null
    avgScore?: number | null
    status: string
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type BatchAnalysisResultUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userInput?: StringFieldUpdateOperationsInput | string
    llmResponse?: StringFieldUpdateOperationsInput | string
    analysisPrompt?: StringFieldUpdateOperationsInput | string
    analysisResult?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    latencyMs?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relevance?: NullableIntFieldUpdateOperationsInput | number | null
    completeness?: NullableIntFieldUpdateOperationsInput | number | null
    clarity?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    summaryText?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    missingData?: NullableStringFieldUpdateOperationsInput | string | null
    issueCount?: NullableIntFieldUpdateOperationsInput | number | null
    avgScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchAnalysisResultUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userInput?: StringFieldUpdateOperationsInput | string
    llmResponse?: StringFieldUpdateOperationsInput | string
    analysisPrompt?: StringFieldUpdateOperationsInput | string
    analysisResult?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    latencyMs?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relevance?: NullableIntFieldUpdateOperationsInput | number | null
    completeness?: NullableIntFieldUpdateOperationsInput | number | null
    clarity?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    summaryText?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    missingData?: NullableStringFieldUpdateOperationsInput | string | null
    issueCount?: NullableIntFieldUpdateOperationsInput | number | null
    avgScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchAnalysisResultUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userInput?: StringFieldUpdateOperationsInput | string
    llmResponse?: StringFieldUpdateOperationsInput | string
    analysisPrompt?: StringFieldUpdateOperationsInput | string
    analysisResult?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    latencyMs?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    relevance?: NullableIntFieldUpdateOperationsInput | number | null
    completeness?: NullableIntFieldUpdateOperationsInput | number | null
    clarity?: NullableIntFieldUpdateOperationsInput | number | null
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    summaryText?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    improvements?: NullableStringFieldUpdateOperationsInput | string | null
    missingData?: NullableStringFieldUpdateOperationsInput | string | null
    issueCount?: NullableIntFieldUpdateOperationsInput | number | null
    avgScore?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQAnalysisResultCreateManyJobInput = {
    id?: string
    rank: number
    representativeQuestion: string
    frequency: number
    reasonAnalysis: string
    isMerged?: boolean
    questions: string
    createdAt?: Date | string
  }

  export type FAQAnalysisResultUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    representativeQuestion?: StringFieldUpdateOperationsInput | string
    frequency?: IntFieldUpdateOperationsInput | number
    reasonAnalysis?: StringFieldUpdateOperationsInput | string
    isMerged?: BoolFieldUpdateOperationsInput | boolean
    questions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQAnalysisResultUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    representativeQuestion?: StringFieldUpdateOperationsInput | string
    frequency?: IntFieldUpdateOperationsInput | number
    reasonAnalysis?: StringFieldUpdateOperationsInput | string
    isMerged?: BoolFieldUpdateOperationsInput | boolean
    questions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQAnalysisResultUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    representativeQuestion?: StringFieldUpdateOperationsInput | string
    frequency?: IntFieldUpdateOperationsInput | number
    reasonAnalysis?: StringFieldUpdateOperationsInput | string
    isMerged?: BoolFieldUpdateOperationsInput | boolean
    questions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}